-- ============================================
-- Agent Management Functions - PostgreSQL Version
-- ============================================
CREATE OR REPLACE FUNCTION sp_upsert_agent(p_first_name VARCHAR(50),
    p_last_name VARCHAR(50),
    p_email VARCHAR(100),
    p_phone VARCHAR(20),
    p_password_hash VARCHAR(200),
    p_agent_id UUID DEFAULT NULL,
    p_avatar TEXT DEFAULT NULL)
RETURNS TABLE(agent_id UUID)
LANGUAGE plpgsql
AS $$
DECLARE
    v_agent_id UUID;
BEGIN
    IF p_agent_id IS NULL THEN
        v_agent_id := gen_random_uuid();

        INSERT INTO agent (agent_id, first_name, last_name, email, phone, password_hash, avatar)
        VALUES (v_agent_id, p_first_name, p_last_name, p_email, p_phone, p_password_hash, p_avatar);

        -- Insert default reminder settings for new agent
        INSERT INTO reminder_settings (agent_id, reminder_type, days_before, time_of_day)
        VALUES 
            (v_agent_id, 'Policy Expiry', 30, '09:00'),
            (v_agent_id, 'Birthday', 1, '08:00'),
            (v_agent_id, 'Appointment', 1, '18:00'),
            (v_agent_id, 'Call', 0, '10:00');
    ELSE
        v_agent_id := p_agent_id;
        
        UPDATE agent
        SET 
            first_name = p_first_name,
            last_name = p_last_name,
            email = p_email,
            phone = p_phone,
            password_hash = p_password_hash,
            avatar = p_avatar,
            modified_date = NOW()
        WHERE agent.agent_id = p_agent_id;
    END IF;

    RETURN QUERY SELECT v_agent_id;
END;
$;

-- Get Agent Profile
CREATE OR REPLACE FUNCTION sp_get_agent(p_agent_id UUID)
RETURNS TABLE(
    agent_id UUID,
    first_name VARCHAR(50),
    last_name VARCHAR(50),
    email VARCHAR(100),
    phone VARCHAR(20),
    password_hash VARCHAR(200),
    avatar TEXT,
    created_date TIMESTAMP,
    modified_date TIMESTAMP,
    is_active BOOLEAN,
    dark_mode BOOLEAN,
    email_notifications BOOLEAN,
    sms_notifications BOOLEAN,
    whatsapp_notifications BOOLEAN,
    push_notifications BOOLEAN,
    sound_enabled BOOLEAN
)
LANGUAGE plpgsql
AS $$
BEGIN
    RETURN QUERY
    SELECT 
        a.agent_id,
        a.first_name,
        a.last_name,
        a.email,
        a.phone,
        a.password_hash,
        a.avatar,
        a.created_date,
        a.modified_date,
        a.is_active,
        s.dark_mode,
        s.email_notifications,
        s.sms_notifications,
        s.whatsapp_notifications,
        s.push_notifications,
        s.sound_enabled
    FROM agent a
    LEFT JOIN agent_settings s ON a.agent_id = s.agent_id
    WHERE a.agent_id = p_agent_id AND a.is_active = true;
END;
$;

-- Update Agent Settings
CREATE OR REPLACE FUNCTION sp_update_agent_settings(p_agent_id UUID,
    p_dark_mode BOOLEAN DEFAULT NULL,
    p_email_notifications BOOLEAN DEFAULT NULL,
    p_sms_notifications BOOLEAN DEFAULT NULL,
    p_whatsapp_notifications BOOLEAN DEFAULT NULL,
    p_push_notifications BOOLEAN DEFAULT NULL,
    p_sound_enabled BOOLEAN DEFAULT NULL)
RETURNS VOID
LANGUAGE plpgsql
AS $
BEGIN
    -- Check if settings exist, create if not
    IF NOT EXISTS (SELECT 1 FROM agent_settings WHERE agent_id = p_agent_id) THEN
        INSERT INTO agent_settings (agent_id) VALUES (p_agent_id);
    END IF;
    
    UPDATE agent_settings 
    SET 
        dark_mode = COALESCE(p_dark_mode, dark_mode),
        email_notifications = COALESCE(p_email_notifications, email_notifications),
        sms_notifications = COALESCE(p_sms_notifications, sms_notifications),
        whatsapp_notifications = COALESCE(p_whatsapp_notifications, whatsapp_notifications),
        push_notifications = COALESCE(p_push_notifications, push_notifications),
        sound_enabled = COALESCE(p_sound_enabled, sound_enabled),
        modified_date = NOW()
    WHERE agent_id = p_agent_id;
END;
$;

-- Get Insurance Companies
CREATE OR REPLACE FUNCTION sp_get_insurance_companies()
RETURNS TABLE(company_id INTEGER, company_name VARCHAR(200))
LANGUAGE plpgsql
AS $
BEGIN
    RETURN QUERY
    SELECT ic.company_id, ic.company_name
    FROM insurance_companies ic
    WHERE ic.is_active = true
    ORDER BY ic.company_name;
END;
$;

-- Get Policy Types
CREATE OR REPLACE FUNCTION sp_get_policy_types()
RETURNS TABLE(type_id INTEGER, type_name VARCHAR(200))
LANGUAGE plpgsql
AS $
BEGIN
    RETURN QUERY
    SELECT pt.type_id, pt.type_name
    FROM policy_types pt
    WHERE pt.is_active = true
    ORDER BY pt.type_name;
END;
$;

-- Authenticate Agent
CREATE OR REPLACE FUNCTION sp_authenticate_agent(p_email VARCHAR(100))
RETURNS TABLE(
    agent_id UUID,
    first_name VARCHAR(50),
    last_name VARCHAR(50),
    email VARCHAR(100),
    phone VARCHAR(20),
    password_hash VARCHAR(200)
)
LANGUAGE plpgsql
AS $$
BEGIN
    RETURN QUERY
    SELECT
        a.agent_id,
        a.first_name,
        a.last_name,
        a.email,
        a.phone,
        a.password_hash
    FROM agent a
    WHERE a.email = p_email AND a.is_active = true;
END;
$;

-- ============================================
-- Authentication Functions
-- ============================================

-- Login Agent
CREATE OR REPLACE FUNCTION sp_login_agent(p_email VARCHAR(100),
    p_password VARCHAR(200))
RETURNS TABLE(
    success INTEGER,
    message TEXT,
    agent_id UUID,
    stored_password_hash VARCHAR(200),
    agent_profile JSON
)
LANGUAGE plpgsql
AS $$
DECLARE
    v_agent_id UUID;
    v_stored_hash VARCHAR(256);
    v_is_active BOOLEAN;
    v_agent_profile JSON;
BEGIN
    -- Get agent details
    SELECT 
        a.agent_id,
        a.password_hash,
        a.is_active
    INTO v_agent_id, v_stored_hash, v_is_active
    FROM agent a
    WHERE a.email = p_email;
    
    -- Check if agent exists and is active
    IF v_agent_id IS NULL THEN
        RETURN QUERY SELECT 
            0::INTEGER,
            'Invalid email or password'::TEXT,
            NULL::UUID,
            NULL::VARCHAR(200),
            NULL::JSON;
        RETURN;
    END IF;
    
    IF v_is_active = false THEN
        RETURN QUERY SELECT 
            0::INTEGER,
            'Account is deactivated'::TEXT,
            NULL::UUID,
            NULL::VARCHAR(200),
            NULL::JSON;
        RETURN;
    END IF;
    
    -- Build agent profile JSON
    SELECT json_build_object(
        'agent_id', a.agent_id,
        'first_name', a.first_name,
        'last_name', a.last_name,
        'email', a.email,
        'phone', a.phone,
        'avatar', a.avatar,
        'created_date', a.created_date,
        'is_active', a.is_active,
        'dark_mode', s.dark_mode,
        'email_notifications', s.email_notifications,
        'sms_notifications', s.sms_notifications,
        'whatsapp_notifications', s.whatsapp_notifications,
        'push_notifications', s.push_notifications,
        'sound_enabled', s.sound_enabled
    )
    INTO v_agent_profile
    FROM agent a
    LEFT JOIN agent_settings s ON a.agent_id = s.agent_id
    WHERE a.agent_id = v_agent_id;
    
    -- Note: Password verification should be done in application layer
    RETURN QUERY SELECT 
        1::INTEGER,
        'Login successful'::TEXT,
        v_agent_id,
        v_stored_hash::VARCHAR(200),
        v_agent_profile;
END;
$;

-- Register New Agent
CREATE OR REPLACE FUNCTION sp_register_agent(p_first_name VARCHAR(50),
    p_last_name VARCHAR(50),
    p_email VARCHAR(100),
    p_phone VARCHAR(20),
    p_password_hash VARCHAR(256),
    p_avatar TEXT DEFAULT NULL)
RETURNS TABLE(
    success INTEGER,
    message TEXT,
    agent_id UUID
)
LANGUAGE plpgsql
AS $$
DECLARE
    v_agent_id UUID := gen_random_uuid();
BEGIN
    -- Check if email already exists
    IF EXISTS(SELECT 1 FROM agent WHERE email = p_email) THEN
        RETURN QUERY SELECT 
            0::INTEGER,
            'Email already exists'::TEXT,
            NULL::UUID;
        RETURN;
    END IF;
    
    BEGIN
        -- Insert agent
        INSERT INTO agent (agent_id, first_name, last_name, email, phone, password_hash, avatar)
        VALUES (v_agent_id, p_first_name, p_last_name, p_email, p_phone, p_password_hash, p_avatar);
        
        -- Insert default agent settings
        INSERT INTO agent_settings (agent_id)
        VALUES (v_agent_id);
        
        -- Insert default reminder settings
        INSERT INTO reminder_settings (agent_id, reminder_type, days_before)
        VALUES 
            (v_agent_id, 'Policy Expiry', 7),
            (v_agent_id, 'Birthday', 1),
            (v_agent_id, 'Appointment', 1);
        
        -- Insert default notification preferences
        INSERT INTO agent_notification_preferences (agent_id, notification_type)
        VALUES 
            (v_agent_id, 'appointment'),
            (v_agent_id, 'birthday'),
            (v_agent_id, 'policy_expiry');
        
        RETURN QUERY SELECT 
            1::INTEGER,
            'Registration successful'::TEXT,
            v_agent_id;
            
    EXCEPTION WHEN OTHERS THEN
        RETURN QUERY SELECT 
            0::INTEGER,
            SQLERRM::TEXT,
            NULL::UUID;
    END;
END;
$;

-- Change Password
CREATE OR REPLACE FUNCTION sp_change_password(p_agent_id UUID,
    p_old_password_hash VARCHAR(256),
    p_new_password_hash VARCHAR(256))
RETURNS TABLE(
    success INTEGER,
    message TEXT
)
LANGUAGE plpgsql
AS $$
DECLARE
    v_stored_hash VARCHAR(256);
BEGIN
    -- Get current password hash
    SELECT password_hash INTO v_stored_hash
    FROM agent 
    WHERE agent_id = p_agent_id AND is_active = true;
    
    IF v_stored_hash IS NULL THEN
        RETURN QUERY SELECT 
            0::INTEGER,
            'Agent not found or inactive'::TEXT;
        RETURN;
    END IF;
    
    -- Note: Old password verification should be done in application layer
    -- Update password
    UPDATE agent 
    SET 
        password_hash = p_new_password_hash,
        modified_date = NOW()
    WHERE agent_id = p_agent_id;
    
    RETURN QUERY SELECT 
        1::INTEGER,
        'Password changed successfully'::TEXT;
END;
$;

-- Request Password Reset
CREATE OR REPLACE FUNCTION sp_request_password_reset(p_email VARCHAR(100))
RETURNS TABLE(
    success INTEGER,
    message TEXT,
    agent_id UUID,
    email VARCHAR(100)
)
LANGUAGE plpgsql
AS $$
DECLARE
    v_agent_id UUID;
BEGIN
    -- Check if agent exists
    SELECT a.agent_id INTO v_agent_id
    FROM agent a
    WHERE a.email = p_email AND a.is_active = true;
    
    IF v_agent_id IS NULL THEN
        RETURN QUERY SELECT 
            0::INTEGER,
            'Email not found'::TEXT,
            NULL::UUID,
            NULL::VARCHAR(100);
        RETURN;
    END IF;
    
    -- Return agent ID for reset token generation in application
    RETURN QUERY SELECT 
        1::INTEGER,
        'Reset request valid'::TEXT,
        v_agent_id,
        p_email;
END;
$;

-- Complete Password Reset
CREATE OR REPLACE FUNCTION sp_reset_password(p_agent_id UUID,
    p_new_password_hash VARCHAR(256))
RETURNS TABLE(
    success INTEGER,
    message TEXT
)
LANGUAGE plpgsql
AS $$
DECLARE
    v_rows_affected INTEGER;
BEGIN
    -- Update password
    UPDATE agent 
    SET 
        password_hash = p_new_password_hash,
        modified_date = NOW()
    WHERE agent_id = p_agent_id AND is_active = true;
    
    GET DIAGNOSTICS v_rows_affected = ROW_COUNT;
    
    IF v_rows_affected = 0 THEN
        RETURN QUERY SELECT 
            0::INTEGER,
            'Invalid reset request'::TEXT;
        RETURN;
    END IF;
    
    RETURN QUERY SELECT 
        1::INTEGER,
        'Password reset successful'::TEXT;
END;
$;

-- ============================================
-- Analytics and Dashboard Functions
-- ============================================

-- Get Dashboard Overview
CREATE OR REPLACE FUNCTION sp_get_dashboard_overview(p_agent_id UUID)
RETURNS TABLE(
    total_clients BIGINT,
    total_prospects BIGINT,
    active_policies BIGINT,
    today_appointments BIGINT,
    week_appointments BIGINT,
    month_appointments BIGINT,
    completed_appointments BIGINT,
    pending_reminders BIGINT,
    today_birthdays BIGINT,
    expiring_policies BIGINT
)
LANGUAGE plpgsql
AS $
DECLARE
    v_today DATE := CURRENT_DATE;
    v_week_start DATE := v_today - EXTRACT(DOW FROM v_today)::INTEGER;
    v_week_end DATE := v_week_start + 6;
    v_month_start DATE := DATE_TRUNC('month', v_today)::DATE;
    v_month_end DATE := (DATE_TRUNC('month', v_today) + INTERVAL '1 month - 1 day')::DATE;
BEGIN
    RETURN QUERY
    SELECT 
        -- Client Statistics
        COUNT(DISTINCT CASE WHEN c.is_client = true THEN c.client_id END) AS total_clients,
        COUNT(DISTINCT CASE WHEN c.is_client = false THEN c.client_id END) AS total_prospects,
        
        -- Policy Statistics
        COUNT(DISTINCT CASE WHEN cp.status = 'Active' THEN cp.policy_id END) AS active_policies,
        
        -- Appointment Statistics
        COUNT(DISTINCT CASE WHEN a.appointment_date = v_today THEN a.appointment_id END) AS today_appointments,
        COUNT(DISTINCT CASE WHEN a.appointment_date BETWEEN v_week_start AND v_week_end THEN a.appointment_id END) AS week_appointments,
        COUNT(DISTINCT CASE WHEN a.appointment_date BETWEEN v_month_start AND v_month_end THEN a.appointment_id END) AS month_appointments,
        COUNT(DISTINCT CASE WHEN a.status = 'Completed' THEN a.appointment_id END) AS completed_appointments,
        
        -- Reminder Statistics
        COUNT(DISTINCT CASE WHEN r.status = 'Active' AND r.reminder_date <= v_today THEN r.reminder_id END) AS pending_reminders,
        
        -- Birthday Statistics
        COUNT(DISTINCT CASE WHEN EXTRACT(DAY FROM c.date_of_birth) = EXTRACT(DAY FROM v_today) 
                                AND EXTRACT(MONTH FROM c.date_of_birth) = EXTRACT(MONTH FROM v_today) 
                           THEN c.client_id END) AS today_birthdays,
        
        -- Expiring Policies
        COUNT(DISTINCT CASE WHEN cp.end_date BETWEEN v_today AND v_today + 30 AND cp.status = 'Active' 
                           THEN cp.policy_id END) AS expiring_policies
        
    FROM clients c
    LEFT JOIN client_policies cp ON c.client_id = cp.client_id AND cp.is_active = true
    LEFT JOIN appointments a ON c.client_id = a.client_id AND a.is_active = true
    LEFT JOIN reminders r ON c.client_id = r.client_id
    WHERE c.agent_id = p_agent_id AND c.is_active = true;
END;
$;

-- Get Today's Activities
CREATE OR REPLACE FUNCTION sp_get_today_activities(p_agent_id UUID)
RETURNS TABLE(
    activity_type TEXT,
    entity_id UUID,
    client_name TEXT,
    title TEXT,
    time_range TEXT,
    location TEXT,
    type TEXT,
    status TEXT,
    notes TEXT,
    priority TEXT,
    client_phone TEXT
)
LANGUAGE plpgsql
AS $
DECLARE
    v_today DATE := CURRENT_DATE;
BEGIN
    -- Today's Appointments
    RETURN QUERY
    SELECT 
        'appointment'::TEXT AS activity_type,
        a.appointment_id AS entity_id,
        a.client_name::TEXT,
        a.title::TEXT,
        (TO_CHAR(a.start_time, 'HH24:MI') || ' - ' || TO_CHAR(a.end_time, 'HH24:MI'))::TEXT AS time_range,
        a.location::TEXT,
        a.type::TEXT,
        a.status::TEXT,
        a.notes::TEXT,
        a.priority::TEXT,
        c.phone_number::TEXT AS client_phone
    FROM appointments a
    LEFT JOIN clients c ON a.client_id = c.client_id
    WHERE a.agent_id = p_agent_id 
        AND a.appointment_date = v_today 
        AND a.is_active = true
        AND a.status NOT IN ('Cancelled')
    
    UNION ALL
    
    -- Today's Reminders
    SELECT 
        'reminder'::TEXT AS activity_type,
        r.reminder_id AS entity_id,
        r.client_name::TEXT,
        r.title::TEXT,
        COALESCE(TO_CHAR(r.reminder_time, 'HH24:MI'), '')::TEXT AS time_range,
        ''::TEXT AS location,
        r.reminder_type::TEXT AS type,
        r.status::TEXT,
        r.notes::TEXT,
        r.priority::TEXT,
        c.phone_number::TEXT AS client_phone
    FROM reminders r
    LEFT JOIN clients c ON r.client_id = c.client_id
    WHERE r.agent_id = p_agent_id 
        AND r.reminder_date = v_today 
        AND r.status = 'Active'
    
    UNION ALL
    
    -- Today's Birthdays
    SELECT 
        'birthday'::TEXT AS activity_type,
        c.client_id AS entity_id,
        (c.first_name || ' ' || c.surname)::TEXT AS client_name,
        ('Birthday - ' || c.first_name || ' ' || c.surname)::TEXT AS title,
        ''::TEXT AS time_range,
        c.address::TEXT AS location,
        'Birthday'::TEXT AS type,
        'Active'::TEXT AS status,
        ('Age: ' || EXTRACT(YEAR FROM AGE(c.date_of_birth)))::TEXT AS notes,
        'Medium'::TEXT AS priority,
        c.phone_number::TEXT AS client_phone
    FROM clients c
    WHERE c.agent_id = p_agent_id 
        AND c.is_active = true
        AND EXTRACT(DAY FROM c.date_of_birth) = EXTRACT(DAY FROM v_today)
        AND EXTRACT(MONTH FROM c.date_of_birth) = EXTRACT(MONTH FROM v_today)
    
    ORDER BY time_range;
END;
$;

-- ============================================
-- Agent Management Functions - PostgreSQL Version
-- ============================================

-- Create or Update Agent Profile
CREATE OR REPLACE FUNCTION sp_upsert_agent(p_first_name VARCHAR(50),
    p_last_name VARCHAR(50),
    p_email VARCHAR(100),
    p_phone VARCHAR(20),
    p_password_hash VARCHAR(200),
    p_agent_id UUID DEFAULT NULL,
    p_avatar TEXT DEFAULT NULL)
RETURNS TABLE(agent_id UUID)
LANGUAGE plpgsql
AS $$
DECLARE
    v_agent_id UUID;
BEGIN
    IF p_agent_id IS NULL THEN
        v_agent_id := gen_random_uuid();

        INSERT INTO agent (agent_id, first_name, last_name, email, phone, password_hash, avatar)
        VALUES (v_agent_id, p_first_name, p_last_name, p_email, p_phone, p_password_hash, p_avatar);

        INSERT INTO agent_settings (agent_id) VALUES (v_agent_id);

        INSERT INTO reminder_settings (agent_id, reminder_type, days_before, time_of_day)
        VALUES 
            (v_agent_id, 'Policy Expiry', 30, '09:00'),
            (v_agent_id, 'Birthday', 1, '08:00'),
            (v_agent_id, 'Appointment', 1, '18:00'),
            (v_agent_id, 'Call', 0, '10:00');
    ELSE
        v_agent_id := p_agent_id;
        
        UPDATE agent
        SET 
            first_name = p_first_name,
            last_name = p_last_name,
            email = p_email,
            phone = p_phone,
            password_hash = p_password_hash,
            avatar = p_avatar,
            modified_date = NOW()
        WHERE agent.agent_id = p_agent_id;
    END IF;

    RETURN QUERY SELECT v_agent_id;
END;
$;

-- Get Agent Profile
CREATE OR REPLACE FUNCTION sp_get_agent(p_agent_id UUID)
RETURNS TABLE(
    agent_id UUID,
    first_name VARCHAR(50),
    last_name VARCHAR(50),
    email VARCHAR(100),
    phone VARCHAR(20),
    password_hash VARCHAR(200),
    avatar TEXT,
    created_date TIMESTAMP,
    modified_date TIMESTAMP,
    is_active BOOLEAN,
    dark_mode BOOLEAN,
    email_notifications BOOLEAN,
    sms_notifications BOOLEAN,
    whatsapp_notifications BOOLEAN,
    push_notifications BOOLEAN,
    sound_enabled BOOLEAN
)
LANGUAGE plpgsql
AS $$
BEGIN
    RETURN QUERY
    SELECT 
        a.agent_id,
        a.first_name,
        a.last_name,
        a.email,
        a.phone,
        a.password_hash,
        a.avatar,
        a.created_date,
        a.modified_date,
        a.is_active,
        s.dark_mode,
        s.email_notifications,
        s.sms_notifications,
        s.whatsapp_notifications,
        s.push_notifications,
        s.sound_enabled
    FROM agent a
    LEFT JOIN agent_settings s ON a.agent_id = s.agent_id
    WHERE a.agent_id = p_agent_id AND a.is_active = true;
END;
$;

-- Update Agent Settings
CREATE OR REPLACE FUNCTION sp_update_agent_settings(p_agent_id UUID,
    p_dark_mode BOOLEAN DEFAULT NULL,
    p_email_notifications BOOLEAN DEFAULT NULL,
    p_sms_notifications BOOLEAN DEFAULT NULL,
    p_whatsapp_notifications BOOLEAN DEFAULT NULL,
    p_push_notifications BOOLEAN DEFAULT NULL,
    p_sound_enabled BOOLEAN DEFAULT NULL)
RETURNS VOID
LANGUAGE plpgsql
AS $
BEGIN
    -- Check if settings exist, create if not
    IF NOT EXISTS (SELECT 1 FROM agent_settings WHERE agent_id = p_agent_id) THEN
        INSERT INTO agent_settings (agent_id) VALUES (p_agent_id);
    END IF;
    
    UPDATE agent_settings 
    SET 
        dark_mode = COALESCE(p_dark_mode, dark_mode),
        email_notifications = COALESCE(p_email_notifications, email_notifications),
        sms_notifications = COALESCE(p_sms_notifications, sms_notifications),
        whatsapp_notifications = COALESCE(p_whatsapp_notifications, whatsapp_notifications),
        push_notifications = COALESCE(p_push_notifications, push_notifications),
        sound_enabled = COALESCE(p_sound_enabled, sound_enabled),
        modified_date = NOW()
    WHERE agent_id = p_agent_id;
END;
$;

-- Get Insurance Companies
CREATE OR REPLACE FUNCTION sp_get_insurance_companies()
RETURNS TABLE(company_id INTEGER, company_name VARCHAR(200))
LANGUAGE plpgsql
AS $
BEGIN
    RETURN QUERY
    SELECT ic.company_id, ic.company_name
    FROM insurance_companies ic
    WHERE ic.is_active = true
    ORDER BY ic.company_name;
END;
$;

-- Get Policy Types
CREATE OR REPLACE FUNCTION sp_get_policy_types()
RETURNS TABLE(type_id INTEGER, type_name VARCHAR(200))
LANGUAGE plpgsql
AS $
BEGIN
    RETURN QUERY
    SELECT pt.type_id, pt.type_name
    FROM policy_types pt
    WHERE pt.is_active = true
    ORDER BY pt.type_name;
END;
$;

-- Authenticate Agent
CREATE OR REPLACE FUNCTION sp_authenticate_agent(p_email VARCHAR(100))
RETURNS TABLE(
    agent_id UUID,
    first_name VARCHAR(50),
    last_name VARCHAR(50),
    email VARCHAR(100),
    phone VARCHAR(20),
    password_hash VARCHAR(200)
)
LANGUAGE plpgsql
AS $$
BEGIN
    RETURN QUERY
    SELECT
        a.agent_id,
        a.first_name,
        a.last_name,
        a.email,
        a.phone,
        a.password_hash
    FROM agent a
    WHERE a.email = p_email AND a.is_active = true;
END;
$;

-- ============================================
-- Authentication Functions
-- ============================================

-- Login Agent
CREATE OR REPLACE FUNCTION sp_login_agent(p_email VARCHAR(100),
    p_password VARCHAR(200))
RETURNS TABLE(
    success INTEGER,
    message TEXT,
    agent_id UUID,
    stored_password_hash VARCHAR(200),
    agent_profile JSON
)
LANGUAGE plpgsql
AS $$
DECLARE
    v_agent_id UUID;
    v_stored_hash VARCHAR(256);
    v_is_active BOOLEAN;
    v_agent_profile JSON;
BEGIN
    -- Get agent details
    SELECT 
        a.agent_id,
        a.password_hash,
        a.is_active
    INTO v_agent_id, v_stored_hash, v_is_active
    FROM agent a
    WHERE a.email = p_email;
    
    -- Check if agent exists and is active
    IF v_agent_id IS NULL THEN
        RETURN QUERY SELECT 
            0::INTEGER,
            'Invalid email or password'::TEXT,
            NULL::UUID,
            NULL::VARCHAR(200),
            NULL::JSON;
        RETURN;
    END IF;
    
    IF v_is_active = false THEN
        RETURN QUERY SELECT 
            0::INTEGER,
            'Account is deactivated'::TEXT,
            NULL::UUID,
            NULL::VARCHAR(200),
            NULL::JSON;
        RETURN;
    END IF;
    
    -- Build agent profile JSON
    SELECT json_build_object(
        'agent_id', a.agent_id,
        'first_name', a.first_name,
        'last_name', a.last_name,
        'email', a.email,
        'phone', a.phone,
        'avatar', a.avatar,
        'created_date', a.created_date,
        'is_active', a.is_active,
        'dark_mode', s.dark_mode,
        'email_notifications', s.email_notifications,
        'sms_notifications', s.sms_notifications,
        'whatsapp_notifications', s.whatsapp_notifications,
        'push_notifications', s.push_notifications,
        'sound_enabled', s.sound_enabled
    )
    INTO v_agent_profile
    FROM agent a
    LEFT JOIN agent_settings s ON a.agent_id = s.agent_id
    WHERE a.agent_id = v_agent_id;
    
    -- Note: Password verification should be done in application layer
    RETURN QUERY SELECT 
        1::INTEGER,
        'Login successful'::TEXT,
        v_agent_id,
        v_stored_hash::VARCHAR(200),
        v_agent_profile;
END;
$;

-- Register New Agent
CREATE OR REPLACE FUNCTION sp_register_agent(p_first_name VARCHAR(50),
    p_last_name VARCHAR(50),
    p_email VARCHAR(100),
    p_phone VARCHAR(20),
    p_password_hash VARCHAR(256),
    p_avatar TEXT DEFAULT NULL)
RETURNS TABLE(
    success INTEGER,
    message TEXT,
    agent_id UUID
)
LANGUAGE plpgsql
AS $$
DECLARE
    v_agent_id UUID := gen_random_uuid();
BEGIN
    -- Check if email already exists
    IF EXISTS(SELECT 1 FROM agent WHERE email = p_email) THEN
        RETURN QUERY SELECT 
            0::INTEGER,
            'Email already exists'::TEXT,
            NULL::UUID;
        RETURN;
    END IF;
    
    BEGIN
        -- Insert agent
        INSERT INTO agent (agent_id, first_name, last_name, email, phone, password_hash, avatar)
        VALUES (v_agent_id, p_first_name, p_last_name, p_email, p_phone, p_password_hash, p_avatar);
        
        -- Insert default agent settings
        INSERT INTO agent_settings (agent_id)
        VALUES (v_agent_id);
        
        -- Insert default reminder settings
        INSERT INTO reminder_settings (agent_id, reminder_type, days_before)
        VALUES 
            (v_agent_id, 'Policy Expiry', 7),
            (v_agent_id, 'Birthday', 1),
            (v_agent_id, 'Appointment', 1);
        
        -- Insert default notification preferences
        INSERT INTO agent_notification_preferences (agent_id, notification_type)
        VALUES 
            (v_agent_id, 'appointment'),
            (v_agent_id, 'birthday'),
            (v_agent_id, 'policy_expiry');
        
        RETURN QUERY SELECT 
            1::INTEGER,
            'Registration successful'::TEXT,
            v_agent_id;
            
    EXCEPTION WHEN OTHERS THEN
        RETURN QUERY SELECT 
            0::INTEGER,
            SQLERRM::TEXT,
            NULL::UUID;
    END;
END;
$;

-- Change Password
CREATE OR REPLACE FUNCTION sp_change_password(p_agent_id UUID,
    p_old_password_hash VARCHAR(256),
    p_new_password_hash VARCHAR(256))
RETURNS TABLE(
    success INTEGER,
    message TEXT
)
LANGUAGE plpgsql
AS $$
DECLARE
    v_stored_hash VARCHAR(256);
BEGIN
    -- Get current password hash
    SELECT password_hash INTO v_stored_hash
    FROM agent 
    WHERE agent_id = p_agent_id AND is_active = true;
    
    IF v_stored_hash IS NULL THEN
        RETURN QUERY SELECT 
            0::INTEGER,
            'Agent not found or inactive'::TEXT;
        RETURN;
    END IF;
    
    -- Note: Old password verification should be done in application layer
    -- Update password
    UPDATE agent 
    SET 
        password_hash = p_new_password_hash,
        modified_date = NOW()
    WHERE agent_id = p_agent_id;
    
    RETURN QUERY SELECT 
        1::INTEGER,
        'Password changed successfully'::TEXT;
END;
$;

-- Request Password Reset
CREATE OR REPLACE FUNCTION sp_request_password_reset(p_email VARCHAR(100))
RETURNS TABLE(
    success INTEGER,
    message TEXT,
    agent_id UUID,
    email VARCHAR(100)
)
LANGUAGE plpgsql
AS $$
DECLARE
    v_agent_id UUID;
BEGIN
    -- Check if agent exists
    SELECT a.agent_id INTO v_agent_id
    FROM agent a
    WHERE a.email = p_email AND a.is_active = true;
    
    IF v_agent_id IS NULL THEN
        RETURN QUERY SELECT 
            0::INTEGER,
            'Email not found'::TEXT,
            NULL::UUID,
            NULL::VARCHAR(100);
        RETURN;
    END IF;
    
    -- Return agent ID for reset token generation in application
    RETURN QUERY SELECT 
        1::INTEGER,
        'Reset request valid'::TEXT,
        v_agent_id,
        p_email;
END;
$;

-- Complete Password Reset
CREATE OR REPLACE FUNCTION sp_reset_password(p_agent_id UUID,
    p_new_password_hash VARCHAR(256))
RETURNS TABLE(
    success INTEGER,
    message TEXT
)
LANGUAGE plpgsql
AS $$
DECLARE
    v_rows_affected INTEGER;
BEGIN
    -- Update password
    UPDATE agent 
    SET 
        password_hash = p_new_password_hash,
        modified_date = NOW()
    WHERE agent_id = p_agent_id AND is_active = true;
    
    GET DIAGNOSTICS v_rows_affected = ROW_COUNT;
    
    IF v_rows_affected = 0 THEN
        RETURN QUERY SELECT 
            0::INTEGER,
            'Invalid reset request'::TEXT;
        RETURN;
    END IF;
    
    RETURN QUERY SELECT 
        1::INTEGER,
        'Password reset successful'::TEXT;
END;
$;

-- ============================================
-- Analytics and Dashboard Functions
-- ============================================

-- Get Dashboard Overview
CREATE OR REPLACE FUNCTION sp_get_dashboard_overview(p_agent_id UUID)
RETURNS TABLE(
    total_clients BIGINT,
    total_prospects BIGINT,
    active_policies BIGINT,
    today_appointments BIGINT,
    week_appointments BIGINT,
    month_appointments BIGINT,
    completed_appointments BIGINT,
    pending_reminders BIGINT,
    today_birthdays BIGINT,
    expiring_policies BIGINT
)
LANGUAGE plpgsql
AS $
DECLARE
    v_today DATE := CURRENT_DATE;
    v_week_start DATE := v_today - EXTRACT(DOW FROM v_today)::INTEGER;
    v_week_end DATE := v_week_start + 6;
    v_month_start DATE := DATE_TRUNC('month', v_today)::DATE;
    v_month_end DATE := (DATE_TRUNC('month', v_today) + INTERVAL '1 month - 1 day')::DATE;
BEGIN
    RETURN QUERY
    SELECT 
        -- Client Statistics
        COUNT(DISTINCT CASE WHEN c.is_client = true THEN c.client_id END) AS total_clients,
        COUNT(DISTINCT CASE WHEN c.is_client = false THEN c.client_id END) AS total_prospects,
        
        -- Policy Statistics
        COUNT(DISTINCT CASE WHEN cp.status = 'Active' THEN cp.policy_id END) AS active_policies,
        
        -- Appointment Statistics
        COUNT(DISTINCT CASE WHEN a.appointment_date = v_today THEN a.appointment_id END) AS today_appointments,
        COUNT(DISTINCT CASE WHEN a.appointment_date BETWEEN v_week_start AND v_week_end THEN a.appointment_id END) AS week_appointments,
        COUNT(DISTINCT CASE WHEN a.appointment_date BETWEEN v_month_start AND v_month_end THEN a.appointment_id END) AS month_appointments,
        COUNT(DISTINCT CASE WHEN a.status = 'Completed' THEN a.appointment_id END) AS completed_appointments,
        
        -- Reminder Statistics
        COUNT(DISTINCT CASE WHEN r.status = 'Active' AND r.reminder_date <= v_today THEN r.reminder_id END) AS pending_reminders,
        
        -- Birthday Statistics
        COUNT(DISTINCT CASE WHEN EXTRACT(DAY FROM c.date_of_birth) = EXTRACT(DAY FROM v_today) 
                                AND EXTRACT(MONTH FROM c.date_of_birth) = EXTRACT(MONTH FROM v_today) 
                           THEN c.client_id END) AS today_birthdays,
        
        -- Expiring Policies
        COUNT(DISTINCT CASE WHEN cp.end_date BETWEEN v_today AND v_today + 30 AND cp.status = 'Active' 
                           THEN cp.policy_id END) AS expiring_policies
        
    FROM clients c
    LEFT JOIN client_policies cp ON c.client_id = cp.client_id AND cp.is_active = true
    LEFT JOIN appointments a ON c.client_id = a.client_id AND a.is_active = true
    LEFT JOIN reminders r ON c.client_id = r.client_id
    WHERE c.agent_id = p_agent_id AND c.is_active = true;
END;
$;

-- Get Today's Activities
CREATE OR REPLACE FUNCTION sp_get_today_activities(p_agent_id UUID)
RETURNS TABLE(
    activity_type TEXT,
    entity_id UUID,
    client_name TEXT,
    title TEXT,
    time_range TEXT,
    location TEXT,
    type TEXT,
    status TEXT,
    notes TEXT,
    priority TEXT,
    client_phone TEXT
)
LANGUAGE plpgsql
AS $
DECLARE
    v_today DATE := CURRENT_DATE;
BEGIN
    -- Today's Appointments
    RETURN QUERY
    SELECT 
        'appointment'::TEXT AS activity_type,
        a.appointment_id AS entity_id,
        a.client_name::TEXT,
        a.title::TEXT,
        (TO_CHAR(a.start_time, 'HH24:MI') || ' - ' || TO_CHAR(a.end_time, 'HH24:MI'))::TEXT AS time_range,
        a.location::TEXT,
        a.type::TEXT,
        a.status::TEXT,
        a.notes::TEXT,
        a.priority::TEXT,
        c.phone_number::TEXT AS client_phone
    FROM appointments a
    LEFT JOIN clients c ON a.client_id = c.client_id
    WHERE a.agent_id = p_agent_id 
        AND a.appointment_date = v_today 
        AND a.is_active = true
        AND a.status NOT IN ('Cancelled')
    
    UNION ALL
    
    -- Today's Reminders
    SELECT 
        'reminder'::TEXT AS activity_type,
        r.reminder_id AS entity_id,
        r.client_name::TEXT,
        r.title::TEXT,
        COALESCE(TO_CHAR(r.reminder_time, 'HH24:MI'), '')::TEXT AS time_range,
        ''::TEXT AS location,
        r.reminder_type::TEXT AS type,
        r.status::TEXT,
        r.notes::TEXT,
        r.priority::TEXT,
        c.phone_number::TEXT AS client_phone
    FROM reminders r
    LEFT JOIN clients c ON r.client_id = c.client_id
    WHERE r.agent_id = p_agent_id 
        AND r.reminder_date = v_today 
        AND r.status = 'Active'
    
    UNION ALL
    
    -- Today's Birthdays
    SELECT 
        'birthday'::TEXT AS activity_type,
        c.client_id AS entity_id,
        (c.first_name || ' ' || c.surname)::TEXT AS client_name,
        ('Birthday - ' || c.first_name || ' ' || c.surname)::TEXT AS title,
        ''::TEXT AS time_range,
        c.address::TEXT AS location,
        'Birthday'::TEXT AS type,
        'Active'::TEXT AS status,
        ('Age: ' || EXTRACT(YEAR FROM AGE(c.date_of_birth)))::TEXT AS notes,
        'Medium'::TEXT AS priority,
        c.phone_number::TEXT AS client_phone
    FROM clients c
    WHERE c.agent_id = p_agent_id 
        AND c.is_active = true
        AND EXTRACT(DAY FROM c.date_of_birth) = EXTRACT(DAY FROM v_today)
        AND EXTRACT(MONTH FROM c.date_of_birth) = EXTRACT(MONTH FROM v_today)
    
    ORDER BY time_range;
END;
$;

-- ============================================
-- Performance and Analytics Functions
-- ============================================

-- Get Performance Metrics
CREATE OR REPLACE FUNCTION sp_get_performance_metrics(p_agent_id UUID,
    'month',
    'quarter',
    'year',
    p_start_date DATE DEFAULT NULL,
    p_end_date DATE DEFAULT NULL,
    p_period VARCHAR(20) DEFAULT 'month' -- 'week')
RETURNS TABLE(
    period_start DATE,
    period_end DATE,
    period VARCHAR(20),
    new_clients_added BIGINT,
    prospects_converted BIGINT,
    total_appointments BIGINT,
    completed_appointments BIGINT,
    cancelled_appointments BIGINT,
    new_policies BIGINT,
    expired_policies BIGINT,
    reminders_created BIGINT,
    reminders_completed BIGINT,
    messages_scheduled BIGINT,
    messages_sent BIGINT
)
LANGUAGE plpgsql
AS $
DECLARE
    v_start_date DATE;
    v_end_date DATE;
    v_today DATE := CURRENT_DATE;
BEGIN
    -- Set default date range based on period
    IF p_start_date IS NULL OR p_end_date IS NULL THEN
        CASE p_period
            WHEN 'week' THEN
                v_start_date := v_today - EXTRACT(DOW FROM v_today)::INTEGER;
                v_end_date := v_start_date + 6;
            WHEN 'month' THEN
                v_start_date := DATE_TRUNC('month', v_today)::DATE;
                v_end_date := (DATE_TRUNC('month', v_today) + INTERVAL '1 month - 1 day')::DATE;
            WHEN 'quarter' THEN
                v_start_date := DATE_TRUNC('quarter', v_today)::DATE;
                v_end_date := (DATE_TRUNC('quarter', v_today) + INTERVAL '3 months - 1 day')::DATE;
            WHEN 'year' THEN
                v_start_date := DATE_TRUNC('year', v_today)::DATE;
                v_end_date := (DATE_TRUNC('year', v_today) + INTERVAL '1 year - 1 day')::DATE;
        END CASE;
    ELSE
        v_start_date := p_start_date;
        v_end_date := p_end_date;
    END IF;
    
    RETURN QUERY
    SELECT 
        v_start_date AS period_start,
        v_end_date AS period_end,
        p_period AS period,
        
        -- Client Metrics
        COUNT(DISTINCT CASE WHEN c.created_date BETWEEN v_start_date AND v_end_date + 1 THEN c.client_id END) AS new_clients_added,
        COUNT(DISTINCT CASE WHEN c.is_client = true AND c.modified_date BETWEEN v_start_date AND v_end_date + 1 THEN c.client_id END) AS prospects_converted,
        
        -- Appointment Metrics
        COUNT(CASE WHEN a.appointment_date BETWEEN v_start_date AND v_end_date THEN 1 END) AS total_appointments,
        COUNT(CASE WHEN a.appointment_date BETWEEN v_start_date AND v_end_date AND a.status = 'Completed' THEN 1 END) AS completed_appointments,
        COUNT(CASE WHEN a.appointment_date BETWEEN v_start_date AND v_end_date AND a.status = 'Cancelled' THEN 1 END) AS cancelled_appointments,
        
        -- Policy Metrics
        COUNT(CASE WHEN cp.created_date BETWEEN v_start_date AND v_end_date + 1 THEN 1 END) AS new_policies,
        COUNT(CASE WHEN cp.end_date BETWEEN v_start_date AND v_end_date AND cp.status = 'Expired' THEN 1 END) AS expired_policies,
        
        -- Reminder Metrics
        COUNT(CASE WHEN r.created_date BETWEEN v_start_date AND v_end_date + 1 THEN 1 END) AS reminders_created,
        COUNT(CASE WHEN r.completed_date BETWEEN v_start_date AND v_end_date + 1 THEN 1 END) AS reminders_completed,
        
        -- Message Metrics
        COUNT(CASE WHEN am.created_date BETWEEN v_start_date AND v_end_date + 1 THEN 1 END) AS messages_scheduled,
        COUNT(CASE WHEN am.sent_date BETWEEN v_start_date AND v_end_date + 1 THEN 1 END) AS messages_sent
        
    FROM clients c
    LEFT JOIN client_policies cp ON c.client_id = cp.client_id AND cp.is_active = true
    LEFT JOIN appointments a ON c.client_id = a.client_id AND a.is_active = true
    LEFT JOIN reminders r ON c.client_id = r.client_id
    LEFT JOIN automated_messages am ON am.agent_id = c.agent_id
    WHERE c.agent_id = p_agent_id AND c.is_active = true;
END;
$;

-- Update Dashboard Statistics Cache
CREATE OR REPLACE FUNCTION sp_update_dashboard_statistics(p_agent_id UUID,
    p_stat_date DATE DEFAULT NULL)
RETURNS VOID
LANGUAGE plpgsql
AS $
 $
DECLARE
    v_stat_date DATE;
    v_week_start DATE;
    v_week_end DATE;
    v_month_start DATE;
    v_month_end DATE;
    v_total_clients INTEGER;
    v_total_prospects INTEGER;
    v_active_policies INTEGER;
    v_today_appointments INTEGER;
    v_week_appointments INTEGER;
    v_month_appointments INTEGER;
    v_completed_appointments INTEGER;
    v_pending_reminders INTEGER;
    v_today_birthdays INTEGER;
    v_expiring_policies INTEGER;
BEGIN
    v_stat_date := COALESCE(p_stat_date, CURRENT_DATE);
    v_week_start := v_stat_date - EXTRACT(DOW FROM v_stat_date)::INTEGER;
    v_week_end := v_week_start + 6;
    v_month_start := DATE_TRUNC('month', v_stat_date)::DATE;
    v_month_end := (DATE_TRUNC('month', v_stat_date) + INTERVAL '1 month - 1 day')::DATE;
    
    -- Calculate basic client statistics
    SELECT 
        COUNT(CASE WHEN is_client = true THEN 1 END),
        COUNT(CASE WHEN is_client = false THEN 1 END),
        COUNT(CASE WHEN EXTRACT(DAY FROM date_of_birth) = EXTRACT(DAY FROM v_stat_date) 
                    AND EXTRACT(MONTH FROM date_of_birth) = EXTRACT(MONTH FROM v_stat_date) THEN 1 END)
    INTO v_total_clients, v_total_prospects, v_today_birthdays
    FROM clients 
    WHERE agent_id = p_agent_id AND is_active = true;
    
    -- Calculate active policies
    SELECT COUNT(DISTINCT cp.policy_id) INTO v_active_policies
    FROM client_policies cp
    INNER JOIN clients c ON cp.client_id = c.client_id
    WHERE c.agent_id = p_agent_id AND cp.status = 'Active' AND cp.is_active = true AND c.is_active = true;
    
    -- Calculate appointment statistics
    SELECT 
        COUNT(CASE WHEN appointment_date = v_stat_date THEN 1 END),
        COUNT(CASE WHEN appointment_date BETWEEN v_week_start AND v_week_end THEN 1 END),
        COUNT(CASE WHEN appointment_date BETWEEN v_month_start AND v_month_end THEN 1 END),
        COUNT(CASE WHEN status = 'Completed' THEN 1 END)
    INTO v_today_appointments, v_week_appointments, v_month_appointments, v_completed_appointments
    FROM appointments a
    INNER JOIN clients c ON a.client_id = c.client_id
    WHERE c.agent_id = p_agent_id AND a.is_active = true AND c.is_active = true;
    
    -- Calculate pending reminders
    SELECT COUNT(*) INTO v_pending_reminders
    FROM reminders 
    WHERE agent_id = p_agent_id AND status = 'Active' AND reminder_date <= v_stat_date;
    
    -- Calculate expiring policies
    SELECT COUNT(DISTINCT cp.policy_id) INTO v_expiring_policies
    FROM client_policies cp
    INNER JOIN clients c ON cp.client_id = c.client_id
    WHERE c.agent_id = p_agent_id 
        AND cp.status = 'Active' 
        AND cp.end_date BETWEEN v_stat_date AND v_stat_date + 30
        AND cp.is_active = true AND c.is_active = true;
    
    -- Update or insert statistics
    IF EXISTS (SELECT 1 FROM dashboard_statistics WHERE agent_id = p_agent_id AND stat_date = v_stat_date) THEN
        UPDATE dashboard_statistics 
        SET 
            total_clients = v_total_clients,
            total_prospects = v_total_prospects,
            active_policies = v_active_policies,
            today_appointments = v_today_appointments,
            week_appointments = v_week_appointments,
            month_appointments = v_month_appointments,
            completed_appointments = v_completed_appointments,
            pending_reminders = v_pending_reminders,
            today_birthdays = v_today_birthdays,
            expiring_policies = v_expiring_policies,
            updated_date = NOW()
        WHERE agent_id = p_agent_id AND stat_date = v_stat_date;
    ELSE
        INSERT INTO dashboard_statistics (
            agent_id, stat_date, total_clients, total_prospects, active_policies,
            today_appointments, week_appointments, month_appointments, completed_appointments,
            pending_reminders, today_birthdays, expiring_policies
        )
        VALUES (
            p_agent_id, v_stat_date, v_total_clients, v_total_prospects, v_active_policies,
            v_today_appointments, v_week_appointments, v_month_appointments, v_completed_appointments,
            v_pending_reminders, v_today_birthdays, v_expiring_policies
        );
    END IF;
END;
$;

-- Log Activity
CREATE OR REPLACE FUNCTION sp_log_activity(p_agent_id UUID,
    p_activity_type VARCHAR(50),
    p_description VARCHAR(500),
    p_entity_type VARCHAR(50) DEFAULT NULL,
    p_entity_id UUID DEFAULT NULL,
    p_additional_data TEXT DEFAULT NULL)
RETURNS VOID
LANGUAGE plpgsql
AS $
DECLARE
    v_today DATE := CURRENT_DATE;
BEGIN
    INSERT INTO activity_log (
        agent_id, activity_type, entity_type, entity_id, description, additional_data
    )
    VALUES (
        p_agent_id, p_activity_type, p_entity_type, p_entity_id, p_description, p_additional_data
    );
    
    -- Update performance metrics if applicable
    IF p_activity_type IN ('client_created', 'appointment_completed', 'reminder_completed', 'policy_created') THEN
        -- Update or create performance metrics for today
        IF EXISTS (SELECT 1 FROM performance_metrics WHERE agent_id = p_agent_id AND metric_date = v_today) THEN
            UPDATE performance_metrics 
            SET 
                new_clients_added = new_clients_added + CASE WHEN p_activity_type = 'client_created' THEN 1 ELSE 0 END,
                appointments_completed = appointments_completed + CASE WHEN p_activity_type = 'appointment_completed' THEN 1 ELSE 0 END,
                reminders_completed = reminders_completed + CASE WHEN p_activity_type = 'reminder_completed' THEN 1 ELSE 0 END,
                policies_sold = policies_sold + CASE WHEN p_activity_type = 'policy_created' THEN 1 ELSE 0 END
            WHERE agent_id = p_agent_id AND metric_date = v_today;
        ELSE
            INSERT INTO performance_metrics (
                agent_id, metric_date, new_clients_added, appointments_completed, reminders_completed, policies_sold
            )
            VALUES (
                p_agent_id, v_today,
                CASE WHEN p_activity_type = 'client_created' THEN 1 ELSE 0 END,
                CASE WHEN p_activity_type = 'appointment_completed' THEN 1 ELSE 0 END,
                CASE WHEN p_activity_type = 'reminder_completed' THEN 1 ELSE 0 END,
                CASE WHEN p_activity_type = 'policy_created' THEN 1 ELSE 0 END
            );
        END IF;
    END IF;
END;
$;

-- Get Activity Log
CREATE OR REPLACE FUNCTION sp_get_activity_log(p_agent_id UUID,
    p_start_date DATE DEFAULT NULL,
    p_end_date DATE DEFAULT NULL,
    p_activity_type VARCHAR(50) DEFAULT NULL,
    p_page_size INTEGER DEFAULT 50,
    p_page_number INTEGER DEFAULT 1)
RETURNS TABLE(
    activity_id BIGINT,
    activity_type VARCHAR(50),
    entity_type VARCHAR(50),
    entity_id UUID,
    description VARCHAR(500),
    activity_date TIMESTAMP,
    additional_data TEXT,
    row_num BIGINT,
    total_records BIGINT
)
LANGUAGE plpgsql
AS $
DECLARE
    v_start_date DATE;
    v_end_date DATE;
    v_offset INTEGER;
    v_total_records BIGINT;
BEGIN
    v_start_date := COALESCE(p_start_date, CURRENT_DATE - 30); -- Last 30 days default
    v_end_date := COALESCE(p_end_date, CURRENT_DATE + 1);
    v_offset := (p_page_number - 1) * p_page_size;
    
    -- Get total count first
    SELECT COUNT(*) INTO v_total_records
    FROM activity_log
    WHERE 
        agent_id = p_agent_id
        AND activity_date BETWEEN v_start_date AND v_end_date
        AND (p_activity_type IS NULL OR activity_type = p_activity_type);
    
    RETURN QUERY
    SELECT 
        al.activity_id,
        al.activity_type,
        al.entity_type,
        al.entity_id,
        al.description,
        al.activity_date,
        al.additional_data,
        ROW_NUMBER() OVER (ORDER BY al.activity_date DESC) AS row_num,
        v_total_records AS total_records
    FROM activity_log al
    WHERE 
        al.agent_id = p_agent_id
        AND al.activity_date BETWEEN v_start_date AND v_end_date
        AND (p_activity_type IS NULL OR al.activity_type = p_activity_type)
    ORDER BY al.activity_date DESC
    OFFSET v_offset
    LIMIT p_page_size;
END;
$;

-- Generate Monthly Report
CREATE OR REPLACE FUNCTION sp_generate_monthly_report(p_agent_id UUID,
    p_report_month DATE -- First day of the month)
RETURNS TABLE(
    agent_id UUID,
    report_month DATE,
    total_clients_added INTEGER,
    total_prospects_added INTEGER,
    prospects_converted INTEGER,
    total_appointments INTEGER,
    completed_appointments INTEGER,
    cancelled_appointments INTEGER,
    total_reminders INTEGER,
    completed_reminders INTEGER,
    messages_sent INTEGER,
    new_policies INTEGER,
    renewed_policies INTEGER,
    expired_policies INTEGER,
    generated_date TIMESTAMP
)
LANGUAGE plpgsql
AS $
 $
DECLARE
    v_month_start DATE := p_report_month;
    v_month_end DATE := (DATE_TRUNC('month', p_report_month) + INTERVAL '1 month - 1 day')::DATE;
    v_total_clients_added INTEGER;
    v_total_prospects_added INTEGER;
    v_prospects_converted INTEGER;
    v_total_appointments INTEGER;
    v_completed_appointments INTEGER;
    v_cancelled_appointments INTEGER;
    v_total_reminders INTEGER;
    v_completed_reminders INTEGER;
    v_messages_sent INTEGER;
    v_new_policies INTEGER;
    v_renewed_policies INTEGER := 0; -- Would require complex logic to track renewals
    v_expired_policies INTEGER;
BEGIN
    -- Client metrics
    SELECT 
        COUNT(CASE WHEN is_client = true AND created_date BETWEEN v_month_start AND v_month_end + 1 THEN 1 END),
        COUNT(CASE WHEN is_client = false AND created_date BETWEEN v_month_start AND v_month_end + 1 THEN 1 END),
        COUNT(CASE WHEN is_client = true AND modified_date BETWEEN v_month_start AND v_month_end + 1 THEN 1 END)
    INTO v_total_clients_added, v_total_prospects_added, v_prospects_converted
    FROM clients 
    WHERE agent_id = p_agent_id;
    
    -- Appointment metrics
    SELECT 
        COUNT(*),
        COUNT(CASE WHEN status = 'Completed' THEN 1 END),
        COUNT(CASE WHEN status = 'Cancelled' THEN 1 END)
    INTO v_total_appointments, v_completed_appointments, v_cancelled_appointments
    FROM appointments a
    INNER JOIN clients c ON a.client_id = c.client_id
    WHERE c.agent_id = p_agent_id 
        AND a.appointment_date BETWEEN v_month_start AND v_month_end;
    
    -- Reminder metrics
    SELECT 
        COUNT(*),
        COUNT(CASE WHEN status = 'Completed' THEN 1 END)
    INTO v_total_reminders, v_completed_reminders
    FROM reminders 
    WHERE agent_id = p_agent_id 
        AND reminder_date BETWEEN v_month_start AND v_month_end;
    
    -- Message metrics
    SELECT COUNT(*) INTO v_messages_sent
    FROM automated_messages 
    WHERE agent_id = p_agent_id 
        AND sent_date BETWEEN v_month_start AND v_month_end + 1;
    
    -- Policy metrics
    SELECT 
        COUNT(CASE WHEN start_date BETWEEN v_month_start AND v_month_end THEN 1 END),
        COUNT(CASE WHEN end_date BETWEEN v_month_start AND v_month_end THEN 1 END)
    INTO v_new_policies, v_expired_policies
    FROM client_policies cp
    INNER JOIN clients c ON cp.client_id = c.client_id
    WHERE c.agent_id = p_agent_id;
    
    -- Update or insert report
    IF EXISTS (SELECT 1 FROM monthly_reports WHERE agent_id = p_agent_id AND report_month = v_month_start) THEN
        UPDATE monthly_reports 
        SET 
            total_clients_added = v_total_clients_added,
            total_prospects_added = v_total_prospects_added,
            prospects_converted = v_prospects_converted,
            total_appointments = v_total_appointments,
            completed_appointments = v_completed_appointments,
            cancelled_appointments = v_cancelled_appointments,
            total_reminders = v_total_reminders,
            completed_reminders = v_completed_reminders,
            messages_sent = v_messages_sent,
            new_policies = v_new_policies,
            renewed_policies = v_renewed_policies,
            expired_policies = v_expired_policies,
            generated_date = NOW()
        WHERE agent_id = p_agent_id AND report_month = v_month_start;
    ELSE
        INSERT INTO monthly_reports (
            agent_id, report_month, total_clients_added, total_prospects_added, prospects_converted,
            total_appointments, completed_appointments, cancelled_appointments,
            total_reminders, completed_reminders, messages_sent,
            new_policies, renewed_policies, expired_policies
        )
        VALUES (
            p_agent_id, v_month_start, v_total_clients_added, v_total_prospects_added, v_prospects_converted,
            v_total_appointments, v_completed_appointments, v_cancelled_appointments,
            v_total_reminders, v_completed_reminders, v_messages_sent,
            v_new_policies, v_renewed_policies, v_expired_policies
        );
    END IF;
    
    RETURN QUERY
    SELECT * FROM monthly_reports 
    WHERE monthly_reports.agent_id = p_agent_id AND report_month = v_month_start;
END;
$;

-- ============================================
-- Missing Policy Service Stored Procedures
-- ============================================

-- Get Policy Catalog with Filters
-- ============================================
-- Agent Management Functions - PostgreSQL Version
-- ============================================

-- Create or Update Agent Profile
CREATE OR REPLACE FUNCTION sp_upsert_agent(p_first_name VARCHAR(50),
    p_last_name VARCHAR(50),
    p_email VARCHAR(100),
    p_phone VARCHAR(20),
    p_password_hash VARCHAR(200),
    p_agent_id UUID DEFAULT NULL,
    p_avatar TEXT DEFAULT NULL)
RETURNS TABLE(agent_id UUID)
LANGUAGE plpgsql
AS $$
DECLARE
    v_agent_id UUID;
BEGIN
    IF p_agent_id IS NULL THEN
        v_agent_id := gen_random_uuid();

        INSERT INTO agent (agent_id, first_name, last_name, email, phone, password_hash, avatar)
        VALUES (v_agent_id, p_first_name, p_last_name, p_email, p_phone, p_password_hash, p_avatar);

        INSERT INTO agent_settings (agent_id) VALUES (v_agent_id);

        INSERT INTO reminder_settings (agent_id, reminder_type, days_before, time_of_day)
        VALUES 
            (v_agent_id, 'Policy Expiry', 30, '09:00'),
            (v_agent_id, 'Birthday', 1, '08:00'),
            (v_agent_id, 'Appointment', 1, '18:00'),
            (v_agent_id, 'Call', 0, '10:00');
    ELSE
        v_agent_id := p_agent_id;
        
        UPDATE agent
        SET 
            first_name = p_first_name,
            last_name = p_last_name,
            email = p_email,
            phone = p_phone,
            password_hash = p_password_hash,
            avatar = p_avatar,
            modified_date = NOW()
        WHERE agent.agent_id = p_agent_id;
    END IF;

    RETURN QUERY SELECT v_agent_id;
END;
$;

-- Get Agent Profile
CREATE OR REPLACE FUNCTION sp_get_agent(p_agent_id UUID)
RETURNS TABLE(
    agent_id UUID,
    first_name VARCHAR(50),
    last_name VARCHAR(50),
    email VARCHAR(100),
    phone VARCHAR(20),
    password_hash VARCHAR(200),
    avatar TEXT,
    created_date TIMESTAMP,
    modified_date TIMESTAMP,
    is_active BOOLEAN,
    dark_mode BOOLEAN,
    email_notifications BOOLEAN,
    sms_notifications BOOLEAN,
    whatsapp_notifications BOOLEAN,
    push_notifications BOOLEAN,
    sound_enabled BOOLEAN
)
LANGUAGE plpgsql
AS $$
BEGIN
    RETURN QUERY
    SELECT 
        a.agent_id,
        a.first_name,
        a.last_name,
        a.email,
        a.phone,
        a.password_hash,
        a.avatar,
        a.created_date,
        a.modified_date,
        a.is_active,
        s.dark_mode,
        s.email_notifications,
        s.sms_notifications,
        s.whatsapp_notifications,
        s.push_notifications,
        s.sound_enabled
    FROM agent a
    LEFT JOIN agent_settings s ON a.agent_id = s.agent_id
    WHERE a.agent_id = p_agent_id AND a.is_active = true;
END;
$;

-- Update Agent Settings
CREATE OR REPLACE FUNCTION sp_update_agent_settings(p_agent_id UUID,
    p_dark_mode BOOLEAN DEFAULT NULL,
    p_email_notifications BOOLEAN DEFAULT NULL,
    p_sms_notifications BOOLEAN DEFAULT NULL,
    p_whatsapp_notifications BOOLEAN DEFAULT NULL,
    p_push_notifications BOOLEAN DEFAULT NULL,
    p_sound_enabled BOOLEAN DEFAULT NULL)
RETURNS VOID
LANGUAGE plpgsql
AS $
BEGIN
    -- Check if settings exist, create if not
    IF NOT EXISTS (SELECT 1 FROM agent_settings WHERE agent_id = p_agent_id) THEN
        INSERT INTO agent_settings (agent_id) VALUES (p_agent_id);
    END IF;
    
    UPDATE agent_settings 
    SET 
        dark_mode = COALESCE(p_dark_mode, dark_mode),
        email_notifications = COALESCE(p_email_notifications, email_notifications),
        sms_notifications = COALESCE(p_sms_notifications, sms_notifications),
        whatsapp_notifications = COALESCE(p_whatsapp_notifications, whatsapp_notifications),
        push_notifications = COALESCE(p_push_notifications, push_notifications),
        sound_enabled = COALESCE(p_sound_enabled, sound_enabled),
        modified_date = NOW()
    WHERE agent_id = p_agent_id;
END;
$;

-- Get Insurance Companies
CREATE OR REPLACE FUNCTION sp_get_insurance_companies()
RETURNS TABLE(company_id INTEGER, company_name VARCHAR(200))
LANGUAGE plpgsql
AS $
BEGIN
    RETURN QUERY
    SELECT ic.company_id, ic.company_name
    FROM insurance_companies ic
    WHERE ic.is_active = true
    ORDER BY ic.company_name;
END;
$;

-- Get Policy Types
CREATE OR REPLACE FUNCTION sp_get_policy_types()
RETURNS TABLE(type_id INTEGER, type_name VARCHAR(200))
LANGUAGE plpgsql
AS $
BEGIN
    RETURN QUERY
    SELECT pt.type_id, pt.type_name
    FROM policy_types pt
    WHERE pt.is_active = true
    ORDER BY pt.type_name;
END;
$;

-- Authenticate Agent
CREATE OR REPLACE FUNCTION sp_authenticate_agent(p_email VARCHAR(100))
RETURNS TABLE(
    agent_id UUID,
    first_name VARCHAR(50),
    last_name VARCHAR(50),
    email VARCHAR(100),
    phone VARCHAR(20),
    password_hash VARCHAR(200)
)
LANGUAGE plpgsql
AS $$
BEGIN
    RETURN QUERY
    SELECT
        a.agent_id,
        a.first_name,
        a.last_name,
        a.email,
        a.phone,
        a.password_hash
    FROM agent a
    WHERE a.email = p_email AND a.is_active = true;
END;
$;

-- ============================================
-- Authentication Functions
-- ============================================

-- Login Agent
CREATE OR REPLACE FUNCTION sp_login_agent(p_email VARCHAR(100),
    p_password VARCHAR(200))
RETURNS TABLE(
    success INTEGER,
    message TEXT,
    agent_id UUID,
    stored_password_hash VARCHAR(200),
    agent_profile JSON
)
LANGUAGE plpgsql
AS $$
DECLARE
    v_agent_id UUID;
    v_stored_hash VARCHAR(256);
    v_is_active BOOLEAN;
    v_agent_profile JSON;
BEGIN
    -- Get agent details
    SELECT 
        a.agent_id,
        a.password_hash,
        a.is_active
    INTO v_agent_id, v_stored_hash, v_is_active
    FROM agent a
    WHERE a.email = p_email;
    
    -- Check if agent exists and is active
    IF v_agent_id IS NULL THEN
        RETURN QUERY SELECT 
            0::INTEGER,
            'Invalid email or password'::TEXT,
            NULL::UUID,
            NULL::VARCHAR(200),
            NULL::JSON;
        RETURN;
    END IF;
    
    IF v_is_active = false THEN
        RETURN QUERY SELECT 
            0::INTEGER,
            'Account is deactivated'::TEXT,
            NULL::UUID,
            NULL::VARCHAR(200),
            NULL::JSON;
        RETURN;
    END IF;
    
    -- Build agent profile JSON
    SELECT json_build_object(
        'agent_id', a.agent_id,
        'first_name', a.first_name,
        'last_name', a.last_name,
        'email', a.email,
        'phone', a.phone,
        'avatar', a.avatar,
        'created_date', a.created_date,
        'is_active', a.is_active,
        'dark_mode', s.dark_mode,
        'email_notifications', s.email_notifications,
        'sms_notifications', s.sms_notifications,
        'whatsapp_notifications', s.whatsapp_notifications,
        'push_notifications', s.push_notifications,
        'sound_enabled', s.sound_enabled
    )
    INTO v_agent_profile
    FROM agent a
    LEFT JOIN agent_settings s ON a.agent_id = s.agent_id
    WHERE a.agent_id = v_agent_id;
    
    -- Note: Password verification should be done in application layer
    RETURN QUERY SELECT 
        1::INTEGER,
        'Login successful'::TEXT,
        v_agent_id,
        v_stored_hash::VARCHAR(200),
        v_agent_profile;
END;
$;

-- Register New Agent
CREATE OR REPLACE FUNCTION sp_register_agent(p_first_name VARCHAR(50),
    p_last_name VARCHAR(50),
    p_email VARCHAR(100),
    p_phone VARCHAR(20),
    p_password_hash VARCHAR(256),
    p_avatar TEXT DEFAULT NULL)
RETURNS TABLE(
    success INTEGER,
    message TEXT,
    agent_id UUID
)
LANGUAGE plpgsql
AS $$
DECLARE
    v_agent_id UUID := gen_random_uuid();
BEGIN
    -- Check if email already exists
    IF EXISTS(SELECT 1 FROM agent WHERE email = p_email) THEN
        RETURN QUERY SELECT 
            0::INTEGER,
            'Email already exists'::TEXT,
            NULL::UUID;
        RETURN;
    END IF;
    
    BEGIN
        -- Insert agent
        INSERT INTO agent (agent_id, first_name, last_name, email, phone, password_hash, avatar)
        VALUES (v_agent_id, p_first_name, p_last_name, p_email, p_phone, p_password_hash, p_avatar);
        
        -- Insert default agent settings
        INSERT INTO agent_settings (agent_id)
        VALUES (v_agent_id);
        
        -- Insert default reminder settings
        INSERT INTO reminder_settings (agent_id, reminder_type, days_before)
        VALUES 
            (v_agent_id, 'Policy Expiry', 7),
            (v_agent_id, 'Birthday', 1),
            (v_agent_id, 'Appointment', 1);
        
        -- Insert default notification preferences
        INSERT INTO agent_notification_preferences (agent_id, notification_type)
        VALUES 
            (v_agent_id, 'appointment'),
            (v_agent_id, 'birthday'),
            (v_agent_id, 'policy_expiry');
        
        RETURN QUERY SELECT 
            1::INTEGER,
            'Registration successful'::TEXT,
            v_agent_id;
            
    EXCEPTION WHEN OTHERS THEN
        RETURN QUERY SELECT 
            0::INTEGER,
            SQLERRM::TEXT,
            NULL::UUID;
    END;
END;
$;

-- Change Password
CREATE OR REPLACE FUNCTION sp_change_password(p_agent_id UUID,
    p_old_password_hash VARCHAR(256),
    p_new_password_hash VARCHAR(256))
RETURNS TABLE(
    success INTEGER,
    message TEXT
)
LANGUAGE plpgsql
AS $$
DECLARE
    v_stored_hash VARCHAR(256);
BEGIN
    -- Get current password hash
    SELECT password_hash INTO v_stored_hash
    FROM agent 
    WHERE agent_id = p_agent_id AND is_active = true;
    
    IF v_stored_hash IS NULL THEN
        RETURN QUERY SELECT 
            0::INTEGER,
            'Agent not found or inactive'::TEXT;
        RETURN;
    END IF;
    
    -- Note: Old password verification should be done in application layer
    -- Update password
    UPDATE agent 
    SET 
        password_hash = p_new_password_hash,
        modified_date = NOW()
    WHERE agent_id = p_agent_id;
    
    RETURN QUERY SELECT 
        1::INTEGER,
        'Password changed successfully'::TEXT;
END;
$;

-- Request Password Reset
CREATE OR REPLACE FUNCTION sp_request_password_reset(p_email VARCHAR(100))
RETURNS TABLE(
    success INTEGER,
    message TEXT,
    agent_id UUID,
    email VARCHAR(100)
)
LANGUAGE plpgsql
AS $$
DECLARE
    v_agent_id UUID;
BEGIN
    -- Check if agent exists
    SELECT a.agent_id INTO v_agent_id
    FROM agent a
    WHERE a.email = p_email AND a.is_active = true;
    
    IF v_agent_id IS NULL THEN
        RETURN QUERY SELECT 
            0::INTEGER,
            'Email not found'::TEXT,
            NULL::UUID,
            NULL::VARCHAR(100);
        RETURN;
    END IF;
    
    -- Return agent ID for reset token generation in application
    RETURN QUERY SELECT 
        1::INTEGER,
        'Reset request valid'::TEXT,
        v_agent_id,
        p_email;
END;
$;

-- Complete Password Reset
CREATE OR REPLACE FUNCTION sp_reset_password(p_agent_id UUID,
    p_new_password_hash VARCHAR(256))
RETURNS TABLE(
    success INTEGER,
    message TEXT
)
LANGUAGE plpgsql
AS $$
DECLARE
    v_rows_affected INTEGER;
BEGIN
    -- Update password
    UPDATE agent 
    SET 
        password_hash = p_new_password_hash,
        modified_date = NOW()
    WHERE agent_id = p_agent_id AND is_active = true;
    
    GET DIAGNOSTICS v_rows_affected = ROW_COUNT;
    
    IF v_rows_affected = 0 THEN
        RETURN QUERY SELECT 
            0::INTEGER,
            'Invalid reset request'::TEXT;
        RETURN;
    END IF;
    
    RETURN QUERY SELECT 
        1::INTEGER,
        'Password reset successful'::TEXT;
END;
$;

-- ============================================
-- Analytics and Dashboard Functions
-- ============================================

-- Get Dashboard Overview
CREATE OR REPLACE FUNCTION sp_get_dashboard_overview(p_agent_id UUID)
RETURNS TABLE(
    total_clients BIGINT,
    total_prospects BIGINT,
    active_policies BIGINT,
    today_appointments BIGINT,
    week_appointments BIGINT,
    month_appointments BIGINT,
    completed_appointments BIGINT,
    pending_reminders BIGINT,
    today_birthdays BIGINT,
    expiring_policies BIGINT
)
LANGUAGE plpgsql
AS $
DECLARE
    v_today DATE := CURRENT_DATE;
    v_week_start DATE := v_today - EXTRACT(DOW FROM v_today)::INTEGER;
    v_week_end DATE := v_week_start + 6;
    v_month_start DATE := DATE_TRUNC('month', v_today)::DATE;
    v_month_end DATE := (DATE_TRUNC('month', v_today) + INTERVAL '1 month - 1 day')::DATE;
BEGIN
    RETURN QUERY
    SELECT 
        -- Client Statistics
        COUNT(DISTINCT CASE WHEN c.is_client = true THEN c.client_id END) AS total_clients,
        COUNT(DISTINCT CASE WHEN c.is_client = false THEN c.client_id END) AS total_prospects,
        
        -- Policy Statistics
        COUNT(DISTINCT CASE WHEN cp.status = 'Active' THEN cp.policy_id END) AS active_policies,
        
        -- Appointment Statistics
        COUNT(DISTINCT CASE WHEN a.appointment_date = v_today THEN a.appointment_id END) AS today_appointments,
        COUNT(DISTINCT CASE WHEN a.appointment_date BETWEEN v_week_start AND v_week_end THEN a.appointment_id END) AS week_appointments,
        COUNT(DISTINCT CASE WHEN a.appointment_date BETWEEN v_month_start AND v_month_end THEN a.appointment_id END) AS month_appointments,
        COUNT(DISTINCT CASE WHEN a.status = 'Completed' THEN a.appointment_id END) AS completed_appointments,
        
        -- Reminder Statistics
        COUNT(DISTINCT CASE WHEN r.status = 'Active' AND r.reminder_date <= v_today THEN r.reminder_id END) AS pending_reminders,
        
        -- Birthday Statistics
        COUNT(DISTINCT CASE WHEN EXTRACT(DAY FROM c.date_of_birth) = EXTRACT(DAY FROM v_today) 
                                AND EXTRACT(MONTH FROM c.date_of_birth) = EXTRACT(MONTH FROM v_today) 
                           THEN c.client_id END) AS today_birthdays,
        
        -- Expiring Policies
        COUNT(DISTINCT CASE WHEN cp.end_date BETWEEN v_today AND v_today + 30 AND cp.status = 'Active' 
                           THEN cp.policy_id END) AS expiring_policies
        
    FROM clients c
    LEFT JOIN client_policies cp ON c.client_id = cp.client_id AND cp.is_active = true
    LEFT JOIN appointments a ON c.client_id = a.client_id AND a.is_active = true
    LEFT JOIN reminders r ON c.client_id = r.client_id
    WHERE c.agent_id = p_agent_id AND c.is_active = true;
END;
$;

-- Get Today's Activities
CREATE OR REPLACE FUNCTION sp_get_today_activities(p_agent_id UUID)
RETURNS TABLE(
    activity_type TEXT,
    entity_id UUID,
    client_name TEXT,
    title TEXT,
    time_range TEXT,
    location TEXT,
    type TEXT,
    status TEXT,
    notes TEXT,
    priority TEXT,
    client_phone TEXT
)
LANGUAGE plpgsql
AS $
DECLARE
    v_today DATE := CURRENT_DATE;
BEGIN
    -- Today's Appointments
    RETURN QUERY
    SELECT 
        'appointment'::TEXT AS activity_type,
        a.appointment_id AS entity_id,
        a.client_name::TEXT,
        a.title::TEXT,
        (TO_CHAR(a.start_time, 'HH24:MI') || ' - ' || TO_CHAR(a.end_time, 'HH24:MI'))::TEXT AS time_range,
        a.location::TEXT,
        a.type::TEXT,
        a.status::TEXT,
        a.notes::TEXT,
        a.priority::TEXT,
        c.phone_number::TEXT AS client_phone
    FROM appointments a
    LEFT JOIN clients c ON a.client_id = c.client_id
    WHERE a.agent_id = p_agent_id 
        AND a.appointment_date = v_today 
        AND a.is_active = true
        AND a.status NOT IN ('Cancelled')
    
    UNION ALL
    
    -- Today's Reminders
    SELECT 
        'reminder'::TEXT AS activity_type,
        r.reminder_id AS entity_id,
        r.client_name::TEXT,
        r.title::TEXT,
        COALESCE(TO_CHAR(r.reminder_time, 'HH24:MI'), '')::TEXT AS time_range,
        ''::TEXT AS location,
        r.reminder_type::TEXT AS type,
        r.status::TEXT,
        r.notes::TEXT,
        r.priority::TEXT,
        c.phone_number::TEXT AS client_phone
    FROM reminders r
    LEFT JOIN clients c ON r.client_id = c.client_id
    WHERE r.agent_id = p_agent_id 
        AND r.reminder_date = v_today 
        AND r.status = 'Active'
    
    UNION ALL
    
    -- Today's Birthdays
    SELECT 
        'birthday'::TEXT AS activity_type,
        c.client_id AS entity_id,
        (c.first_name || ' ' || c.surname)::TEXT AS client_name,
        ('Birthday - ' || c.first_name || ' ' || c.surname)::TEXT AS title,
        ''::TEXT AS time_range,
        c.address::TEXT AS location,
        'Birthday'::TEXT AS type,
        'Active'::TEXT AS status,
        ('Age: ' || EXTRACT(YEAR FROM AGE(c.date_of_birth)))::TEXT AS notes,
        'Medium'::TEXT AS priority,
        c.phone_number::TEXT AS client_phone
    FROM clients c
    WHERE c.agent_id = p_agent_id 
        AND c.is_active = true
        AND EXTRACT(DAY FROM c.date_of_birth) = EXTRACT(DAY FROM v_today)
        AND EXTRACT(MONTH FROM c.date_of_birth) = EXTRACT(MONTH FROM v_today)
    
    ORDER BY time_range;
END;
$;

-- ============================================
-- Performance and Analytics Functions
-- ============================================

-- Get Performance Metrics
CREATE OR REPLACE FUNCTION sp_get_performance_metrics(p_agent_id UUID,
    'month',
    'quarter',
    'year',
    p_start_date DATE DEFAULT NULL,
    p_end_date DATE DEFAULT NULL,
    p_period VARCHAR(20) DEFAULT 'month' -- 'week')
RETURNS TABLE(
    period_start DATE,
    period_end DATE,
    period VARCHAR(20),
    new_clients_added BIGINT,
    prospects_converted BIGINT,
    total_appointments BIGINT,
    completed_appointments BIGINT,
    cancelled_appointments BIGINT,
    new_policies BIGINT,
    expired_policies BIGINT,
    reminders_created BIGINT,
    reminders_completed BIGINT,
    messages_scheduled BIGINT,
    messages_sent BIGINT
)
LANGUAGE plpgsql
AS $
DECLARE
    v_start_date DATE;
    v_end_date DATE;
    v_today DATE := CURRENT_DATE;
BEGIN
    -- Set default date range based on period
    IF p_start_date IS NULL OR p_end_date IS NULL THEN
        CASE p_period
            WHEN 'week' THEN
                v_start_date := v_today - EXTRACT(DOW FROM v_today)::INTEGER;
                v_end_date := v_start_date + 6;
            WHEN 'month' THEN
                v_start_date := DATE_TRUNC('month', v_today)::DATE;
                v_end_date := (DATE_TRUNC('month', v_today) + INTERVAL '1 month - 1 day')::DATE;
            WHEN 'quarter' THEN
                v_start_date := DATE_TRUNC('quarter', v_today)::DATE;
                v_end_date := (DATE_TRUNC('quarter', v_today) + INTERVAL '3 months - 1 day')::DATE;
            WHEN 'year' THEN
                v_start_date := DATE_TRUNC('year', v_today)::DATE;
                v_end_date := (DATE_TRUNC('year', v_today) + INTERVAL '1 year - 1 day')::DATE;
        END CASE;
    ELSE
        v_start_date := p_start_date;
        v_end_date := p_end_date;
    END IF;
    
    RETURN QUERY
    SELECT 
        v_start_date AS period_start,
        v_end_date AS period_end,
        p_period AS period,
        
        -- Client Metrics
        COUNT(DISTINCT CASE WHEN c.created_date BETWEEN v_start_date AND v_end_date + 1 THEN c.client_id END) AS new_clients_added,
        COUNT(DISTINCT CASE WHEN c.is_client = true AND c.modified_date BETWEEN v_start_date AND v_end_date + 1 THEN c.client_id END) AS prospects_converted,
        
        -- Appointment Metrics
        COUNT(CASE WHEN a.appointment_date BETWEEN v_start_date AND v_end_date THEN 1 END) AS total_appointments,
        COUNT(CASE WHEN a.appointment_date BETWEEN v_start_date AND v_end_date AND a.status = 'Completed' THEN 1 END) AS completed_appointments,
        COUNT(CASE WHEN a.appointment_date BETWEEN v_start_date AND v_end_date AND a.status = 'Cancelled' THEN 1 END) AS cancelled_appointments,
        
        -- Policy Metrics
        COUNT(CASE WHEN cp.created_date BETWEEN v_start_date AND v_end_date + 1 THEN 1 END) AS new_policies,
        COUNT(CASE WHEN cp.end_date BETWEEN v_start_date AND v_end_date AND cp.status = 'Expired' THEN 1 END) AS expired_policies,
        
        -- Reminder Metrics
        COUNT(CASE WHEN r.created_date BETWEEN v_start_date AND v_end_date + 1 THEN 1 END) AS reminders_created,
        COUNT(CASE WHEN r.completed_date BETWEEN v_start_date AND v_end_date + 1 THEN 1 END) AS reminders_completed,
        
        -- Message Metrics
        COUNT(CASE WHEN am.created_date BETWEEN v_start_date AND v_end_date + 1 THEN 1 END) AS messages_scheduled,
        COUNT(CASE WHEN am.sent_date BETWEEN v_start_date AND v_end_date + 1 THEN 1 END) AS messages_sent
        
    FROM clients c
    LEFT JOIN client_policies cp ON c.client_id = cp.client_id AND cp.is_active = true
    LEFT JOIN appointments a ON c.client_id = a.client_id AND a.is_active = true
    LEFT JOIN reminders r ON c.client_id = r.client_id
    LEFT JOIN automated_messages am ON am.agent_id = c.agent_id
    WHERE c.agent_id = p_agent_id AND c.is_active = true;
END;
$;

-- Update Dashboard Statistics Cache
CREATE OR REPLACE FUNCTION sp_update_dashboard_statistics(p_agent_id UUID,
    p_stat_date DATE DEFAULT NULL)
RETURNS VOID
LANGUAGE plpgsql
AS $
 $
DECLARE
    v_stat_date DATE;
    v_week_start DATE;
    v_week_end DATE;
    v_month_start DATE;
    v_month_end DATE;
    v_total_clients INTEGER;
    v_total_prospects INTEGER;
    v_active_policies INTEGER;
    v_today_appointments INTEGER;
    v_week_appointments INTEGER;
    v_month_appointments INTEGER;
    v_completed_appointments INTEGER;
    v_pending_reminders INTEGER;
    v_today_birthdays INTEGER;
    v_expiring_policies INTEGER;
BEGIN
    v_stat_date := COALESCE(p_stat_date, CURRENT_DATE);
    v_week_start := v_stat_date - EXTRACT(DOW FROM v_stat_date)::INTEGER;
    v_week_end := v_week_start + 6;
    v_month_start := DATE_TRUNC('month', v_stat_date)::DATE;
    v_month_end := (DATE_TRUNC('month', v_stat_date) + INTERVAL '1 month - 1 day')::DATE;
    
    -- Calculate basic client statistics
    SELECT 
        COUNT(CASE WHEN is_client = true THEN 1 END),
        COUNT(CASE WHEN is_client = false THEN 1 END),
        COUNT(CASE WHEN EXTRACT(DAY FROM date_of_birth) = EXTRACT(DAY FROM v_stat_date) 
                    AND EXTRACT(MONTH FROM date_of_birth) = EXTRACT(MONTH FROM v_stat_date) THEN 1 END)
    INTO v_total_clients, v_total_prospects, v_today_birthdays
    FROM clients 
    WHERE agent_id = p_agent_id AND is_active = true;
    
    -- Calculate active policies
    SELECT COUNT(DISTINCT cp.policy_id) INTO v_active_policies
    FROM client_policies cp
    INNER JOIN clients c ON cp.client_id = c.client_id
    WHERE c.agent_id = p_agent_id AND cp.status = 'Active' AND cp.is_active = true AND c.is_active = true;
    
    -- Calculate appointment statistics
    SELECT 
        COUNT(CASE WHEN appointment_date = v_stat_date THEN 1 END),
        COUNT(CASE WHEN appointment_date BETWEEN v_week_start AND v_week_end THEN 1 END),
        COUNT(CASE WHEN appointment_date BETWEEN v_month_start AND v_month_end THEN 1 END),
        COUNT(CASE WHEN status = 'Completed' THEN 1 END)
    INTO v_today_appointments, v_week_appointments, v_month_appointments, v_completed_appointments
    FROM appointments a
    INNER JOIN clients c ON a.client_id = c.client_id
    WHERE c.agent_id = p_agent_id AND a.is_active = true AND c.is_active = true;
    
    -- Calculate pending reminders
    SELECT COUNT(*) INTO v_pending_reminders
    FROM reminders 
    WHERE agent_id = p_agent_id AND status = 'Active' AND reminder_date <= v_stat_date;
    
    -- Calculate expiring policies
    SELECT COUNT(DISTINCT cp.policy_id) INTO v_expiring_policies
    FROM client_policies cp
    INNER JOIN clients c ON cp.client_id = c.client_id
    WHERE c.agent_id = p_agent_id 
        AND cp.status = 'Active' 
        AND cp.end_date BETWEEN v_stat_date AND v_stat_date + 30
        AND cp.is_active = true AND c.is_active = true;
    
    -- Update or insert statistics
    IF EXISTS (SELECT 1 FROM dashboard_statistics WHERE agent_id = p_agent_id AND stat_date = v_stat_date) THEN
        UPDATE dashboard_statistics 
        SET 
            total_clients = v_total_clients,
            total_prospects = v_total_prospects,
            active_policies = v_active_policies,
            today_appointments = v_today_appointments,
            week_appointments = v_week_appointments,
            month_appointments = v_month_appointments,
            completed_appointments = v_completed_appointments,
            pending_reminders = v_pending_reminders,
            today_birthdays = v_today_birthdays,
            expiring_policies = v_expiring_policies,
            updated_date = NOW()
        WHERE agent_id = p_agent_id AND stat_date = v_stat_date;
    ELSE
        INSERT INTO dashboard_statistics (
            agent_id, stat_date, total_clients, total_prospects, active_policies,
            today_appointments, week_appointments, month_appointments, completed_appointments,
            pending_reminders, today_birthdays, expiring_policies
        )
        VALUES (
            p_agent_id, v_stat_date, v_total_clients, v_total_prospects, v_active_policies,
            v_today_appointments, v_week_appointments, v_month_appointments, v_completed_appointments,
            v_pending_reminders, v_today_birthdays, v_expiring_policies
        );
    END IF;
END;
$;

-- Log Activity
CREATE OR REPLACE FUNCTION sp_log_activity(p_agent_id UUID,
    p_activity_type VARCHAR(50),
    p_description VARCHAR(500),
    p_entity_type VARCHAR(50) DEFAULT NULL,
    p_entity_id UUID DEFAULT NULL,
    p_additional_data TEXT DEFAULT NULL)
RETURNS VOID
LANGUAGE plpgsql
AS $
DECLARE
    v_today DATE := CURRENT_DATE;
BEGIN
    INSERT INTO activity_log (
        agent_id, activity_type, entity_type, entity_id, description, additional_data
    )
    VALUES (
        p_agent_id, p_activity_type, p_entity_type, p_entity_id, p_description, p_additional_data
    );
    
    -- Update performance metrics if applicable
    IF p_activity_type IN ('client_created', 'appointment_completed', 'reminder_completed', 'policy_created') THEN
        -- Update or create performance metrics for today
        IF EXISTS (SELECT 1 FROM performance_metrics WHERE agent_id = p_agent_id AND metric_date = v_today) THEN
            UPDATE performance_metrics 
            SET 
                new_clients_added = new_clients_added + CASE WHEN p_activity_type = 'client_created' THEN 1 ELSE 0 END,
                appointments_completed = appointments_completed + CASE WHEN p_activity_type = 'appointment_completed' THEN 1 ELSE 0 END,
                reminders_completed = reminders_completed + CASE WHEN p_activity_type = 'reminder_completed' THEN 1 ELSE 0 END,
                policies_sold = policies_sold + CASE WHEN p_activity_type = 'policy_created' THEN 1 ELSE 0 END
            WHERE agent_id = p_agent_id AND metric_date = v_today;
        ELSE
            INSERT INTO performance_metrics (
                agent_id, metric_date, new_clients_added, appointments_completed, reminders_completed, policies_sold
            )
            VALUES (
                p_agent_id, v_today,
                CASE WHEN p_activity_type = 'client_created' THEN 1 ELSE 0 END,
                CASE WHEN p_activity_type = 'appointment_completed' THEN 1 ELSE 0 END,
                CASE WHEN p_activity_type = 'reminder_completed' THEN 1 ELSE 0 END,
                CASE WHEN p_activity_type = 'policy_created' THEN 1 ELSE 0 END
            );
        END IF;
    END IF;
END;
$;

-- Get Activity Log
CREATE OR REPLACE FUNCTION sp_get_activity_log(p_agent_id UUID,
    p_start_date DATE DEFAULT NULL,
    p_end_date DATE DEFAULT NULL,
    p_activity_type VARCHAR(50) DEFAULT NULL,
    p_page_size INTEGER DEFAULT 50,
    p_page_number INTEGER DEFAULT 1)
RETURNS TABLE(
    activity_id BIGINT,
    activity_type VARCHAR(50),
    entity_type VARCHAR(50),
    entity_id UUID,
    description VARCHAR(500),
    activity_date TIMESTAMP,
    additional_data TEXT,
    row_num BIGINT,
    total_records BIGINT
)
LANGUAGE plpgsql
AS $
DECLARE
    v_start_date DATE;
    v_end_date DATE;
    v_offset INTEGER;
    v_total_records BIGINT;
BEGIN
    v_start_date := COALESCE(p_start_date, CURRENT_DATE - 30); -- Last 30 days default
    v_end_date := COALESCE(p_end_date, CURRENT_DATE + 1);
    v_offset := (p_page_number - 1) * p_page_size;
    
    -- Get total count first
    SELECT COUNT(*) INTO v_total_records
    FROM activity_log
    WHERE 
        agent_id = p_agent_id
        AND activity_date BETWEEN v_start_date AND v_end_date
        AND (p_activity_type IS NULL OR activity_type = p_activity_type);
    
    RETURN QUERY
    SELECT 
        al.activity_id,
        al.activity_type,
        al.entity_type,
        al.entity_id,
        al.description,
        al.activity_date,
        al.additional_data,
        ROW_NUMBER() OVER (ORDER BY al.activity_date DESC) AS row_num,
        v_total_records AS total_records
    FROM activity_log al
    WHERE 
        al.agent_id = p_agent_id
        AND al.activity_date BETWEEN v_start_date AND v_end_date
        AND (p_activity_type IS NULL OR al.activity_type = p_activity_type)
    ORDER BY al.activity_date DESC
    OFFSET v_offset
    LIMIT p_page_size;
END;
$;

-- Generate Monthly Report
CREATE OR REPLACE FUNCTION sp_generate_monthly_report(p_agent_id UUID,
    p_report_month DATE -- First day of the month)
RETURNS TABLE(
    agent_id UUID,
    report_month DATE,
    total_clients_added INTEGER,
    total_prospects_added INTEGER,
    prospects_converted INTEGER,
    total_appointments INTEGER,
    completed_appointments INTEGER,
    cancelled_appointments INTEGER,
    total_reminders INTEGER,
    completed_reminders INTEGER,
    messages_sent INTEGER,
    new_policies INTEGER,
    renewed_policies INTEGER,
    expired_policies INTEGER,
    generated_date TIMESTAMP
)
LANGUAGE plpgsql
AS $
 $
DECLARE
    v_month_start DATE := p_report_month;
    v_month_end DATE := (DATE_TRUNC('month', p_report_month) + INTERVAL '1 month - 1 day')::DATE;
    v_total_clients_added INTEGER;
    v_total_prospects_added INTEGER;
    v_prospects_converted INTEGER;
    v_total_appointments INTEGER;
    v_completed_appointments INTEGER;
    v_cancelled_appointments INTEGER;
    v_total_reminders INTEGER;
    v_completed_reminders INTEGER;
    v_messages_sent INTEGER;
    v_new_policies INTEGER;
    v_renewed_policies INTEGER := 0; -- Would require complex logic to track renewals
    v_expired_policies INTEGER;
BEGIN
    -- Client metrics
    SELECT 
        COUNT(CASE WHEN is_client = true AND created_date BETWEEN v_month_start AND v_month_end + 1 THEN 1 END),
        COUNT(CASE WHEN is_client = false AND created_date BETWEEN v_month_start AND v_month_end + 1 THEN 1 END),
        COUNT(CASE WHEN is_client = true AND modified_date BETWEEN v_month_start AND v_month_end + 1 THEN 1 END)
    INTO v_total_clients_added, v_total_prospects_added, v_prospects_converted
    FROM clients 
    WHERE agent_id = p_agent_id;
    
    -- Appointment metrics
    SELECT 
        COUNT(*),
        COUNT(CASE WHEN status = 'Completed' THEN 1 END),
        COUNT(CASE WHEN status = 'Cancelled' THEN 1 END)
    INTO v_total_appointments, v_completed_appointments, v_cancelled_appointments
    FROM appointments a
    INNER JOIN clients c ON a.client_id = c.client_id
    WHERE c.agent_id = p_agent_id 
        AND a.appointment_date BETWEEN v_month_start AND v_month_end;
    
    -- Reminder metrics
    SELECT 
        COUNT(*),
        COUNT(CASE WHEN status = 'Completed' THEN 1 END)
    INTO v_total_reminders, v_completed_reminders
    FROM reminders 
    WHERE agent_id = p_agent_id 
        AND reminder_date BETWEEN v_month_start AND v_month_end;
    
    -- Message metrics
    SELECT COUNT(*) INTO v_messages_sent
    FROM automated_messages 
    WHERE agent_id = p_agent_id 
        AND sent_date BETWEEN v_month_start AND v_month_end + 1;
    
    -- Policy metrics
    SELECT 
        COUNT(CASE WHEN start_date BETWEEN v_month_start AND v_month_end THEN 1 END),
        COUNT(CASE WHEN end_date BETWEEN v_month_start AND v_month_end THEN 1 END)
    INTO v_new_policies, v_expired_policies
    FROM client_policies cp
    INNER JOIN clients c ON cp.client_id = c.client_id
    WHERE c.agent_id = p_agent_id;
    
    -- Update or insert report
    IF EXISTS (SELECT 1 FROM monthly_reports WHERE agent_id = p_agent_id AND report_month = v_month_start) THEN
        UPDATE monthly_reports 
        SET 
            total_clients_added = v_total_clients_added,
            total_prospects_added = v_total_prospects_added,
            prospects_converted = v_prospects_converted,
            total_appointments = v_total_appointments,
            completed_appointments = v_completed_appointments,
            cancelled_appointments = v_cancelled_appointments,
            total_reminders = v_total_reminders,
            completed_reminders = v_completed_reminders,
            messages_sent = v_messages_sent,
            new_policies = v_new_policies,
            renewed_policies = v_renewed_policies,
            expired_policies = v_expired_policies,
            generated_date = NOW()
        WHERE agent_id = p_agent_id AND report_month = v_month_start;
    ELSE
        INSERT INTO monthly_reports (
            agent_id, report_month, total_clients_added, total_prospects_added, prospects_converted,
            total_appointments, completed_appointments, cancelled_appointments,
            total_reminders, completed_reminders, messages_sent,
            new_policies, renewed_policies, expired_policies
        )
        VALUES (
            p_agent_id, v_month_start, v_total_clients_added, v_total_prospects_added, v_prospects_converted,
            v_total_appointments, v_completed_appointments, v_cancelled_appointments,
            v_total_reminders, v_completed_reminders, v_messages_sent,
            v_new_policies, v_renewed_policies, v_expired_policies
        );
    END IF;
    
    RETURN QUERY
    SELECT * FROM monthly_reports 
    WHERE monthly_reports.agent_id = p_agent_id AND report_month = v_month_start;
END;
$;
-- Create Client Policy
CREATE OR REPLACE FUNCTION sp_create_client_policy(p_client_id UUID,
    p_policy_name VARCHAR(100),
    p_policy_type VARCHAR(50),
    p_company_name VARCHAR(100),
    p_start_date DATE,
    p_end_date DATE,
    p_status VARCHAR(20) DEFAULT 'Active',
    p_notes TEXT DEFAULT NULL) RETURNS UUID AS $$
DECLARE
    v_policy_id UUID;
BEGIN
    v_policy_id := gen_random_uuid();
    
    INSERT INTO client_policies (
        policy_id, client_id, policy_name, policy_type, company_name, 
        status, start_date, end_date, notes
    )
    VALUES (
        v_policy_id, p_client_id, p_policy_name, p_policy_type, p_company_name, 
        p_status, p_start_date, p_end_date, p_notes
    );
    
    RETURN v_policy_id;
END;
$ LANGUAGE plpgsql;

-- Update Client Policy
CREATE OR REPLACE FUNCTION sp_update_client_policy(p_policy_id UUID,
    p_policy_name VARCHAR(100) DEFAULT NULL,
    p_policy_type VARCHAR(50) DEFAULT NULL,
    p_company_name VARCHAR(100) DEFAULT NULL,
    p_status VARCHAR(20) DEFAULT NULL,
    p_start_date DATE DEFAULT NULL,
    p_end_date DATE DEFAULT NULL,
    p_notes TEXT DEFAULT NULL,
    p_is_active BOOLEAN DEFAULT NULL) RETURNS INTEGER AS $$
DECLARE
    rows_affected INTEGER;
BEGIN
    UPDATE client_policies 
    SET 
        policy_name = COALESCE(p_policy_name, policy_name),
        policy_type = COALESCE(p_policy_type, policy_type),
        company_name = COALESCE(p_company_name, company_name),
        status = COALESCE(p_status, status),
        start_date = COALESCE(p_start_date, start_date),
        end_date = COALESCE(p_end_date, end_date),
        notes = COALESCE(p_notes, notes),
        is_active = COALESCE(p_is_active, is_active),
        modified_date = NOW() AT TIME ZONE 'UTC'
    WHERE policy_id = p_policy_id;
    
    GET DIAGNOSTICS rows_affected = ROW_COUNT;
    RETURN rows_affected;
END;
$ LANGUAGE plpgsql;

-- Get Expiring Policies
CREATE OR REPLACE FUNCTION sp_get_expiring_policies(p_agent_id UUID,
    p_days_ahead INTEGER DEFAULT 30) RETURNS TABLE (
    policy_id UUID,
    client_id UUID,
    policy_name VARCHAR(100),
    policy_type VARCHAR(50),
    company_name VARCHAR(100),
    status VARCHAR(20),
    start_date DATE,
    end_date DATE,
    notes TEXT,
    client_name TEXT,
    client_phone VARCHAR(20),
    client_email VARCHAR(100),
    days_until_expiry INTEGER
) AS $
DECLARE
    v_start_date DATE;
    v_end_date DATE;
BEGIN
    v_start_date := CURRENT_DATE;
    v_end_date := v_start_date + INTERVAL '1 day' * p_days_ahead;
    
    RETURN QUERY
    SELECT 
        cp.policy_id,
        cp.client_id,
        cp.policy_name,
        cp.policy_type,
        cp.company_name,
        cp.status,
        cp.start_date,
        cp.end_date,
        cp.notes,
        (c.first_name || ' ' || c.surname) AS client_name,
        c.phone_number AS client_phone,
        c.email AS client_email,
        (cp.end_date - v_start_date)::INTEGER AS days_until_expiry
    FROM client_policies cp
    INNER JOIN clients c ON cp.client_id = c.client_id
    WHERE 
        c.agent_id = p_agent_id 
        AND cp.status = 'Active'
        AND cp.is_active = true
        AND c.is_active = true
        AND cp.end_date BETWEEN v_start_date AND v_end_date
    ORDER BY cp.end_date ASC;
END;
$ LANGUAGE plpgsql;

-- Get Policy Statistics
CREATE OR REPLACE FUNCTION sp_get_policy_statistics(p_agent_id UUID) RETURNS TABLE (
    total_policies BIGINT,
    active_policies BIGINT,
    expired_policies BIGINT,
    lapsed_policies BIGINT,
    inactive_policies BIGINT,
    expiring_in_30_days BIGINT,
    expiring_in_7_days BIGINT,
    new_policies_this_month BIGINT,
    motor_policies BIGINT,
    life_policies BIGINT,
    health_policies BIGINT,
    travel_policies BIGINT,
    property_policies BIGINT,
    marine_policies BIGINT,
    business_policies BIGINT,
    catalog_policies BIGINT
) AS $
DECLARE
    v_today DATE;
    v_month_start DATE;
    v_month_end DATE;
BEGIN
    v_today := CURRENT_DATE;
    v_month_start := DATE_TRUNC('month', v_today)::DATE;
    v_month_end := (DATE_TRUNC('month', v_today) + INTERVAL '1 month - 1 day')::DATE;
    
    RETURN QUERY
    SELECT 
        -- Total Policies
        COUNT(DISTINCT cp.policy_id) AS total_policies,
        COUNT(DISTINCT CASE WHEN cp.status = 'Active' THEN cp.policy_id END) AS active_policies,
        COUNT(DISTINCT CASE WHEN cp.status = 'Expired' THEN cp.policy_id END) AS expired_policies,
        COUNT(DISTINCT CASE WHEN cp.status = 'Lapsed' THEN cp.policy_id END) AS lapsed_policies,
        COUNT(DISTINCT CASE WHEN cp.status = 'Inactive' THEN cp.policy_id END) AS inactive_policies,
        
        -- Expiring Soon (next 30 days)
        COUNT(DISTINCT CASE WHEN cp.end_date BETWEEN v_today AND v_today + INTERVAL '30 days' AND cp.status = 'Active' THEN cp.policy_id END) AS expiring_in_30_days,
        COUNT(DISTINCT CASE WHEN cp.end_date BETWEEN v_today AND v_today + INTERVAL '7 days' AND cp.status = 'Active' THEN cp.policy_id END) AS expiring_in_7_days,
        
        -- New Policies This Month
        COUNT(DISTINCT CASE WHEN cp.start_date BETWEEN v_month_start AND v_month_end THEN cp.policy_id END) AS new_policies_this_month,
        
        -- Policies by Type
        COUNT(DISTINCT CASE WHEN cp.policy_type = 'Motor' THEN cp.policy_id END) AS motor_policies,
        COUNT(DISTINCT CASE WHEN cp.policy_type = 'Life' THEN cp.policy_id END) AS life_policies,
        COUNT(DISTINCT CASE WHEN cp.policy_type = 'Health' THEN cp.policy_id END) AS health_policies,
        COUNT(DISTINCT CASE WHEN cp.policy_type = 'Travel' THEN cp.policy_id END) AS travel_policies,
        COUNT(DISTINCT CASE WHEN cp.policy_type = 'Property' THEN cp.policy_id END) AS property_policies,
        COUNT(DISTINCT CASE WHEN cp.policy_type = 'Marine' THEN cp.policy_id END) AS marine_policies,
        COUNT(DISTINCT CASE WHEN cp.policy_type = 'Business' THEN cp.policy_id END) AS business_policies,
        
        -- Catalog Statistics
        COUNT(DISTINCT pc.policy_catalog_id) AS catalog_policies
        
    FROM client_policies cp
    INNER JOIN clients c ON cp.client_id = c.client_id
    LEFT JOIN policy_catalog pc ON pc.agent_id = c.agent_id AND pc.is_active = true
    WHERE c.agent_id = p_agent_id AND cp.is_active = true AND c.is_active = true;
END;
$ LANGUAGE plpgsql;

-- Get Insurance Companies
CREATE OR REPLACE FUNCTION sp_get_insurance_companies(p_is_active BOOLEAN DEFAULT true) RETURNS TABLE (
    company_id UUID,
    company_name VARCHAR(100),
    is_active BOOLEAN,
    created_date TIMESTAMP
) AS $
BEGIN
    RETURN QUERY
    SELECT 
        ic.company_id,
        ic.company_name,
        ic.is_active,
        ic.created_date
    FROM insurance_companies ic
    WHERE (p_is_active IS NULL OR ic.is_active = p_is_active)
    ORDER BY ic.company_name ASC;
END;
$ LANGUAGE plpgsql;

-- Get Policy Types
CREATE OR REPLACE FUNCTION sp_get_policy_types(p_is_active BOOLEAN DEFAULT true) RETURNS TABLE (
    type_id UUID,
    type_name VARCHAR(50),
    is_active BOOLEAN,
    created_date TIMESTAMP
) AS $
BEGIN
    RETURN QUERY
    SELECT 
        pt.type_id,
        pt.type_name,
        pt.is_active,
        pt.created_date
    FROM policy_types pt
    WHERE (p_is_active IS NULL OR pt.is_active = p_is_active)
    ORDER BY pt.type_name ASC;
END;
$ LANGUAGE plpgsql;

-- Get Policy Templates
CREATE OR REPLACE FUNCTION sp_get_policy_templates(p_agent_id UUID,
    p_policy_type VARCHAR(50) DEFAULT NULL,
    p_is_active BOOLEAN DEFAULT true) RETURNS TABLE (
    template_id UUID,
    agent_id UUID,
    template_name VARCHAR(100),
    policy_type VARCHAR(50),
    default_term_months INTEGER,
    default_premium DECIMAL(10,2),
    coverage_description TEXT,
    terms TEXT,
    is_active BOOLEAN,
    created_date TIMESTAMP
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        pt.template_id,
        pt.agent_id,
        pt.template_name,
        pt.policy_type,
        pt.default_term_months,
        pt.default_premium,
        pt.coverage_description,
        pt.terms,
        pt.is_active,
        pt.created_date
    FROM policy_templates pt
    WHERE 
        pt.agent_id = p_agent_id
        AND (p_policy_type IS NULL OR pt.policy_type = p_policy_type)
        AND (p_is_active IS NULL OR pt.is_active = p_is_active)
    ORDER BY pt.template_name ASC;
END;
$ LANGUAGE plpgsql;

-- Create Policy Template
CREATE OR REPLACE FUNCTION sp_create_policy_template(p_agent_id UUID,
    p_template_name VARCHAR(100),
    p_policy_type VARCHAR(50),
    p_default_term_months INTEGER DEFAULT NULL,
    p_default_premium DECIMAL(10,2) DEFAULT NULL,
    p_coverage_description TEXT DEFAULT NULL,
    p_terms TEXT DEFAULT NULL) RETURNS UUID AS $$
DECLARE
    v_template_id UUID;
BEGIN
    v_template_id := gen_random_uuid();
    
    INSERT INTO policy_templates (
        template_id, agent_id, template_name, policy_type, default_term_months, 
        default_premium, coverage_description, terms
    )
    VALUES (
        v_template_id, p_agent_id, p_template_name, p_policy_type, p_default_term_months, 
        p_default_premium, p_coverage_description, p_terms
    );
    
    RETURN v_template_id;
END;
$ LANGUAGE plpgsql;

-- Validate Policy Data
CREATE OR REPLACE FUNCTION sp_validate_policy_data(p_policy_name VARCHAR(100),
    p_policy_type VARCHAR(50),
    p_company_id UUID DEFAULT NULL,
    p_start_date DATE DEFAULT NULL,
    p_end_date DATE DEFAULT NULL) RETURNS TABLE (
    is_valid BOOLEAN,
    validation_errors TEXT
) AS $$
DECLARE
    v_is_valid BOOLEAN := true;
    v_validation_errors TEXT := '';
BEGIN
    -- Validate Policy Name
    IF p_policy_name IS NULL OR LENGTH(TRIM(p_policy_name)) = 0 THEN
        v_is_valid := false;
        v_validation_errors := v_validation_errors || 'Policy name is required. ';
    END IF;
    
    -- Validate Policy Type
    IF p_policy_type IS NULL OR NOT EXISTS (
        SELECT 1 FROM policy_types WHERE type_name = p_policy_type AND is_active = true
    ) THEN
        v_is_valid := false;
        v_validation_errors := v_validation_errors || 'Valid policy type is required. ';
    END IF;
    
    -- Validate Company
    IF p_company_id IS NOT NULL AND NOT EXISTS (
        SELECT 1 FROM insurance_companies WHERE company_id = p_company_id AND is_active = true
    ) THEN
        v_is_valid := false;
        v_validation_errors := v_validation_errors || 'Valid insurance company is required. ';
    END IF;
    
    -- Validate Dates
    IF p_start_date IS NOT NULL AND p_end_date IS NOT NULL AND p_start_date >= p_end_date THEN
        v_is_valid := false;
        v_validation_errors := v_validation_errors || 'End date must be after start date. ';
    END IF;
    
    RETURN QUERY SELECT v_is_valid, RTRIM(v_validation_errors);
END;
$ LANGUAGE plpgsql;
-- ============================================
-- Appointments Management Stored Procedures
-- ============================================

-- Create or Update Appointment (Upsert)
CREATE OR REPLACE FUNCTION sp_upsert_appointment(p_client_id UUID,
    p_agent_id UUID,
    p_client_name VARCHAR(150),
    p_title VARCHAR(200),
    p_appointment_date DATE,
    p_start_time TIME,
    p_end_time TIME,
    p_type VARCHAR(50),
    p_appointment_id UUID DEFAULT NULL,
    p_client_phone VARCHAR(20) DEFAULT NULL,
    p_description TEXT DEFAULT NULL,
    p_location VARCHAR(200) DEFAULT NULL,
    p_status VARCHAR(20) DEFAULT 'Scheduled',
    p_priority VARCHAR(10) DEFAULT 'Medium',
    p_notes TEXT DEFAULT NULL,
    p_reminder_set BOOLEAN DEFAULT false) RETURNS UUID AS $$
DECLARE
    v_appointment_id UUID;
BEGIN
    IF p_appointment_id IS NULL THEN
        -- Create new appointment
        v_appointment_id := gen_random_uuid();
        
        INSERT INTO appointments (
            appointment_id, client_id, agent_id, client_name, client_phone, title, description,
            appointment_date, start_time, end_time, location, type, status, priority, notes, reminder_set
        )
        VALUES (
            v_appointment_id, p_client_id, p_agent_id, p_client_name, p_client_phone, p_title, p_description,
            p_appointment_date, p_start_time, p_end_time, p_location, p_type, p_status, p_priority, p_notes, p_reminder_set
        );
        
        -- Log activity
        INSERT INTO activity_log (agent_id, activity_type, entity_type, entity_id, description)
        VALUES (p_agent_id, 'appointment_created', 'appointment', v_appointment_id, 
                'Appointment "' || p_title || '" scheduled with ' || p_client_name);
        
        -- Create automatic reminder if reminder_set is true
        IF p_reminder_set = true THEN
            INSERT INTO reminders (
                client_id, appointment_id, agent_id, reminder_type, title, description,
                reminder_date, reminder_time, client_name, priority, enable_push_notification
            )
            VALUES (
                p_client_id, v_appointment_id, p_agent_id, 'Appointment', 'Appointment Reminder: ' || p_title,
                'Reminder for appointment with ' || p_client_name,
                p_appointment_date - INTERVAL '1 day', p_start_time, p_client_name, p_priority, true
            );
        END IF;
        
    ELSE
        -- Update existing appointment
        v_appointment_id := p_appointment_id;
        
        UPDATE appointments 
        SET 
            client_name = p_client_name,
            client_phone = p_client_phone,
            title = p_title,
            description = p_description,
            appointment_date = p_appointment_date,
            start_time = p_start_time,
            end_time = p_end_time,
            location = p_location,
            type = p_type,
            status = p_status,
            priority = p_priority,
            notes = p_notes,
            reminder_set = p_reminder_set,
            modified_date = NOW() AT TIME ZONE 'UTC'
        WHERE appointment_id = p_appointment_id;
        
        -- Log activity
        INSERT INTO activity_log (agent_id, activity_type, entity_type, entity_id, description)
        VALUES (p_agent_id, 'appointment_updated', 'appointment', v_appointment_id, 
                'Appointment "' || p_title || '" updated');
    END IF;
    
    RETURN v_appointment_id;
END;
$ LANGUAGE plpgsql;

-- Get Appointments with Filters
CREATE OR REPLACE FUNCTION sp_get_appointments(p_agent_id UUID,
    -- 'all',
    'today',
    'week',
    p_date_range_filter VARCHAR(20) DEFAULT 'all',
    'month'
    p_status_filter VARCHAR(20) DEFAULT 'all',
    p_type_filter VARCHAR(50) DEFAULT 'all',
    p_search_term VARCHAR(100) DEFAULT NULL,
    p_start_date DATE DEFAULT NULL,
    p_end_date DATE DEFAULT NULL) RETURNS TABLE (
    appointment_id UUID,
    client_id UUID,
    agent_id UUID,
    client_name VARCHAR(150),
    client_phone VARCHAR(20),
    title VARCHAR(200),
    description TEXT,
    appointment_date DATE,
    start_time TIME,
    end_time TIME,
    location VARCHAR(200),
    type VARCHAR(50),
    status VARCHAR(20),
    priority VARCHAR(10),
    notes TEXT,
    reminder_set BOOLEAN,
    created_date TIMESTAMP,
    modified_date TIMESTAMP,
    is_active BOOLEAN,
    computed_client_name TEXT,
    client_email VARCHAR(100),
    insurance_type VARCHAR(50)
) AS $$
DECLARE
    v_filter_start_date DATE;
    v_filter_end_date DATE;
    v_today DATE := CURRENT_DATE;
BEGIN
    -- Calculate date range filters
    IF p_date_range_filter = 'today' THEN
        v_filter_start_date := v_today;
        v_filter_end_date := v_today;
    ELSIF p_date_range_filter = 'week' THEN
        v_filter_start_date := v_today - (EXTRACT(DOW FROM v_today)::INTEGER - 1);
        v_filter_end_date := v_filter_start_date + INTERVAL '6 days';
    ELSIF p_date_range_filter = 'month' THEN
        v_filter_start_date := DATE_TRUNC('month', v_today)::DATE;
        v_filter_end_date := (DATE_TRUNC('month', v_today) + INTERVAL '1 month - 1 day')::DATE;
    ELSE
        v_filter_start_date := COALESCE(p_start_date, '1900-01-01'::DATE);
        v_filter_end_date := COALESCE(p_end_date, '2100-12-31'::DATE);
    END IF;
    
    RETURN QUERY
    SELECT 
        a.appointment_id,
        a.client_id,
        a.agent_id,
        a.client_name,
        a.client_phone,
        a.title,
        a.description,
        a.appointment_date,
        a.start_time,
        a.end_time,
        a.location,
        a.type,
        a.status,
        a.priority,
        a.notes,
        a.reminder_set,
        a.created_date,
        a.modified_date,
        a.is_active,
        (c.first_name || ' ' || c.surname) AS computed_client_name,
        c.email AS client_email,
        c.insurance_type
    FROM appointments a
    LEFT JOIN clients c ON a.client_id = c.client_id
    WHERE 
        a.agent_id = p_agent_id 
        AND a.is_active = true
        AND a.appointment_date BETWEEN v_filter_start_date AND v_filter_end_date
        AND (p_status_filter = 'all' OR a.status = p_status_filter)
        AND (p_type_filter = 'all' OR a.type = p_type_filter)
        AND (p_search_term IS NULL OR 
             a.client_name ILIKE '%' || p_search_term || '%' OR
             a.title ILIKE '%' || p_search_term || '%')
    ORDER BY a.appointment_date DESC, a.start_time DESC;
END;
$ LANGUAGE plpgsql;

-- Get Today's Appointments
CREATE OR REPLACE FUNCTION sp_get_today_appointments(p_agent_id UUID) RETURNS TABLE (
    appointment_id UUID,
    client_id UUID,
    client_name VARCHAR(150),
    title VARCHAR(200),
    appointment_date DATE,
    start_time TIME,
    end_time TIME,
    location VARCHAR(200),
    type VARCHAR(50),
    status VARCHAR(20),
    priority VARCHAR(10),
    notes TEXT,
    time_range TEXT
) AS $
BEGIN
    RETURN QUERY
    SELECT 
        a.appointment_id,
        a.client_id,
        a.client_name,
        a.title,
        a.appointment_date,
        a.start_time,
        a.end_time,
        a.location,
        a.type,
        a.status,
        a.priority,
        a.notes,
        (TO_CHAR(a.start_time, 'HH24:MI') || ' - ' || TO_CHAR(a.end_time, 'HH24:MI')) AS time_range
    FROM appointments a
    WHERE 
        a.agent_id = p_agent_id 
        AND a.is_active = true
        AND a.appointment_date = CURRENT_DATE
        AND a.status NOT IN ('Cancelled')
    ORDER BY a.start_time;
END;
$ LANGUAGE plpgsql;

-- Get Week View Data
CREATE OR REPLACE FUNCTION sp_get_week_view_appointments(p_agent_id UUID,
    p_week_start_date DATE DEFAULT NULL) RETURNS TABLE (
    appointment_id UUID,
    client_id UUID,
    client_name VARCHAR(150),
    title VARCHAR(200),
    appointment_date DATE,
    start_time TIME,
    end_time TIME,
    location VARCHAR(200),
    type VARCHAR(50),
    status VARCHAR(20),
    priority VARCHAR(10),
    day_name TEXT,
    day_number INTEGER
) AS $
DECLARE
    v_week_start_date DATE;
    v_week_end_date DATE;
    v_today DATE := CURRENT_DATE;
BEGIN
    -- Default to current week if no date provided
    IF p_week_start_date IS NULL THEN
        v_week_start_date := v_today - (EXTRACT(DOW FROM v_today)::INTEGER - 1);
    ELSE
        v_week_start_date := p_week_start_date;
    END IF;
    
    v_week_end_date := v_week_start_date + INTERVAL '6 days';
    
    RETURN QUERY
    SELECT 
        a.appointment_id,
        a.client_id,
        a.client_name,
        a.title,
        a.appointment_date,
        a.start_time,
        a.end_time,
        a.location,
        a.type,
        a.status,
        a.priority,
        TO_CHAR(a.appointment_date, 'Day') AS day_name,
        EXTRACT(DAY FROM a.appointment_date)::INTEGER AS day_number
    FROM appointments a
    WHERE 
        a.agent_id = p_agent_id 
        AND a.is_active = true
        AND a.appointment_date BETWEEN v_week_start_date AND v_week_end_date
        AND a.status NOT IN ('Cancelled')
    ORDER BY a.appointment_date, a.start_time;
END;
$ LANGUAGE plpgsql;

-- Get Calendar View Data
CREATE OR REPLACE FUNCTION sp_get_calendar_appointments(p_agent_id UUID,
    p_month INTEGER,
    p_year INTEGER) RETURNS TABLE (
    appointment_id UUID,
    client_id UUID,
    client_name VARCHAR(150),
    title VARCHAR(200),
    appointment_date DATE,
    start_time TIME,
    type VARCHAR(50),
    status VARCHAR(20),
    priority VARCHAR(10),
    day_number INTEGER,
    appointments_on_day BIGINT
) AS $
DECLARE
    v_start_date DATE;
    v_end_date DATE;
BEGIN
    v_start_date := MAKE_DATE(p_year, p_month, 1);
    v_end_date := (DATE_TRUNC('month', v_start_date) + INTERVAL '1 month - 1 day')::DATE;
    
    RETURN QUERY
    SELECT 
        a.appointment_id,
        a.client_id,
        a.client_name,
        a.title,
        a.appointment_date,
        a.start_time,
        a.type,
        a.status,
        a.priority,
        EXTRACT(DAY FROM a.appointment_date)::INTEGER AS day_number,
        COUNT(*) OVER (PARTITION BY a.appointment_date) AS appointments_on_day
    FROM appointments a
    WHERE 
        a.agent_id = p_agent_id 
        AND a.is_active = true
        AND a.appointment_date BETWEEN v_start_date AND v_end_date
        AND a.status NOT IN ('Cancelled')
    ORDER BY a.appointment_date, a.start_time;
END;
$ LANGUAGE plpgsql;

-- Update Appointment Status
CREATE OR REPLACE FUNCTION sp_update_appointment_status(p_appointment_id UUID,
    p_agent_id UUID,
    p_status VARCHAR(20)) RETURNS INTEGER AS $$
DECLARE
    v_title VARCHAR(200);
    v_client_name VARCHAR(150);
    rows_affected INTEGER;
BEGIN
    -- Get appointment details for logging
    SELECT title, client_name INTO v_title, v_client_name
    FROM appointments 
    WHERE appointment_id = p_appointment_id;
    
    UPDATE appointments 
    SET status = p_status, modified_date = NOW() AT TIME ZONE 'UTC'
    WHERE appointment_id = p_appointment_id AND agent_id = p_agent_id;
    
    GET DIAGNOSTICS rows_affected = ROW_COUNT;
    
    -- Log activity
    INSERT INTO activity_log (agent_id, activity_type, entity_type, entity_id, description)
    VALUES (p_agent_id, 'appointment_status_changed', 'appointment', p_appointment_id, 
            'Appointment "' || v_title || '" status changed to ' || p_status);
    
    RETURN rows_affected;
END;
$ LANGUAGE plpgsql;

-- Delete Appointment (Soft Delete)
CREATE OR REPLACE FUNCTION sp_delete_appointment(p_appointment_id UUID,
    p_agent_id UUID) RETURNS INTEGER AS $
DECLARE
    v_title VARCHAR(200);
    v_client_name VARCHAR(150);
    rows_affected INTEGER;
BEGIN
    -- Get appointment details for logging
    SELECT title, client_name INTO v_title, v_client_name
    FROM appointments 
    WHERE appointment_id = p_appointment_id;
    
    -- Soft delete
    UPDATE appointments 
    SET is_active = false, modified_date = NOW() AT TIME ZONE 'UTC'
    WHERE appointment_id = p_appointment_id AND agent_id = p_agent_id;
    
    GET DIAGNOSTICS rows_affected = ROW_COUNT;
    
    -- Also cancel related reminders
    UPDATE reminders 
    SET status = 'Cancelled'
    WHERE appointment_id = p_appointment_id;
    
    -- Log activity
    INSERT INTO activity_log (agent_id, activity_type, entity_type, entity_id, description)
    VALUES (p_agent_id, 'appointment_deleted', 'appointment', p_appointment_id, 
            'Appointment "' || v_title || '" deleted');
    
    RETURN rows_affected;
END;
$ LANGUAGE plpgsql;

-- Get Appointment Statistics
CREATE OR REPLACE FUNCTION sp_get_appointment_statistics(p_agent_id UUID) RETURNS TABLE (
    today_appointments BIGINT,
    week_appointments BIGINT,
    month_appointments BIGINT,
    completed_appointments BIGINT,
    upcoming_appointments BIGINT,
    cancelled_appointments BIGINT
) AS $
DECLARE
    v_today DATE := CURRENT_DATE;
    v_week_start DATE;
    v_week_end DATE;
    v_month_start DATE;
    v_month_end DATE;
BEGIN
    v_week_start := v_today - (EXTRACT(DOW FROM v_today)::INTEGER - 1);
    v_week_end := v_week_start + INTERVAL '6 days';
    v_month_start := DATE_TRUNC('month', v_today)::DATE;
    v_month_end := (DATE_TRUNC('month', v_today) + INTERVAL '1 month - 1 day')::DATE;
    
    RETURN QUERY
    SELECT 
        COUNT(CASE WHEN appointment_date = v_today THEN 1 END) AS today_appointments,
        COUNT(CASE WHEN appointment_date BETWEEN v_week_start AND v_week_end THEN 1 END) AS week_appointments,
        COUNT(CASE WHEN appointment_date BETWEEN v_month_start AND v_month_end THEN 1 END) AS month_appointments,
        COUNT(CASE WHEN status = 'Completed' THEN 1 END) AS completed_appointments,
        COUNT(CASE WHEN status = 'Scheduled' OR status = 'Confirmed' THEN 1 END) AS upcoming_appointments,
        COUNT(CASE WHEN status = 'Cancelled' THEN 1 END) AS cancelled_appointments
    FROM appointments
    WHERE agent_id = p_agent_id AND is_active = true;
END;
$ LANGUAGE plpgsql;

-- ============================================
-- Missing Appointment Service Stored Procedures
-- ============================================

-- Get All Appointments with Filters
CREATE OR REPLACE FUNCTION sp_get_all_appointments(p_agent_id UUID,
    p_start_date DATE DEFAULT NULL,
    p_end_date DATE DEFAULT NULL,
    p_status VARCHAR(20) DEFAULT NULL,
    p_type VARCHAR(50) DEFAULT NULL,
    p_priority VARCHAR(10) DEFAULT NULL,
    p_client_id UUID DEFAULT NULL,
    p_search_term VARCHAR(200) DEFAULT NULL,
    p_page_size INTEGER DEFAULT 50,
    p_page_number INTEGER DEFAULT 1)
RETURNS TABLE (
    appointment_id UUID,
    client_id UUID,
    client_name VARCHAR(150),
    client_phone VARCHAR(20),
    title VARCHAR(200),
    description TEXT,
    appointment_date DATE,
    start_time TIME,
    end_time TIME,
    location VARCHAR(200),
    type VARCHAR(50),
    status VARCHAR(20),
    priority VARCHAR(10),
    notes TEXT,
    reminder_set BOOLEAN,
    created_date TIMESTAMP,
    modified_date TIMESTAMP,
    client_email VARCHAR(100),
    client_address TEXT,
    total_records BIGINT
) AS $$
DECLARE
    v_offset INTEGER;
    v_total_count BIGINT;
BEGIN
    v_offset := (p_page_number - 1) * p_page_size;
    
    -- Get total count first
    SELECT COUNT(*) INTO v_total_count
    FROM appointments a
    WHERE a.agent_id = p_agent_id 
        AND a.is_active = true
        AND (p_start_date IS NULL OR a.appointment_date >= p_start_date)
        AND (p_end_date IS NULL OR a.appointment_date <= p_end_date)
        AND (p_status IS NULL OR a.status = p_status)
        AND (p_type IS NULL OR a.type = p_type)
        AND (p_priority IS NULL OR a.priority = p_priority)
        AND (p_client_id IS NULL OR a.client_id = p_client_id)
        AND (p_search_term IS NULL OR 
             a.client_name ILIKE '%' || p_search_term || '%' OR 
             a.title ILIKE '%' || p_search_term || '%' OR
             a.description ILIKE '%' || p_search_term || '%' OR
             a.location ILIKE '%' || p_search_term || '%');
    
    -- Return paginated results with total count
    RETURN QUERY
    SELECT 
        a.appointment_id,
        a.client_id,
        a.client_name,
        a.client_phone,
        a.title,
        a.description,
        a.appointment_date,
        a.start_time,
        a.end_time,
        a.location,
        a.type,
        a.status,
        a.priority,
        a.notes,
        a.reminder_set,
        a.created_date,
        a.modified_date,
        c.email AS client_email,
        c.address AS client_address,
        v_total_count AS total_records
    FROM appointments a
    LEFT JOIN clients c ON a.client_id = c.client_id
    WHERE a.agent_id = p_agent_id 
        AND a.is_active = true
        AND (p_start_date IS NULL OR a.appointment_date >= p_start_date)
        AND (p_end_date IS NULL OR a.appointment_date <= p_end_date)
        AND (p_status IS NULL OR a.status = p_status)
        AND (p_type IS NULL OR a.type = p_type)
        AND (p_priority IS NULL OR a.priority = p_priority)
        AND (p_client_id IS NULL OR a.client_id = p_client_id)
        AND (p_search_term IS NULL OR 
             a.client_name ILIKE '%' || p_search_term || '%' OR 
             a.title ILIKE '%' || p_search_term || '%' OR
             a.description ILIKE '%' || p_search_term || '%' OR
             a.location ILIKE '%' || p_search_term || '%')
    ORDER BY a.appointment_date DESC, a.start_time DESC
    LIMIT p_page_size OFFSET v_offset;
END;
$ LANGUAGE plpgsql;

-- Get Appointment By ID
CREATE OR REPLACE FUNCTION sp_get_appointment_by_id(p_appointment_id UUID,
    p_agent_id UUID)
RETURNS TABLE (
    appointment_id UUID,
    client_id UUID,
    client_name VARCHAR(150),
    client_phone VARCHAR(20),
    title VARCHAR(200),
    description TEXT,
    appointment_date DATE,
    start_time TIME,
    end_time TIME,
    location VARCHAR(200),
    type VARCHAR(50),
    status VARCHAR(20),
    priority VARCHAR(10),
    notes TEXT,
    reminder_set BOOLEAN,
    created_date TIMESTAMP,
    modified_date TIMESTAMP,
    client_email VARCHAR(100),
    client_address TEXT,
    first_name VARCHAR(50),
    surname VARCHAR(50),
    last_name VARCHAR(50)
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        a.appointment_id,
        a.client_id,
        a.client_name,
        a.client_phone,
        a.title,
        a.description,
        a.appointment_date,
        a.start_time,
        a.end_time,
        a.location,
        a.type,
        a.status,
        a.priority,
        a.notes,
        a.reminder_set,
        a.created_date,
        a.modified_date,
        c.email AS client_email,
        c.address AS client_address,
        c.first_name,
        c.surname,
        c.last_name
    FROM appointments a
    LEFT JOIN clients c ON a.client_id = c.client_id
    WHERE a.appointment_id = p_appointment_id 
        AND a.agent_id = p_agent_id 
        AND a.is_active = true;
END;
$ LANGUAGE plpgsql;

-- Create Appointment
CREATE OR REPLACE FUNCTION sp_create_appointment(p_agent_id UUID,
    p_client_id UUID,
    p_title VARCHAR(200),
    p_appointment_date DATE,
    p_start_time TIME,
    p_end_time TIME,
    p_type VARCHAR(50),
    p_description TEXT DEFAULT NULL,
    p_location VARCHAR(200) DEFAULT NULL,
    p_status VARCHAR(20) DEFAULT 'Scheduled',
    p_priority VARCHAR(10) DEFAULT 'Medium',
    p_notes TEXT DEFAULT NULL,
    p_reminder_set BOOLEAN DEFAULT false)
RETURNS TABLE (
    success INTEGER,
    message TEXT,
    appointment_id UUID
) AS $$
DECLARE
    v_appointment_id UUID;
    v_client_name VARCHAR(150);
    v_client_phone VARCHAR(20);
    v_conflict_count INTEGER;
BEGIN
    -- Generate new appointment ID
    v_appointment_id := gen_random_uuid();
    
    -- Validate time range
    IF p_end_time <= p_start_time THEN
        RETURN QUERY SELECT 0, 'End time must be after start time'::TEXT, NULL::UUID;
        RETURN;
    END IF;

    -- Get client details
    SELECT 
        COALESCE(first_name, '') || ' ' || COALESCE(surname, ''),
        phone_number
    INTO v_client_name, v_client_phone
    FROM clients 
    WHERE client_id = p_client_id 
      AND agent_id = p_agent_id 
      AND is_active = true;
    
    IF v_client_name IS NULL THEN
        RETURN QUERY SELECT 0, 'Client not found'::TEXT, NULL::UUID;
        RETURN;
    END IF;
    
    -- Check for time conflicts
    SELECT COUNT(*) INTO v_conflict_count
    FROM appointments 
    WHERE agent_id = p_agent_id 
      AND appointment_date = p_appointment_date
      AND is_active = true
      AND status NOT IN ('Cancelled')
      AND (
          -- Overlap detection: one starts before the other ends AND ends after the other starts
          (p_start_time < end_time AND p_end_time > start_time)
      );
    
    IF v_conflict_count > 0 THEN
        RETURN QUERY SELECT 0, 'Time conflict with existing appointment'::TEXT, NULL::UUID;
        RETURN;
    END IF;
    
    -- Insert new appointment
    INSERT INTO appointments (
        appointment_id, client_id, agent_id, client_name, client_phone,
        title, description, appointment_date, start_time, end_time,
        location, type, status, priority, notes, reminder_set,
        created_date, modified_date, is_active
    )
    VALUES (
        v_appointment_id, p_client_id, p_agent_id, v_client_name, v_client_phone,
        p_title, p_description, p_appointment_date, p_start_time, p_end_time,
        p_location, p_type, p_status, p_priority, p_notes, p_reminder_set,
        CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, true
    );
    
    RETURN QUERY SELECT 1, 'Appointment created successfully'::TEXT, v_appointment_id;
END;
$ LANGUAGE plpgsql;

-- Get All Appointments with Filters
CREATE OR REPLACE FUNCTION sp_get_all_appointments(p_agent_id UUID,
    p_start_date DATE DEFAULT NULL,
    p_end_date DATE DEFAULT NULL,
    p_status VARCHAR(20) DEFAULT NULL,
    p_type VARCHAR(50) DEFAULT NULL,
    p_priority VARCHAR(10) DEFAULT NULL,
    p_client_id UUID DEFAULT NULL,
    p_search_term VARCHAR(200) DEFAULT NULL,
    p_page_size INTEGER DEFAULT 50,
    p_page_number INTEGER DEFAULT 1)
RETURNS TABLE (
    appointment_id UUID,
    client_id UUID,
    client_name VARCHAR(150),
    client_phone VARCHAR(20),
    title VARCHAR(200),
    description TEXT,
    appointment_date DATE,
    start_time TIME,
    end_time TIME,
    location VARCHAR(200),
    type VARCHAR(50),
    status VARCHAR(20),
    priority VARCHAR(10),
    notes TEXT,
    reminder_set BOOLEAN,
    created_date TIMESTAMP,
    modified_date TIMESTAMP,
    client_email VARCHAR(100),
    client_address TEXT,
    total_records BIGINT
) AS $$
DECLARE
    v_offset INTEGER;
    v_total_count BIGINT;
BEGIN
    v_offset := (p_page_number - 1) * p_page_size;
    
    -- Get total count first
    SELECT COUNT(*) INTO v_total_count
    FROM appointments a
    WHERE a.agent_id = p_agent_id 
        AND a.is_active = true
        AND (p_start_date IS NULL OR a.appointment_date >= p_start_date)
        AND (p_end_date IS NULL OR a.appointment_date <= p_end_date)
        AND (p_status IS NULL OR a.status = p_status)
        AND (p_type IS NULL OR a.type = p_type)
        AND (p_priority IS NULL OR a.priority = p_priority)
        AND (p_client_id IS NULL OR a.client_id = p_client_id)
        AND (p_search_term IS NULL OR 
             a.client_name ILIKE '%' || p_search_term || '%' OR 
             a.title ILIKE '%' || p_search_term || '%' OR
             a.description ILIKE '%' || p_search_term || '%' OR
             a.location ILIKE '%' || p_search_term || '%');
    
    -- Return paginated results with total count
    RETURN QUERY
    SELECT 
        a.appointment_id,
        a.client_id,
        a.client_name,
        a.client_phone,
        a.title,
        a.description,
        a.appointment_date,
        a.start_time,
        a.end_time,
        a.location,
        a.type,
        a.status,
        a.priority,
        a.notes,
        a.reminder_set,
        a.created_date,
        a.modified_date,
        c.email AS client_email,
        c.address AS client_address,
        v_total_count AS total_records
    FROM appointments a
    LEFT JOIN clients c ON a.client_id = c.client_id
    WHERE a.agent_id = p_agent_id 
        AND a.is_active = true
        AND (p_start_date IS NULL OR a.appointment_date >= p_start_date)
        AND (p_end_date IS NULL OR a.appointment_date <= p_end_date)
        AND (p_status IS NULL OR a.status = p_status)
        AND (p_type IS NULL OR a.type = p_type)
        AND (p_priority IS NULL OR a.priority = p_priority)
        AND (p_client_id IS NULL OR a.client_id = p_client_id)
        AND (p_search_term IS NULL OR 
             a.client_name ILIKE '%' || p_search_term || '%' OR 
             a.title ILIKE '%' || p_search_term || '%' OR
             a.description ILIKE '%' || p_search_term || '%' OR
             a.location ILIKE '%' || p_search_term || '%')
    ORDER BY a.appointment_date DESC, a.start_time DESC
    LIMIT p_page_size OFFSET v_offset;
END;
$ LANGUAGE plpgsql;

-- Update Appointment
CREATE OR REPLACE FUNCTION sp_update_appointment(p_appointment_id UUID,
    p_agent_id UUID,
    p_title VARCHAR(200) DEFAULT NULL,
    p_description TEXT DEFAULT NULL,
    p_appointment_date DATE DEFAULT NULL,
    p_start_time TIME DEFAULT NULL,
    p_end_time TIME DEFAULT NULL,
    p_location VARCHAR(200) DEFAULT NULL,
    p_type VARCHAR(50) DEFAULT NULL,
    p_priority VARCHAR(10) DEFAULT NULL,
    p_notes TEXT DEFAULT NULL,
    p_reminder_set BOOLEAN DEFAULT NULL)
RETURNS TABLE (
    success INTEGER,
    message TEXT
) AS  $$
$
DECLARE
    v_appointment_exists INTEGER
$$ LANGUAGE plpgsql;
    v_conflict_count INTEGER;
BEGIN
    -- Check if appointment exists
    SELECT COUNT(*) INTO v_appointment_exists
    FROM appointments 
    WHERE appointment_id = p_appointment_id 
      AND agent_id = p_agent_id 
      AND is_active = true;
    
    IF v_appointment_exists = 0 THEN
        RETURN QUERY SELECT 0, 'Appointment not found'::TEXT;
        RETURN;
    END IF;
    
    -- If updating date/time, check for conflicts
    IF p_appointment_date IS NOT NULL AND p_start_time IS NOT NULL AND p_end_time IS NOT NULL THEN
        SELECT COUNT(*) INTO v_conflict_count
        FROM appointments 
        WHERE agent_id = p_agent_id 
            AND appointment_id <> p_appointment_id
            AND appointment_date = p_appointment_date
            AND is_active = true
            AND status NOT IN ('Cancelled')
            AND (
                -- Overlap detection
                (p_start_time < end_time AND p_end_time > start_time)
            );
        
        IF v_conflict_count > 0 THEN
            RETURN QUERY SELECT 0, 'Time conflict with existing appointment'::TEXT;
            RETURN;
        END IF;
    END IF;
    
    UPDATE appointments 
    SET 
        title = COALESCE(p_title, title),
        description = COALESCE(p_description, description),
        appointment_date = COALESCE(p_appointment_date, appointment_date),
        start_time = COALESCE(p_start_time, start_time),
        end_time = COALESCE(p_end_time, end_time),
        location = COALESCE(p_location, location),
        type = COALESCE(p_type, type),
        priority = COALESCE(p_priority, priority),
        notes = COALESCE(p_notes, notes),
        reminder_set = COALESCE(p_reminder_set, reminder_set),
        modified_date = CURRENT_TIMESTAMP
    WHERE appointment_id = p_appointment_id AND agent_id = p_agent_id;
    
    RETURN QUERY SELECT 1, 'Appointment updated successfully'::TEXT;
END;
$ LANGUAGE plpgsql;

-- Get Appointments for Specific Date
CREATE OR REPLACE FUNCTION sp_get_appointments_for_date(p_agent_id UUID,
    p_appointment_date DATE)
RETURNS TABLE (
    appointment_id UUID,
    client_id UUID,
    client_name VARCHAR(150),
    client_phone VARCHAR(20),
    title VARCHAR(200),
    description TEXT,
    start_time TIME,
    end_time TIME,
    location VARCHAR(200),
    type VARCHAR(50),
    status VARCHAR(20),
    priority VARCHAR(10),
    notes TEXT,
    reminder_set BOOLEAN
) AS  $$
$
 $
BEGIN
    RETURN QUERY
    SELECT 
        a.appointment_id,
        a.client_id,
        a.client_name,
        a.client_phone,
        a.title,
        a.description,
        a.start_time,
        a.end_time,
        a.location,
        a.type,
        a.status,
        a.priority,
        a.notes,
        a.reminder_set
    FROM appointments a
    WHERE a.agent_id = p_agent_id 
        AND a.appointment_date = p_appointment_date
        AND a.is_active = true
        AND a.status NOT IN ('Cancelled')
    ORDER BY a.start_time
$$ LANGUAGE plpgsql;
END;
$ LANGUAGE plpgsql;

-- Search Appointments
CREATE OR REPLACE FUNCTION sp_search_appointments(p_agent_id UUID,
    p_search_term VARCHAR(200))
RETURNS TABLE (
    appointment_id UUID,
    client_id UUID,
    client_name VARCHAR(150),
    client_phone VARCHAR(20),
    title VARCHAR(200),
    description TEXT,
    appointment_date DATE,
    start_time TIME,
    end_time TIME,
    location VARCHAR(200),
    type VARCHAR(50),
    status VARCHAR(20),
    priority VARCHAR(10),
    notes TEXT,
    created_date TIMESTAMP
) AS  $$
$
BEGIN
    RETURN QUERY
    SELECT 
        a.appointment_id,
        a.client_id,
        a.client_name,
        a.client_phone,
        a.title,
        a.description,
        a.appointment_date,
        a.start_time,
        a.end_time,
        a.location,
        a.type,
        a.status,
        a.priority,
        a.notes,
        a.created_date
    FROM appointments a
    WHERE a.agent_id = p_agent_id 
        AND a.is_active = true
        AND (
            a.client_name ILIKE '%' || p_search_term || '%' OR 
            a.title ILIKE '%' || p_search_term || '%' OR
            a.description ILIKE '%' || p_search_term || '%' OR
            a.location ILIKE '%' || p_search_term || '%' OR
            a.type ILIKE '%' || p_search_term || '%'
        )
    ORDER BY a.appointment_date DESC, a.start_time DESC
$$ LANGUAGE plpgsql;
END;
$ LANGUAGE plpgsql;

-- Check Time Conflicts
CREATE OR REPLACE FUNCTION sp_check_time_conflicts(p_agent_id UUID,
    p_appointment_date DATE,
    p_start_time TIME,
    p_end_time TIME,
    p_exclude_appointment_id UUID DEFAULT NULL)
RETURNS TABLE (
    has_conflict INTEGER,
    conflict_count INTEGER
) AS  $$
$
DECLARE
    v_conflict_count INTEGER
$$ LANGUAGE plpgsql;
BEGIN
    SELECT COUNT(*) INTO v_conflict_count
    FROM appointments
    WHERE agent_id = p_agent_id
      AND appointment_date = p_appointment_date
      AND is_active = true
      AND status NOT IN ('Cancelled')
      AND (p_exclude_appointment_id IS NULL OR appointment_id <> p_exclude_appointment_id)
      AND (
            -- Real overlap check
            NOT (p_end_time <= start_time OR p_start_time >= end_time)
          );

    RETURN QUERY SELECT 
        CASE WHEN v_conflict_count > 0 THEN 1 ELSE 0 END,
        v_conflict_count;
END;
$ LANGUAGE plpgsql;

-- ============================================
-- Reminder Service Functions
-- ============================================

-- Get All Reminders with Filters
CREATE OR REPLACE FUNCTION sp_get_all_reminders(p_agent_id UUID,
    p_start_date DATE DEFAULT NULL,
    p_end_date DATE DEFAULT NULL,
    p_reminder_type VARCHAR(50) DEFAULT NULL,
    p_status VARCHAR(20) DEFAULT NULL,
    p_priority VARCHAR(10) DEFAULT NULL,
    p_client_id UUID DEFAULT NULL,
    p_search_term VARCHAR(200) DEFAULT NULL,
    p_page_size INTEGER DEFAULT 50,
    p_page_number INTEGER DEFAULT 1)
RETURNS TABLE (
    reminder_id UUID,
    client_id UUID,
    appointment_id UUID,
    reminder_type VARCHAR(50),
    title VARCHAR(200),
    description TEXT,
    reminder_date DATE,
    reminder_time TIME,
    client_name VARCHAR(150),
    priority VARCHAR(10),
    status VARCHAR(20),
    enable_sms BOOLEAN,
    enable_whatsapp BOOLEAN,
    enable_push_notification BOOLEAN,
    advance_notice VARCHAR(20),
    custom_message TEXT,
    auto_send BOOLEAN,
    notes TEXT,
    created_date TIMESTAMP,
    modified_date TIMESTAMP,
    completed_date TIMESTAMP,
    client_phone VARCHAR(20),
    client_email VARCHAR(100),
    total_records BIGINT
) AS  $$
$
DECLARE
    v_offset INTEGER
$$ LANGUAGE plpgsql;
    v_total_count BIGINT;
BEGIN
    v_offset := (p_page_number - 1) * p_page_size;
    
    -- Get total count
    SELECT COUNT(*) INTO v_total_count
    FROM reminders r
    WHERE r.agent_id = p_agent_id 
        AND (p_start_date IS NULL OR r.reminder_date >= p_start_date)
        AND (p_end_date IS NULL OR r.reminder_date <= p_end_date)
        AND (p_reminder_type IS NULL OR r.reminder_type = p_reminder_type)
        AND (p_status IS NULL OR r.status = p_status)
        AND (p_priority IS NULL OR r.priority = p_priority)
        AND (p_client_id IS NULL OR r.client_id = p_client_id)
        AND (p_search_term IS NULL OR 
             r.client_name ILIKE '%' || p_search_term || '%' OR 
             r.title ILIKE '%' || p_search_term || '%' OR
             r.description ILIKE '%' || p_search_term || '%' OR
             r.notes ILIKE '%' || p_search_term || '%');
    
    RETURN QUERY
    SELECT 
        r.reminder_id,
        r.client_id,
        r.appointment_id,
        r.reminder_type,
        r.title,
        r.description,
        r.reminder_date,
        r.reminder_time,
        r.client_name,
        r.priority,
        r.status,
        r.enable_sms,
        r.enable_whatsapp,
        r.enable_push_notification,
        r.advance_notice,
        r.custom_message,
        r.auto_send,
        r.notes,
        r.created_date,
        r.modified_date,
        r.completed_date,
        c.phone_number AS client_phone,
        c.email AS client_email,
        v_total_count AS total_records
    FROM reminders r
    LEFT JOIN clients c ON r.client_id = c.client_id
    WHERE r.agent_id = p_agent_id 
        AND (p_start_date IS NULL OR r.reminder_date >= p_start_date)
        AND (p_end_date IS NULL OR r.reminder_date <= p_end_date)
        AND (p_reminder_type IS NULL OR r.reminder_type = p_reminder_type)
        AND (p_status IS NULL OR r.status = p_status)
        AND (p_priority IS NULL OR r.priority = p_priority)
        AND (p_client_id IS NULL OR r.client_id = p_client_id)
        AND (p_search_term IS NULL OR 
             r.client_name ILIKE '%' || p_search_term || '%' OR 
             r.title ILIKE '%' || p_search_term || '%' OR
             r.description ILIKE '%' || p_search_term || '%' OR
             r.notes ILIKE '%' || p_search_term || '%')
    ORDER BY r.reminder_date DESC, r.reminder_time DESC
    LIMIT p_page_size OFFSET v_offset;
END;
$ LANGUAGE plpgsql;

-- Get Reminder By ID
CREATE OR REPLACE FUNCTION sp_get_reminder_by_id(p_reminder_id UUID,
    p_agent_id UUID)
RETURNS TABLE (
    reminder_id UUID,
    client_id UUID,
    appointment_id UUID,
    reminder_type VARCHAR(50),
    title VARCHAR(200),
    description TEXT,
    reminder_date DATE,
    reminder_time TIME,
    client_name VARCHAR(150),
    priority VARCHAR(10),
    status VARCHAR(20),
    enable_sms BOOLEAN,
    enable_whatsapp BOOLEAN,
    enable_push_notification BOOLEAN,
    advance_notice VARCHAR(20),
    custom_message TEXT,
    auto_send BOOLEAN,
    notes TEXT,
    created_date TIMESTAMP,
    modified_date TIMESTAMP,
    completed_date TIMESTAMP,
    client_phone VARCHAR(20),
    client_email VARCHAR(100),
    first_name VARCHAR(50),
    surname VARCHAR(50),
    last_name VARCHAR(50)
) AS $
BEGIN
    RETURN QUERY
    SELECT 
        r.reminder_id,
        r.client_id,
        r.appointment_id,
        r.reminder_type,
        r.title,
        r.description,
        r.reminder_date,
        r.reminder_time,
        r.client_name,
        r.priority,
        r.status,
        r.enable_sms,
        r.enable_whatsapp,
        r.enable_push_notification,
        r.advance_notice,
        r.custom_message,
        r.auto_send,
        r.notes,
        r.created_date,
        r.modified_date,
        r.completed_date,
        c.phone_number AS client_phone,
        c.email AS  $$
client_email,
        c.first_name,
        c.surname,
        c.last_name
    FROM reminders r
    LEFT JOIN clients c ON r.client_id = c.client_id
    WHERE r.reminder_id = p_reminder_id 
        AND r.agent_id = p_agent_id
$$ LANGUAGE plpgsql;
END;
$ LANGUAGE plpgsql;

-- Create Reminder
CREATE OR REPLACE FUNCTION sp_create_reminder(p_agent_id UUID,
    p_reminder_type VARCHAR(50),
    p_title VARCHAR(200),
    p_reminder_date DATE,
    p_client_id UUID DEFAULT NULL,
    p_appointment_id UUID DEFAULT NULL,
    p_description TEXT DEFAULT NULL,
    p_reminder_time TIME DEFAULT NULL,
    p_priority VARCHAR(10) DEFAULT 'Medium',
    p_enable_sms BOOLEAN DEFAULT false,
    p_enable_whatsapp BOOLEAN DEFAULT false,
    p_enable_push_notification BOOLEAN DEFAULT true,
    p_advance_notice VARCHAR(20) DEFAULT '1 day',
    p_custom_message TEXT DEFAULT NULL,
    p_auto_send BOOLEAN DEFAULT false,
    p_notes TEXT DEFAULT NULL)
RETURNS TABLE (
    success INTEGER,
    message TEXT,
    reminder_id UUID
) AS  $$
$
DECLARE
    v_reminder_id UUID
$$ LANGUAGE plpgsql;
    v_client_name VARCHAR(150);
BEGIN
    v_reminder_id := gen_random_uuid();
    
    -- Get client name if ClientId is provided
    IF p_client_id IS NOT NULL THEN
        SELECT COALESCE(first_name, '') || ' ' || COALESCE(surname, '') INTO v_client_name
        FROM clients 
        WHERE client_id = p_client_id AND agent_id = p_agent_id AND is_active = true;
    END IF;
    
    INSERT INTO reminders (
        reminder_id, client_id, appointment_id, agent_id, reminder_type,
        title, description, reminder_date, reminder_time, client_name,
        priority, status, enable_sms, enable_whatsapp, enable_push_notification,
        advance_notice, custom_message, auto_send, notes,
        created_date, modified_date
    )
    VALUES (
        v_reminder_id, p_client_id, p_appointment_id, p_agent_id, p_reminder_type,
        p_title, p_description, p_reminder_date, p_reminder_time, v_client_name,
        p_priority, 'Active', p_enable_sms, p_enable_whatsapp, p_enable_push_notification,
        p_advance_notice, p_custom_message, p_auto_send, p_notes,
        CURRENT_TIMESTAMP, CURRENT_TIMESTAMP
    );
    
    RETURN QUERY SELECT 1, 'Reminder created successfully'::TEXT, v_reminder_id;
END;
$ LANGUAGE plpgsql;

-- Update Reminder
CREATE OR REPLACE FUNCTION sp_update_reminder(p_reminder_id UUID,
    p_agent_id UUID,
    p_title VARCHAR(200) DEFAULT NULL,
    p_description TEXT DEFAULT NULL,
    p_reminder_date DATE DEFAULT NULL,
    p_reminder_time TIME DEFAULT NULL,
    p_priority VARCHAR(10) DEFAULT NULL,
    p_enable_sms BOOLEAN DEFAULT NULL,
    p_enable_whatsapp BOOLEAN DEFAULT NULL,
    p_enable_push_notification BOOLEAN DEFAULT NULL,
    p_advance_notice VARCHAR(20) DEFAULT NULL,
    p_custom_message TEXT DEFAULT NULL,
    p_auto_send BOOLEAN DEFAULT NULL,
    p_notes TEXT DEFAULT NULL)
RETURNS TABLE (
    success INTEGER,
    message TEXT
) AS  $$
$
DECLARE
    v_reminder_exists INTEGER
$$ LANGUAGE plpgsql;
BEGIN
    -- Check if reminder exists
    SELECT COUNT(*) INTO v_reminder_exists
    FROM reminders 
    WHERE reminder_id = p_reminder_id AND agent_id = p_agent_id;
    
    IF v_reminder_exists = 0 THEN
        RETURN QUERY SELECT 0, 'Reminder not found'::TEXT;
        RETURN;
    END IF;
    
    UPDATE reminders 
    SET 
        title = COALESCE(p_title, title),
        description = COALESCE(p_description, description),
        reminder_date = COALESCE(p_reminder_date, reminder_date),
        reminder_time = COALESCE(p_reminder_time, reminder_time),
        priority = COALESCE(p_priority, priority),
        enable_sms = COALESCE(p_enable_sms, enable_sms),
        enable_whatsapp = COALESCE(p_enable_whatsapp, enable_whatsapp),
        enable_push_notification = COALESCE(p_enable_push_notification, enable_push_notification),
        advance_notice = COALESCE(p_advance_notice, advance_notice),
        custom_message = COALESCE(p_custom_message, custom_message),
        auto_send = COALESCE(p_auto_send, auto_send),
        notes = COALESCE(p_notes, notes),
        modified_date = CURRENT_TIMESTAMP
    WHERE reminder_id = p_reminder_id AND agent_id = p_agent_id;
    
    RETURN QUERY SELECT 1, 'Reminder updated successfully'::TEXT;
END;
$ LANGUAGE plpgsql;

-- Get Appointment By ID
CREATE OR REPLACE FUNCTION sp_get_appointment_by_id(p_appointment_id UUID,
    p_agent_id UUID)
RETURNS TABLE (
    appointment_id UUID,
    client_id UUID,
    client_name VARCHAR(150),
    client_phone VARCHAR(20),
    title VARCHAR(200),
    description TEXT,
    appointment_date DATE,
    start_time TIME,
    end_time TIME,
    location VARCHAR(200),
    type VARCHAR(50),
    status VARCHAR(20),
    priority VARCHAR(10),
    notes TEXT,
    reminder_set BOOLEAN,
    created_date TIMESTAMP,
    modified_date TIMESTAMP,
    client_email VARCHAR(100),
    client_address TEXT,
    first_name VARCHAR(50),
    surname VARCHAR(50),
    last_name VARCHAR(50)
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        a.appointment_id,
        a.client_id,
        a.client_name,
        a.client_phone,
        a.title,
        a.description,
        a.appointment_date,
        a.start_time,
        a.end_time,
        a.location,
        a.type,
        a.status,
        a.priority,
        a.notes,
        a.reminder_set,
        a.created_date,
        a.modified_date,
        c.email AS client_email,
        c.address AS client_address,
        c.first_name,
        c.surname,
        c.last_name
    FROM appointments a
    LEFT JOIN clients c ON a.client_id = c.client_id
    WHERE a.appointment_id = p_appointment_id 
        AND a.agent_id = p_agent_id 
        AND a.is_active = true;
END;
$ LANGUAGE plpgsql;

-- Create Appointment
CREATE OR REPLACE FUNCTION sp_create_appointment(p_agent_id UUID,
    p_client_id UUID,
    p_title VARCHAR(200),
    p_appointment_date DATE,
    p_start_time TIME,
    p_end_time TIME,
    p_type VARCHAR(50),
    p_description TEXT DEFAULT NULL,
    p_location VARCHAR(200) DEFAULT NULL,
    p_status VARCHAR(20) DEFAULT 'Scheduled',
    p_priority VARCHAR(10) DEFAULT 'Medium',
    p_notes TEXT DEFAULT NULL,
    p_reminder_set BOOLEAN DEFAULT false)
RETURNS TABLE (
    success INTEGER,
    message TEXT,
    appointment_id UUID
) AS $$
DECLARE
    v_appointment_id UUID;
    v_client_name VARCHAR(150);
    v_client_phone VARCHAR(20);
    v_conflict_count INTEGER;
BEGIN
    -- Generate new appointment ID
    v_appointment_id := gen_random_uuid();
    
    -- Validate time range
    IF p_end_time <= p_start_time THEN
        RETURN QUERY SELECT 0, 'End time must be after start time'::TEXT, NULL::UUID;
        RETURN;
    END IF;

    -- Get client details
    SELECT 
        COALESCE(first_name, '') || ' ' || COALESCE(surname, ''),
        phone_number
    INTO v_client_name, v_client_phone
    FROM clients 
    WHERE client_id = p_client_id 
      AND agent_id = p_agent_id 
      AND is_active = true;
    
    IF v_client_name IS NULL THEN
        RETURN QUERY SELECT 0, 'Client not found'::TEXT, NULL::UUID;
        RETURN;
    END IF;
    
    -- Check for time conflicts
    SELECT COUNT(*) INTO v_conflict_count
    FROM appointments 
    WHERE agent_id = p_agent_id 
      AND appointment_date = p_appointment_date
      AND is_active = true
      AND status NOT IN ('Cancelled')
      AND (
          -- Overlap detection: one starts before the other ends AND ends after the other starts
          (p_start_time < end_time AND p_end_time > start_time)
      );
    
    IF v_conflict_count > 0 THEN
        RETURN QUERY SELECT 0, 'Time conflict with existing appointment'::TEXT, NULL::UUID;
        RETURN;
    END IF;
    
    -- Insert new appointment
    INSERT INTO appointments (
        appointment_id, client_id, agent_id, client_name, client_phone,
        title, description, appointment_date, start_time, end_time,
        location, type, status, priority, notes, reminder_set,
        created_date, modified_date, is_active
    )
    VALUES (
        v_appointment_id, p_client_id, p_agent_id, v_client_name, v_client_phone,
        p_title, p_description, p_appointment_date, p_start_time, p_end_time,
        p_location, p_type, p_status, p_priority, p_notes, p_reminder_set,
        CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, true
    );
    
    RETURN QUERY SELECT 1, 'Appointment created successfully'::TEXT, v_appointment_id;
END;
$ LANGUAGE plpgsql;

-- Get Upcoming Reminders
CREATE OR REPLACE FUNCTION sp_get_upcoming_reminders(p_agent_id UUID,
    p_days_ahead INTEGER DEFAULT 7)
RETURNS TABLE (
    reminder_id UUID,
    client_id UUID,
    reminder_type VARCHAR(50),
    title VARCHAR(255),
    description TEXT,
    reminder_date DATE,
    reminder_time TIME,
    client_name VARCHAR(255),
    priority VARCHAR(20),
    status VARCHAR(20),
    notes TEXT,
    client_phone VARCHAR(20)
) AS $
DECLARE
    v_end_date DATE := CURRENT_DATE + INTERVAL '1 day' * p_days_ahead;
BEGIN
    RETURN QUERY
    SELECT 
        r.reminder_id,
        r.client_id,
        r.reminder_type,
        r.title,
        r.description,
        r.reminder_date,
        r.reminder_time,
        r.client_name,
        r.priority,
        r.status,
        r.notes,
        c.phone_number AS client_phone
    FROM reminders r
    LEFT JOIN clients c ON r.client_id = c.client_id
    WHERE r.agent_id = p_agent_id 
        AND r.status = 'Active'
        AND r.reminder_date BETWEEN CURRENT_DATE AND v_end_date
    ORDER BY r.reminder_date, r.reminder_time;
END;
$ LANGUAGE plpgsql;

-- Get Completed Reminders
CREATE OR REPLACE FUNCTION sp_get_completed_reminders(p_agent_id UUID,
    p_start_date DATE DEFAULT NULL,
    p_end_date DATE DEFAULT NULL)
RETURNS TABLE (
    reminder_id UUID,
    client_id UUID,
    reminder_type VARCHAR(50),
    title VARCHAR(255),
    description TEXT,
    reminder_date DATE,
    reminder_time TIME,
    client_name VARCHAR(255),
    priority VARCHAR(20),
    status VARCHAR(20),
    completed_date TIMESTAMP,
    notes TEXT,
    client_phone VARCHAR(20)
) AS $
DECLARE
    v_start_date DATE := COALESCE(p_start_date, CURRENT_DATE - INTERVAL '30 days');
    v_end_date DATE := COALESCE(p_end_date, CURRENT_DATE);
BEGIN
    RETURN QUERY
    SELECT 
        r.reminder_id,
        r.client_id,
        r.reminder_type,
        r.title,
        r.description,
        r.reminder_date,
        r.reminder_time,
        r.client_name,
        r.priority,
        r.status,
        r.completed_date,
        r.notes,
        c.phone_number AS client_phone
    FROM reminders r
    LEFT JOIN clients c ON r.client_id = c.client_id
    WHERE r.agent_id = p_agent_id 
        AND r.status = 'Completed'
        AND r.completed_date BETWEEN v_start_date AND (v_end_date + INTERVAL '1 day')
    ORDER BY r.completed_date DESC;
END;
$ LANGUAGE plpgsql;

-- Update Reminder Setting
CREATE OR REPLACE FUNCTION sp_update_reminder_setting(p_agent_id UUID,
    p_reminder_type VARCHAR(50),
    p_is_enabled BOOLEAN DEFAULT NULL,
    p_days_before INTEGER DEFAULT NULL,
    p_time_of_day TIME DEFAULT NULL,
    p_repeat_daily BOOLEAN DEFAULT NULL)
RETURNS TABLE (
    success INTEGER,
    message TEXT
) AS $$
BEGIN
    IF EXISTS (SELECT 1 FROM reminder_settings WHERE agent_id = p_agent_id AND reminder_type = p_reminder_type) THEN
        UPDATE reminder_settings 
        SET 
            is_enabled = COALESCE(p_is_enabled, is_enabled),
            days_before = COALESCE(p_days_before, days_before),
            time_of_day = COALESCE(p_time_of_day, time_of_day),
            repeat_daily = COALESCE(p_repeat_daily, repeat_daily),
            modified_date = NOW()
        WHERE agent_id = p_agent_id AND reminder_type = p_reminder_type;
    ELSE
        INSERT INTO reminder_settings (
            agent_id, reminder_type, is_enabled, days_before, time_of_day, repeat_daily
        )
        VALUES (
            p_agent_id, p_reminder_type, COALESCE(p_is_enabled, true), 
            COALESCE(p_days_before, 1), COALESCE(p_time_of_day, '09:00'::TIME), 
            COALESCE(p_repeat_daily, false)
        );
    END IF;
    
    RETURN QUERY SELECT 1 AS success, 'Reminder setting updated successfully'::TEXT AS message;
END;
$ LANGUAGE plpgsql;

-- Create or Update Client
CREATE OR REPLACE FUNCTION sp_upsert_client(p_agent_id UUID,
    p_first_name VARCHAR(50),
    p_surname VARCHAR(50),
    p_last_name VARCHAR(50),
    p_phone_number VARCHAR(20),
    p_email VARCHAR(100),
    p_address VARCHAR(500),
    p_national_id VARCHAR(20),
    p_date_of_birth DATE,
    p_is_client BOOLEAN,
    p_client_id UUID DEFAULT NULL,
    p_notes TEXT DEFAULT NULL)
RETURNS TABLE (
    client_id UUID
) AS $$
DECLARE
    v_client_id UUID := COALESCE(p_client_id, gen_random_uuid());
    v_client_name TEXT := p_first_name || ' ' || p_surname;
BEGIN
    IF p_client_id IS NULL THEN
        -- Create new client
        INSERT INTO clients (
            client_id, agent_id, first_name, surname, last_name, phone_number, 
            email, address, national_id, date_of_birth, is_client, notes
        )
        VALUES (
            v_client_id, p_agent_id, p_first_name, p_surname, p_last_name, p_phone_number,
            p_email, p_address, p_national_id, p_date_of_birth, p_is_client, p_notes
        );
        
        -- Log activity
        INSERT INTO activity_log (agent_id, activity_type, entity_type, entity_id, description)
        VALUES (p_agent_id, 'client_created', 'client', v_client_id, 
                v_client_name || ' added as ' || CASE WHEN p_is_client THEN 'client' ELSE 'prospect' END);
    ELSE
        -- Update existing client
        v_client_id := p_client_id;
        
        UPDATE clients 
        SET 
            first_name = p_first_name,
            surname = p_surname,
            last_name = p_last_name,
            phone_number = p_phone_number,
            email = p_email,
            address = p_address,
            national_id = p_national_id,
            date_of_birth = p_date_of_birth,
            is_client = p_is_client,
            notes = p_notes,
            modified_date = NOW()
        WHERE clients.client_id = p_client_id;
        
        -- Log activity
        INSERT INTO activity_log (agent_id, activity_type, entity_type, entity_id, description)
        VALUES (p_agent_id, 'client_updated', 'client', v_client_id, v_client_name || ' updated');
    END IF;
    
    RETURN QUERY SELECT v_client_id;
END;
$ LANGUAGE plpgsql;

-- Get Clients
CREATE OR REPLACE FUNCTION sp_get_clients(p_agent_id UUID,
    p_search_term VARCHAR(100) DEFAULT NULL,
    p_filter_type VARCHAR(20) DEFAULT 'all',
    p_insurance_type VARCHAR(50) DEFAULT NULL)
RETURNS TABLE (
    client_id UUID,
    first_name VARCHAR(50),
    surname VARCHAR(50),
    last_name VARCHAR(50),
    phone_number VARCHAR(20),
    email VARCHAR(100),
    address VARCHAR(500),
    national_id VARCHAR(20),
    date_of_birth DATE,
    is_client BOOLEAN,
    insurance_type VARCHAR(50),
    notes TEXT,
    created_date TIMESTAMP,
    modified_date TIMESTAMP,
    policy_id UUID,
    policy_name VARCHAR(255),
    policy_type VARCHAR(100),
    policy_company VARCHAR(255),
    policy_status VARCHAR(20),
    policy_start_date DATE,
    policy_end_date DATE,
    policy_notes TEXT
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        c.client_id,
        c.first_name,
        c.surname,
        c.last_name,
        c.phone_number,
        c.email,
        c.address,
        c.national_id,
        c.date_of_birth,
        c.is_client,
        c.insurance_type,
        c.notes,
        c.created_date,
        c.modified_date,

        -- Policy Info from related tables
        cp.policy_id,
        cp.policy_name,
        pt.type_name AS policy_type,
        ic.company_name AS policy_company,
        cp.status AS policy_status,
        cp.start_date AS policy_start_date,
        cp.end_date AS policy_end_date,
        cp.notes AS policy_notes
    FROM clients c
    LEFT JOIN client_policies cp 
        ON c.client_id = cp.client_id AND cp.is_active = true
    LEFT JOIN policy_catalog pc
        ON cp.policy_catalog_id = pc.policy_catalog_id
    LEFT JOIN policy_types pt
        ON pc.type_id = pt.type_id
    LEFT JOIN insurance_companies ic
        ON pc.company_id = ic.company_id
    WHERE 
        c.agent_id = p_agent_id 
        AND c.is_active = true
        AND (
            p_search_term IS NULL OR 
            c.first_name ILIKE '%' || p_search_term || '%' OR
            c.surname ILIKE '%' || p_search_term || '%' OR
            c.last_name ILIKE '%' || p_search_term || '%' OR
            c.phone_number ILIKE '%' || p_search_term || '%' OR
            c.email ILIKE '%' || p_search_term || '%'
        )
        AND (
            p_filter_type = 'all' OR 
            (p_filter_type = 'clients' AND c.is_client = true) OR
            (p_filter_type = 'prospects' AND c.is_client = false)
        )
        AND (p_insurance_type IS NULL OR c.insurance_type = p_insurance_type)
    ORDER BY c.first_name, c.surname;
END;
$ LANGUAGE plpgsql;

-- Get Client
CREATE OR REPLACE FUNCTION sp_get_client(p_client_id UUID,
    p_agent_id UUID)
RETURNS TABLE (
    -- Client details
    client_id UUID,
    agent_id UUID,
    first_name VARCHAR(50),
    surname VARCHAR(50),
    last_name VARCHAR(50),
    phone_number VARCHAR(20),
    email VARCHAR(100),
    address VARCHAR(500),
    national_id VARCHAR(20),
    date_of_birth DATE,
    is_client BOOLEAN,
    insurance_type VARCHAR(50),
    notes TEXT,
    created_date TIMESTAMP,
    modified_date TIMESTAMP,
    is_active BOOLEAN,
    -- Policy details
    policy_id UUID,
    policy_name VARCHAR(255),
    policy_type VARCHAR(100),
    policy_company VARCHAR(255),
    policy_status VARCHAR(20),
    policy_start_date DATE,
    policy_end_date DATE,
    policy_notes TEXT
) AS $$
BEGIN
    -- Main client details with linked policy info
    RETURN QUERY
    SELECT 
        c.client_id,
        c.agent_id,
        c.first_name,
        c.surname,
        c.last_name,
        c.phone_number,
        c.email,
        c.address,
        c.national_id,
        c.date_of_birth,
        c.is_client,
        c.insurance_type,
        c.notes,
        c.created_date,
        c.modified_date,
        c.is_active,
        cp.policy_id,
        cp.policy_name,
        pt.type_name AS policy_type,
        ic.company_name AS policy_company,
        cp.status AS policy_status,
        cp.start_date AS policy_start_date,
        cp.end_date AS policy_end_date,
        cp.notes AS policy_notes
    FROM clients c
    LEFT JOIN client_policies cp 
        ON c.client_id = cp.client_id AND cp.is_active = true
    LEFT JOIN policy_catalog pc 
        ON cp.policy_catalog_id = pc.policy_catalog_id
    LEFT JOIN policy_types pt 
        ON pc.type_id = pt.type_id
    LEFT JOIN insurance_companies ic 
        ON pc.company_id = ic.company_id
    WHERE 
        c.client_id = p_client_id 
        AND c.agent_id = p_agent_id 
        AND c.is_active = true;
END;
$ LANGUAGE plpgsql;

-- Get Client Appointments (separate function since PostgreSQL functions can only return one result set)
CREATE OR REPLACE FUNCTION sp_get_client_appointments(p_client_id UUID,
    p_agent_id UUID)
RETURNS TABLE (
    appointment_id UUID,
    title VARCHAR(255),
    appointment_date DATE,
    start_time TIME,
    end_time TIME,
    type VARCHAR(50),
    status VARCHAR(20),
    location VARCHAR(255)
) AS $
BEGIN
    -- Appointments for the client
    RETURN QUERY
    SELECT 
        a.appointment_id,
        a.title,
        a.appointment_date,
        a.start_time,
        a.end_time,
        a.type,
        a.status,
        a.location
    FROM appointments a
    WHERE 
        a.client_id = p_client_id 
        AND a.agent_id = p_agent_id 
        AND a.is_active = true
    ORDER BY a.appointment_date DESC, a.start_time DESC;
END;
$ LANGUAGE plpgsql;

-- Delete Client
CREATE OR REPLACE FUNCTION sp_delete_client(p_client_id UUID,
    p_agent_id UUID)
RETURNS TABLE (
    rows_affected INTEGER
) AS $
DECLARE
    v_client_name TEXT;
    v_rows_affected INTEGER;
BEGIN
    -- Get client name for logging
    SELECT first_name || ' ' || surname INTO v_client_name 
    FROM clients WHERE client_id = p_client_id;
    
    -- Soft delete - set is_active to false
    UPDATE clients 
    SET is_active = false, modified_date = NOW()
    WHERE client_id = p_client_id AND agent_id = p_agent_id;
    
    GET DIAGNOSTICS v_rows_affected = ROW_COUNT;
    
    -- Also soft delete related appointments
    UPDATE appointments 
    SET is_active = false, modified_date = NOW()
    WHERE client_id = p_client_id AND agent_id = p_agent_id;
    
    -- Log activity
    INSERT INTO activity_log (agent_id, activity_type, entity_type, entity_id, description)
    VALUES (p_agent_id, 'client_deleted', 'client', p_client_id, v_client_name || ' deleted');
    
    RETURN QUERY SELECT v_rows_affected;
END;
$ LANGUAGE plpgsql;
-- Get Upcoming Reminders
CREATE OR REPLACE FUNCTION sp_get_upcoming_reminders(p_agent_id UUID,
    p_days_ahead INTEGER DEFAULT 7)
RETURNS TABLE (
    reminder_id UUID,
    client_id UUID,
    reminder_type VARCHAR(50),
    title VARCHAR(255),
    description TEXT,
    reminder_date DATE,
    reminder_time TIME,
    client_name VARCHAR(255),
    priority VARCHAR(20),
    status VARCHAR(20),
    notes TEXT,
    client_phone VARCHAR(20)
) AS $
DECLARE
    v_end_date DATE := CURRENT_DATE + INTERVAL '1 day' * p_days_ahead;
BEGIN
    RETURN QUERY
    SELECT 
        r.reminder_id,
        r.client_id,
        r.reminder_type,
        r.title,
        r.description,
        r.reminder_date,
        r.reminder_time,
        r.client_name,
        r.priority,
        r.status,
        r.notes,
        c.phone_number AS client_phone
    FROM reminders r
    LEFT JOIN clients c ON r.client_id = c.client_id
    WHERE r.agent_id = p_agent_id 
        AND r.status = 'Active'
        AND r.reminder_date BETWEEN CURRENT_DATE AND v_end_date
    ORDER BY r.reminder_date, r.reminder_time;
END;
$ LANGUAGE plpgsql;

-- Get Client Statistics
CREATE OR REPLACE FUNCTION sp_get_client_statistics(p_agent_id UUID)
RETURNS TABLE (
    total_contacts BIGINT,
    total_clients BIGINT,
    total_prospects BIGINT,
    today_birthdays BIGINT
) AS $
 $
BEGIN
    RETURN QUERY
    SELECT 
        COUNT(*) AS total_contacts,
        COUNT(CASE WHEN is_client = true THEN 1 END) AS total_clients,
        COUNT(CASE WHEN is_client = false THEN 1 END) AS total_prospects,
        COUNT(CASE WHEN 
            EXTRACT(DAY FROM date_of_birth) = EXTRACT(DAY FROM CURRENT_DATE) 
            AND EXTRACT(MONTH FROM date_of_birth) = EXTRACT(MONTH FROM CURRENT_DATE) 
            THEN 1 END) AS  $$
today_birthdays
    FROM clients
    WHERE agent_id = p_agent_id AND is_active = true
$$ LANGUAGE plpgsql;
END;
$ LANGUAGE plpgsql;

-- Get Today's Birthdays
CREATE OR REPLACE FUNCTION sp_get_today_birthdays(p_agent_id UUID)
RETURNS TABLE (
    client_id UUID,
    first_name VARCHAR(50),
    surname VARCHAR(50),
    last_name VARCHAR(50),
    phone_number VARCHAR(20),
    email VARCHAR(100),
    insurance_type VARCHAR(50),
    date_of_birth DATE,
    age INTEGER
) AS $
BEGIN
    RETURN QUERY
    SELECT 
        c.client_id,
        c.first_name,
        c.surname,
        c.last_name,
        c.phone_number,
        c.email,
        c.insurance_type,
        c.date_of_birth,
        EXTRACT(YEAR FROM AGE(CURRENT_DATE, c.date_of_birth))::INTEGER AS  $$
age
    FROM clients c
    WHERE 
        c.agent_id = p_agent_id 
        AND c.is_active = true
        AND EXTRACT(DAY FROM c.date_of_birth) = EXTRACT(DAY FROM CURRENT_DATE)
        AND EXTRACT(MONTH FROM c.date_of_birth) = EXTRACT(MONTH FROM CURRENT_DATE)
    ORDER BY c.first_name, c.surname
$$ LANGUAGE plpgsql;
END;
$ LANGUAGE plpgsql;

-- Get All Clients with Advanced Filters
CREATE OR REPLACE FUNCTION sp_get_all_clients(p_agent_id UUID,
    p_search_term VARCHAR(100) DEFAULT NULL,
    p_insurance_type VARCHAR(50) DEFAULT NULL,
    p_is_client BOOLEAN DEFAULT NULL,
    p_page_number INTEGER DEFAULT 1,
    p_page_size INTEGER DEFAULT 50)
RETURNS TABLE (
    client_id UUID,
    first_name VARCHAR(50),
    surname VARCHAR(50),
    last_name VARCHAR(50),
    phone_number VARCHAR(20),
    email VARCHAR(100),
    address VARCHAR(500),
    national_id VARCHAR(20),
    date_of_birth DATE,
    age INTEGER,
    is_client BOOLEAN,
    insurance_type VARCHAR(50),
    notes TEXT,
    created_date TIMESTAMP,
    modified_date TIMESTAMP,
    policy_count BIGINT,
    next_expiry_date DATE
) AS  $$
$
DECLARE
    v_offset INTEGER := (p_page_number - 1) * p_page_size
$$ LANGUAGE plpgsql;
BEGIN
    RETURN QUERY
    SELECT 
        c.client_id,
        c.first_name,
        c.surname,
        c.last_name,
        c.phone_number,
        c.email,
        c.address,
        c.national_id,
        c.date_of_birth,
        EXTRACT(YEAR FROM AGE(CURRENT_DATE, c.date_of_birth))::INTEGER as age,
        c.is_client,
        c.insurance_type,
        c.notes,
        c.created_date,
        c.modified_date,
        COUNT(cp.policy_id) as policy_count,
        MAX(cp.end_date) as next_expiry_date
    FROM clients c
    LEFT JOIN client_policies cp ON c.client_id = cp.client_id AND cp.is_active = true
    WHERE 
        c.agent_id = p_agent_id 
        AND c.is_active = true
        AND (p_search_term IS NULL OR 
             c.first_name ILIKE '%' || p_search_term || '%' OR 
             c.surname ILIKE '%' || p_search_term || '%' OR
             c.last_name ILIKE '%' || p_search_term || '%' OR
             c.phone_number ILIKE '%' || p_search_term || '%' OR
             c.email ILIKE '%' || p_search_term || '%')
        AND (p_insurance_type IS NULL OR c.insurance_type = p_insurance_type)
        AND (p_is_client IS NULL OR c.is_client = p_is_client)
    GROUP BY 
        c.client_id, c.first_name, c.surname, c.last_name, c.phone_number,
        c.email, c.address, c.national_id, c.date_of_birth, c.is_client,
        c.insurance_type, c.notes, c.created_date, c.modified_date
    ORDER BY c.created_date DESC
    LIMIT p_page_size OFFSET v_offset;
END;
$ LANGUAGE plpgsql;

-- Search Clients
CREATE OR REPLACE FUNCTION sp_search_clients(p_agent_id UUID,
    p_search_term VARCHAR(100))
RETURNS TABLE (
    client_id UUID,
    first_name VARCHAR(50),
    surname VARCHAR(50),
    last_name VARCHAR(50),
    phone_number VARCHAR(20),
    email VARCHAR(100),
    is_client BOOLEAN,
    insurance_type VARCHAR(50),
    age INTEGER
) AS $
BEGIN
    RETURN QUERY
    SELECT 
        c.client_id,
        c.first_name,
        c.surname,
        c.last_name,
        c.phone_number,
        c.email,
        c.is_client,
        c.insurance_type,
        EXTRACT(YEAR FROM AGE(CURRENT_DATE, c.date_of_birth))::INTEGER as  $$
age
    FROM clients c
    WHERE 
        c.agent_id = p_agent_id 
        AND c.is_active = true
        AND (
            c.first_name ILIKE '%' || p_search_term || '%' OR 
            c.surname ILIKE '%' || p_search_term || '%' OR
            c.last_name ILIKE '%' || p_search_term || '%' OR
            c.phone_number ILIKE '%' || p_search_term || '%' OR
            c.email ILIKE '%' || p_search_term || '%' OR
            c.national_id ILIKE '%' || p_search_term || '%'
        )
    ORDER BY c.first_name, c.surname
$$ LANGUAGE plpgsql;
END;
$ LANGUAGE plpgsql;

-- Get Clients by Insurance Type
CREATE OR REPLACE FUNCTION sp_get_clients_by_insurance_type(p_agent_id UUID,
    p_insurance_type VARCHAR(50))
RETURNS TABLE (
    client_id UUID,
    first_name VARCHAR(50),
    surname VARCHAR(50),
    last_name VARCHAR(50),
    phone_number VARCHAR(20),
    email VARCHAR(100),
    address VARCHAR(500),
    date_of_birth DATE,
    age INTEGER,
    is_client BOOLEAN,
    insurance_type VARCHAR(50),
    created_date TIMESTAMP,
    policy_count BIGINT
) AS $
BEGIN
    RETURN QUERY
    SELECT 
        c.client_id,
        c.first_name,
        c.surname,
        c.last_name,
        c.phone_number,
        c.email,
        c.address,
        c.date_of_birth,
        EXTRACT(YEAR FROM AGE(CURRENT_DATE, c.date_of_birth))::INTEGER as age,
        c.is_client,
        c.insurance_type,
        c.created_date,
        COUNT(cp.policy_id) as  $$
policy_count
    FROM clients c
    LEFT JOIN client_policies cp ON c.client_id = cp.client_id AND cp.is_active = true
    WHERE 
        c.agent_id = p_agent_id 
        AND c.is_active = true
        AND c.insurance_type = p_insurance_type
    GROUP BY 
        c.client_id, c.first_name, c.surname, c.last_name, c.phone_number,
        c.email, c.address, c.date_of_birth, c.is_client, c.insurance_type, c.created_date
    ORDER BY c.first_name, c.surname
$$ LANGUAGE plpgsql;
END;
$ LANGUAGE plpgsql;

-- Get Client with Full Details (main client info)
CREATE OR REPLACE FUNCTION sp_get_client_with_policies(p_client_id UUID,
    p_agent_id UUID)
RETURNS TABLE (
    client_id UUID,
    first_name VARCHAR(50),
    surname VARCHAR(50),
    last_name VARCHAR(50),
    phone_number VARCHAR(20),
    email VARCHAR(100),
    address VARCHAR(500),
    national_id VARCHAR(20),
    date_of_birth DATE,
    age INTEGER,
    is_client BOOLEAN,
    insurance_type VARCHAR(50),
    notes TEXT,
    created_date TIMESTAMP,
    modified_date TIMESTAMP
) AS $
BEGIN
    -- Client details
    RETURN QUERY
    SELECT 
        c.client_id,
        c.first_name,
        c.surname,
        c.last_name,
        c.phone_number,
        c.email,
        c.address,
        c.national_id,
        c.date_of_birth,
        EXTRACT(YEAR FROM AGE(CURRENT_DATE, c.date_of_birth))::INTEGER as  $$
age,
        c.is_client,
        c.insurance_type,
        c.notes,
        c.created_date,
        c.modified_date
    FROM clients c
    WHERE c.client_id = p_client_id AND c.agent_id = p_agent_id AND c.is_active = true
$$ LANGUAGE plpgsql;
END;
$ LANGUAGE plpgsql;

-- Get Client Policies (separate function for client policies)
CREATE OR REPLACE FUNCTION sp_get_client_policies_details(p_client_id UUID)
RETURNS TABLE (
    policy_id UUID,
    policy_name VARCHAR(255),
    policy_type VARCHAR(100),
    company_name VARCHAR(255),
    status VARCHAR(20),
    start_date DATE,
    end_date DATE,
    days_to_expiry INTEGER,
    notes TEXT,
    created_date TIMESTAMP
) AS $
 $
BEGIN
    -- Client policies
    RETURN QUERY
    SELECT 
        cp.policy_id,
        cp.policy_name,
        cp.policy_type,
        cp.company_name,
        cp.status,
        cp.start_date,
        cp.end_date,
        (cp.end_date - CURRENT_DATE)::INTEGER as  $$
days_to_expiry,
        cp.notes,
        cp.created_date
    FROM client_policies cp
    WHERE cp.client_id = p_client_id AND cp.is_active = true
    ORDER BY cp.end_date DESC
$$ LANGUAGE plpgsql;
END;
$ LANGUAGE plpgsql;

-- Get Client Recent Appointments (separate function)
CREATE OR REPLACE FUNCTION sp_get_client_recent_appointments(p_client_id UUID)
RETURNS TABLE (
    appointment_id UUID,
    title VARCHAR(255),
    appointment_date DATE,
    start_time TIME,
    type VARCHAR(50),
    status VARCHAR(20)
) AS  $$
$
 $
BEGIN
    -- Recent appointments (limit 5)
    RETURN QUERY
    SELECT 
        a.appointment_id,
        a.title,
        a.appointment_date,
        a.start_time,
        a.type,
        a.status
    FROM appointments a
    WHERE a.client_id = p_client_id AND a.is_active = true
    ORDER BY a.appointment_date DESC, a.start_time DESC
    LIMIT 5
$$ LANGUAGE plpgsql;
END;
$ LANGUAGE plpgsql;

-- Get Client Active Reminders (separate function)
CREATE OR REPLACE FUNCTION sp_get_client_active_reminders(p_client_id UUID)
RETURNS TABLE (
    reminder_id UUID,
    title VARCHAR(255),
    reminder_date DATE,
    reminder_time TIME,
    reminder_type VARCHAR(50),
    priority VARCHAR(20),
    status VARCHAR(20)
) AS  $$
$
 $
BEGIN
    -- Active reminders
    RETURN QUERY
    SELECT 
        r.reminder_id,
        r.title,
        r.reminder_date,
        r.reminder_time,
        r.reminder_type,
        r.priority,
        r.status
    FROM reminders r
    WHERE r.client_id = p_client_id AND r.status = 'Active'
    ORDER BY r.reminder_date, r.reminder_time
$$ LANGUAGE plpgsql;
END;
$ LANGUAGE plpgsql;

-- Create New Client
CREATE OR REPLACE FUNCTION sp_create_client(p_agent_id UUID,
    p_first_name VARCHAR(50),
    p_surname VARCHAR(50),
    p_last_name VARCHAR(50),
    p_phone_number VARCHAR(20),
    p_email VARCHAR(100),
    p_address VARCHAR(500),
    p_national_id VARCHAR(20),
    p_date_of_birth DATE,
    p_insurance_type VARCHAR(50),
    p_is_client BOOLEAN DEFAULT false,
    p_notes TEXT DEFAULT NULL)
RETURNS TABLE (
    success INTEGER,
    message TEXT,
    client_id UUID
) AS  $$
$
DECLARE
    v_client_id UUID := gen_random_uuid()
$$ LANGUAGE plpgsql;
    v_client_type TEXT := CASE WHEN p_is_client THEN 'client' ELSE 'prospect' END;
BEGIN
    -- Check for duplicate phone or email
    IF EXISTS(SELECT 1 FROM clients WHERE phone_number = p_phone_number AND agent_id = p_agent_id AND is_active = true) THEN
        RETURN QUERY SELECT 
            0 as success,
            'Phone number already exists'::TEXT as message,
            NULL::UUID as client_id;
        RETURN;
    END IF;
    
    IF EXISTS(SELECT 1 FROM clients WHERE email = p_email AND agent_id = p_agent_id AND is_active = true) THEN
        RETURN QUERY SELECT 
            0 as success,
            'Email already exists'::TEXT as message,
            NULL::UUID as client_id;
        RETURN;
    END IF;
    
    BEGIN
        INSERT INTO clients (
            client_id, agent_id, first_name, surname, last_name, phone_number,
            email, address, national_id, date_of_birth, is_client, insurance_type, notes
        )
        VALUES (
            v_client_id, p_agent_id, p_first_name, p_surname, p_last_name, p_phone_number,
            p_email, p_address, p_national_id, p_date_of_birth, p_is_client, p_insurance_type, p_notes
        );
        
        -- Log activity
        INSERT INTO activity_log (agent_id, activity_type, entity_type, entity_id, description)
        VALUES (
            p_agent_id, 
            CASE WHEN p_is_client THEN 'client_added' ELSE 'prospect_added' END,
            'client', 
            v_client_id, 
            'Added new ' || v_client_type || ': ' || p_first_name || ' ' || p_surname
        );
        
        RETURN QUERY SELECT 
            1 as success,
            CASE WHEN p_is_client THEN 'Client created successfully' ELSE 'Prospect created successfully' END::TEXT as message,
            v_client_id as client_id;
            
    EXCEPTION WHEN OTHERS THEN
        RETURN QUERY SELECT 
            0 as success,
            SQLERRM::TEXT as message,
            NULL::UUID as client_id;
    END;
END;
$ LANGUAGE plpgsql;

-- Get Completed Reminders
CREATE OR REPLACE FUNCTION sp_get_completed_reminders(p_agent_id UUID,
    p_start_date DATE DEFAULT NULL,
    p_end_date DATE DEFAULT NULL)
RETURNS TABLE (
    reminder_id UUID,
    client_id UUID,
    reminder_type VARCHAR(50),
    title VARCHAR(255),
    description TEXT,
    reminder_date DATE,
    reminder_time TIME,
    client_name VARCHAR(255),
    priority VARCHAR(20),
    status VARCHAR(20),
    completed_date TIMESTAMP,
    notes TEXT,
    client_phone VARCHAR(20)
) AS $
DECLARE
    v_start_date DATE := COALESCE(p_start_date, CURRENT_DATE - INTERVAL '30 days');
    v_end_date DATE := COALESCE(p_end_date, CURRENT_DATE);
BEGIN
    RETURN QUERY
    SELECT 
        r.reminder_id,
        r.client_id,
        r.reminder_type,
        r.title,
        r.description,
        r.reminder_date,
        r.reminder_time,
        r.client_name,
        r.priority,
        r.status,
        r.completed_date,
        r.notes,
        c.phone_number AS client_phone
    FROM reminders r
    LEFT JOIN clients c ON r.client_id = c.client_id
    WHERE r.agent_id = p_agent_id 
        AND r.status = 'Completed'
        AND r.completed_date BETWEEN v_start_date AND (v_end_date + INTERVAL '1 day')
    ORDER BY r.completed_date DESC;
END;
$ LANGUAGE plpgsql;

-- Update Reminder Setting
CREATE OR REPLACE FUNCTION sp_update_reminder_setting(p_agent_id UUID,
    p_reminder_type VARCHAR(50),
    p_is_enabled BOOLEAN DEFAULT NULL,
    p_days_before INTEGER DEFAULT NULL,
    p_time_of_day TIME DEFAULT NULL,
    p_repeat_daily BOOLEAN DEFAULT NULL)
RETURNS TABLE (
    success INTEGER,
    message TEXT
) AS $$
BEGIN
    IF EXISTS (SELECT 1 FROM reminder_settings WHERE agent_id = p_agent_id AND reminder_type = p_reminder_type) THEN
        UPDATE reminder_settings 
        SET 
            is_enabled = COALESCE(p_is_enabled, is_enabled),
            days_before = COALESCE(p_days_before, days_before),
            time_of_day = COALESCE(p_time_of_day, time_of_day),
            repeat_daily = COALESCE(p_repeat_daily, repeat_daily),
            modified_date = NOW()
        WHERE agent_id = p_agent_id AND reminder_type = p_reminder_type;
    ELSE
        INSERT INTO reminder_settings (
            agent_id, reminder_type, is_enabled, days_before, time_of_day, repeat_daily
        )
        VALUES (
            p_agent_id, p_reminder_type, COALESCE(p_is_enabled, true), 
            COALESCE(p_days_before, 1), COALESCE(p_time_of_day, '09:00'::TIME), 
            COALESCE(p_repeat_daily, false)
        );
    END IF;
    
    RETURN QUERY SELECT 1 AS success, 'Reminder setting updated successfully'::TEXT AS message;
END;
$ LANGUAGE plpgsql;

-- Create or Update Client
CREATE OR REPLACE FUNCTION sp_upsert_client(p_agent_id UUID,
    p_first_name VARCHAR(50),
    p_surname VARCHAR(50),
    p_last_name VARCHAR(50),
    p_phone_number VARCHAR(20),
    p_email VARCHAR(100),
    p_address VARCHAR(500),
    p_national_id VARCHAR(20),
    p_date_of_birth DATE,
    p_is_client BOOLEAN,
    p_client_id UUID DEFAULT NULL,
    p_notes TEXT DEFAULT NULL)
RETURNS TABLE (
    client_id UUID
) AS $$
DECLARE
    v_client_id UUID := COALESCE(p_client_id, gen_random_uuid());
    v_client_name TEXT := p_first_name || ' ' || p_surname;
BEGIN
    IF p_client_id IS NULL THEN
        -- Create new client
        INSERT INTO clients (
            client_id, agent_id, first_name, surname, last_name, phone_number, 
            email, address, national_id, date_of_birth, is_client, notes
        )
        VALUES (
            v_client_id, p_agent_id, p_first_name, p_surname, p_last_name, p_phone_number,
            p_email, p_address, p_national_id, p_date_of_birth, p_is_client, p_notes
        );
        
        -- Log activity
        INSERT INTO activity_log (agent_id, activity_type, entity_type, entity_id, description)
        VALUES (p_agent_id, 'client_created', 'client', v_client_id, 
                v_client_name || ' added as ' || CASE WHEN p_is_client THEN 'client' ELSE 'prospect' END);
    ELSE
        -- Update existing client
        v_client_id := p_client_id;
        
        UPDATE clients 
        SET 
            first_name = p_first_name,
            surname = p_surname,
            last_name = p_last_name,
            phone_number = p_phone_number,
            email = p_email,
            address = p_address,
            national_id = p_national_id,
            date_of_birth = p_date_of_birth,
            is_client = p_is_client,
            notes = p_notes,
            modified_date = NOW()
        WHERE clients.client_id = p_client_id;
        
        -- Log activity
        INSERT INTO activity_log (agent_id, activity_type, entity_type, entity_id, description)
        VALUES (p_agent_id, 'client_updated', 'client', v_client_id, v_client_name || ' updated');
    END IF;
    
    RETURN QUERY SELECT v_client_id;
END;
$ LANGUAGE plpgsql;

-- Get Clients
CREATE OR REPLACE FUNCTION sp_get_clients(p_agent_id UUID,
    p_search_term VARCHAR(100) DEFAULT NULL,
    p_filter_type VARCHAR(20) DEFAULT 'all',
    p_insurance_type VARCHAR(50) DEFAULT NULL)
RETURNS TABLE (
    client_id UUID,
    first_name VARCHAR(50),
    surname VARCHAR(50),
    last_name VARCHAR(50),
    phone_number VARCHAR(20),
    email VARCHAR(100),
    address VARCHAR(500),
    national_id VARCHAR(20),
    date_of_birth DATE,
    is_client BOOLEAN,
    insurance_type VARCHAR(50),
    notes TEXT,
    created_date TIMESTAMP,
    modified_date TIMESTAMP,
    policy_id UUID,
    policy_name VARCHAR(255),
    policy_type VARCHAR(100),
    policy_company VARCHAR(255),
    policy_status VARCHAR(20),
    policy_start_date DATE,
    policy_end_date DATE,
    policy_notes TEXT
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        c.client_id,
        c.first_name,
        c.surname,
        c.last_name,
        c.phone_number,
        c.email,
        c.address,
        c.national_id,
        c.date_of_birth,
        c.is_client,
        c.insurance_type,
        c.notes,
        c.created_date,
        c.modified_date,

        -- Policy Info from related tables
        cp.policy_id,
        cp.policy_name,
        pt.type_name AS policy_type,
        ic.company_name AS policy_company,
        cp.status AS policy_status,
        cp.start_date AS policy_start_date,
        cp.end_date AS policy_end_date,
        cp.notes AS policy_notes
    FROM clients c
    LEFT JOIN client_policies cp 
        ON c.client_id = cp.client_id AND cp.is_active = true
    LEFT JOIN policy_catalog pc
        ON cp.policy_catalog_id = pc.policy_catalog_id
    LEFT JOIN policy_types pt
        ON pc.type_id = pt.type_id
    LEFT JOIN insurance_companies ic
        ON pc.company_id = ic.company_id
    WHERE 
        c.agent_id = p_agent_id 
        AND c.is_active = true
        AND (
            p_search_term IS NULL OR 
            c.first_name ILIKE '%' || p_search_term || '%' OR
            c.surname ILIKE '%' || p_search_term || '%' OR
            c.last_name ILIKE '%' || p_search_term || '%' OR
            c.phone_number ILIKE '%' || p_search_term || '%' OR
            c.email ILIKE '%' || p_search_term || '%'
        )
        AND (
            p_filter_type = 'all' OR 
            (p_filter_type = 'clients' AND c.is_client = true) OR
            (p_filter_type = 'prospects' AND c.is_client = false)
        )
        AND (p_insurance_type IS NULL OR c.insurance_type = p_insurance_type)
    ORDER BY c.first_name, c.surname;
END;
$ LANGUAGE plpgsql;

-- Get Client
CREATE OR REPLACE FUNCTION sp_get_client(p_client_id UUID,
    p_agent_id UUID)
RETURNS TABLE (
    -- Client details
    client_id UUID,
    agent_id UUID,
    first_name VARCHAR(50),
    surname VARCHAR(50),
    last_name VARCHAR(50),
    phone_number VARCHAR(20),
    email VARCHAR(100),
    address VARCHAR(500),
    national_id VARCHAR(20),
    date_of_birth DATE,
    is_client BOOLEAN,
    insurance_type VARCHAR(50),
    notes TEXT,
    created_date TIMESTAMP,
    modified_date TIMESTAMP,
    is_active BOOLEAN,
    -- Policy details
    policy_id UUID,
    policy_name VARCHAR(255),
    policy_type VARCHAR(100),
    policy_company VARCHAR(255),
    policy_status VARCHAR(20),
    policy_start_date DATE,
    policy_end_date DATE,
    policy_notes TEXT
) AS $$
BEGIN
    -- Main client details with linked policy info
    RETURN QUERY
    SELECT 
        c.client_id,
        c.agent_id,
        c.first_name,
        c.surname,
        c.last_name,
        c.phone_number,
        c.email,
        c.address,
        c.national_id,
        c.date_of_birth,
        c.is_client,
        c.insurance_type,
        c.notes,
        c.created_date,
        c.modified_date,
        c.is_active,
        cp.policy_id,
        cp.policy_name,
        pt.type_name AS policy_type,
        ic.company_name AS policy_company,
        cp.status AS policy_status,
        cp.start_date AS policy_start_date,
        cp.end_date AS policy_end_date,
        cp.notes AS policy_notes
    FROM clients c
    LEFT JOIN client_policies cp 
        ON c.client_id = cp.client_id AND cp.is_active = true
    LEFT JOIN policy_catalog pc 
        ON cp.policy_catalog_id = pc.policy_catalog_id
    LEFT JOIN policy_types pt 
        ON pc.type_id = pt.type_id
    LEFT JOIN insurance_companies ic 
        ON pc.company_id = ic.company_id
    WHERE 
        c.client_id = p_client_id 
        AND c.agent_id = p_agent_id 
        AND c.is_active = true;
END;
$ LANGUAGE plpgsql;

-- Get Client Appointments (separate function since PostgreSQL functions can only return one result set)
CREATE OR REPLACE FUNCTION sp_get_client_appointments(p_client_id UUID,
    p_agent_id UUID)
RETURNS TABLE (
    appointment_id UUID,
    title VARCHAR(255),
    appointment_date DATE,
    start_time TIME,
    end_time TIME,
    type VARCHAR(50),
    status VARCHAR(20),
    location VARCHAR(255)
) AS $
BEGIN
    -- Appointments for the client
    RETURN QUERY
    SELECT 
        a.appointment_id,
        a.title,
        a.appointment_date,
        a.start_time,
        a.end_time,
        a.type,
        a.status,
        a.location
    FROM appointments a
    WHERE 
        a.client_id = p_client_id 
        AND a.agent_id = p_agent_id 
        AND a.is_active = true
    ORDER BY a.appointment_date DESC, a.start_time DESC;
END;
$ LANGUAGE plpgsql;

-- Delete Client
CREATE OR REPLACE FUNCTION sp_delete_client(p_client_id UUID,
    p_agent_id UUID)
RETURNS TABLE (
    rows_affected INTEGER
) AS $
DECLARE
    v_client_name TEXT;
    v_rows_affected INTEGER;
BEGIN
    -- Get client name for logging
    SELECT first_name || ' ' || surname INTO v_client_name 
    FROM clients WHERE client_id = p_client_id;
    
    -- Soft delete - set is_active to false
    UPDATE clients 
    SET is_active = false, modified_date = NOW()
    WHERE client_id = p_client_id AND agent_id = p_agent_id;
    
    GET DIAGNOSTICS v_rows_affected = ROW_COUNT;
    
    -- Also soft delete related appointments
    UPDATE appointments 
    SET is_active = false, modified_date = NOW()
    WHERE client_id = p_client_id AND agent_id = p_agent_id;
    
    -- Log activity
    INSERT INTO activity_log (agent_id, activity_type, entity_type, entity_id, description)
    VALUES (p_agent_id, 'client_deleted', 'client', p_client_id, v_client_name || ' deleted');
    
    RETURN QUERY SELECT v_rows_affected;
END;
$ LANGUAGE plpgsql;

-- Get Upcoming Reminders
CREATE OR REPLACE FUNCTION sp_get_upcoming_reminders(p_agent_id UUID,
    p_days_ahead INTEGER DEFAULT 7)
RETURNS TABLE (
    reminder_id UUID,
    client_id UUID,
    reminder_type VARCHAR(50),
    title VARCHAR(255),
    description TEXT,
    reminder_date DATE,
    reminder_time TIME,
    client_name VARCHAR(255),
    priority VARCHAR(20),
    status VARCHAR(20),
    notes TEXT,
    client_phone VARCHAR(20)
) AS $
DECLARE
    v_end_date DATE := CURRENT_DATE + INTERVAL '1 day' * p_days_ahead;
BEGIN
    RETURN QUERY
    SELECT 
        r.reminder_id,
        r.client_id,
        r.reminder_type,
        r.title,
        r.description,
        r.reminder_date,
        r.reminder_time,
        r.client_name,
        r.priority,
        r.status,
        r.notes,
        c.phone_number AS client_phone
    FROM reminders r
    LEFT JOIN clients c ON r.client_id = c.client_id
    WHERE r.agent_id = p_agent_id 
        AND r.status = 'Active'
        AND r.reminder_date BETWEEN CURRENT_DATE AND v_end_date
    ORDER BY r.reminder_date, r.reminder_time;
END;
$ LANGUAGE plpgsql;

-- Get Client Statistics
CREATE OR REPLACE FUNCTION sp_get_client_statistics(p_agent_id UUID)
RETURNS TABLE (
    total_contacts BIGINT,
    total_clients BIGINT,
    total_prospects BIGINT,
    today_birthdays BIGINT
) AS $
 $
BEGIN
    RETURN QUERY
    SELECT 
        COUNT(*) AS total_contacts,
        COUNT(CASE WHEN is_client = true THEN 1 END) AS total_clients,
        COUNT(CASE WHEN is_client = false THEN 1 END) AS total_prospects,
        COUNT(CASE WHEN 
            EXTRACT(DAY FROM date_of_birth) = EXTRACT(DAY FROM CURRENT_DATE) 
            AND EXTRACT(MONTH FROM date_of_birth) = EXTRACT(MONTH FROM CURRENT_DATE) 
            THEN 1 END) AS  $$
today_birthdays
    FROM clients
    WHERE agent_id = p_agent_id AND is_active = true
$$ LANGUAGE plpgsql;
END;
$ LANGUAGE plpgsql;

-- Get Today's Birthdays
CREATE OR REPLACE FUNCTION sp_get_today_birthdays(p_agent_id UUID)
RETURNS TABLE (
    client_id UUID,
    first_name VARCHAR(50),
    surname VARCHAR(50),
    last_name VARCHAR(50),
    phone_number VARCHAR(20),
    email VARCHAR(100),
    insurance_type VARCHAR(50),
    date_of_birth DATE,
    age INTEGER
) AS $
BEGIN
    RETURN QUERY
    SELECT 
        c.client_id,
        c.first_name,
        c.surname,
        c.last_name,
        c.phone_number,
        c.email,
        c.insurance_type,
        c.date_of_birth,
        EXTRACT(YEAR FROM AGE(CURRENT_DATE, c.date_of_birth))::INTEGER AS  $$
age
    FROM clients c
    WHERE 
        c.agent_id = p_agent_id 
        AND c.is_active = true
        AND EXTRACT(DAY FROM c.date_of_birth) = EXTRACT(DAY FROM CURRENT_DATE)
        AND EXTRACT(MONTH FROM c.date_of_birth) = EXTRACT(MONTH FROM CURRENT_DATE)
    ORDER BY c.first_name, c.surname
$$ LANGUAGE plpgsql;
END;
$ LANGUAGE plpgsql;

-- Get All Clients with Advanced Filters
CREATE OR REPLACE FUNCTION sp_get_all_clients(p_agent_id UUID,
    p_search_term VARCHAR(100) DEFAULT NULL,
    p_insurance_type VARCHAR(50) DEFAULT NULL,
    p_is_client BOOLEAN DEFAULT NULL,
    p_page_number INTEGER DEFAULT 1,
    p_page_size INTEGER DEFAULT 50)
RETURNS TABLE (
    client_id UUID,
    first_name VARCHAR(50),
    surname VARCHAR(50),
    last_name VARCHAR(50),
    phone_number VARCHAR(20),
    email VARCHAR(100),
    address VARCHAR(500),
    national_id VARCHAR(20),
    date_of_birth DATE,
    age INTEGER,
    is_client BOOLEAN,
    insurance_type VARCHAR(50),
    notes TEXT,
    created_date TIMESTAMP,
    modified_date TIMESTAMP,
    policy_count BIGINT,
    next_expiry_date DATE
) AS  $$
$
DECLARE
    v_offset INTEGER := (p_page_number - 1) * p_page_size
$$ LANGUAGE plpgsql;
BEGIN
    RETURN QUERY
    SELECT 
        c.client_id,
        c.first_name,
        c.surname,
        c.last_name,
        c.phone_number,
        c.email,
        c.address,
        c.national_id,
        c.date_of_birth,
        EXTRACT(YEAR FROM AGE(CURRENT_DATE, c.date_of_birth))::INTEGER as age,
        c.is_client,
        c.insurance_type,
        c.notes,
        c.created_date,
        c.modified_date,
        COUNT(cp.policy_id) as policy_count,
        MAX(cp.end_date) as next_expiry_date
    FROM clients c
    LEFT JOIN client_policies cp ON c.client_id = cp.client_id AND cp.is_active = true
    WHERE 
        c.agent_id = p_agent_id 
        AND c.is_active = true
        AND (p_search_term IS NULL OR 
             c.first_name ILIKE '%' || p_search_term || '%' OR 
             c.surname ILIKE '%' || p_search_term || '%' OR
             c.last_name ILIKE '%' || p_search_term || '%' OR
             c.phone_number ILIKE '%' || p_search_term || '%' OR
             c.email ILIKE '%' || p_search_term || '%')
        AND (p_insurance_type IS NULL OR c.insurance_type = p_insurance_type)
        AND (p_is_client IS NULL OR c.is_client = p_is_client)
    GROUP BY 
        c.client_id, c.first_name, c.surname, c.last_name, c.phone_number,
        c.email, c.address, c.national_id, c.date_of_birth, c.is_client,
        c.insurance_type, c.notes, c.created_date, c.modified_date
    ORDER BY c.created_date DESC
    LIMIT p_page_size OFFSET v_offset;
END;
$ LANGUAGE plpgsql;

-- Search Clients
CREATE OR REPLACE FUNCTION sp_search_clients(p_agent_id UUID,
    p_search_term VARCHAR(100))
RETURNS TABLE (
    client_id UUID,
    first_name VARCHAR(50),
    surname VARCHAR(50),
    last_name VARCHAR(50),
    phone_number VARCHAR(20),
    email VARCHAR(100),
    is_client BOOLEAN,
    insurance_type VARCHAR(50),
    age INTEGER
) AS $
BEGIN
    RETURN QUERY
    SELECT 
        c.client_id,
        c.first_name,
        c.surname,
        c.last_name,
        c.phone_number,
        c.email,
        c.is_client,
        c.insurance_type,
        EXTRACT(YEAR FROM AGE(CURRENT_DATE, c.date_of_birth))::INTEGER as  $$
age
    FROM clients c
    WHERE 
        c.agent_id = p_agent_id 
        AND c.is_active = true
        AND (
            c.first_name ILIKE '%' || p_search_term || '%' OR 
            c.surname ILIKE '%' || p_search_term || '%' OR
            c.last_name ILIKE '%' || p_search_term || '%' OR
            c.phone_number ILIKE '%' || p_search_term || '%' OR
            c.email ILIKE '%' || p_search_term || '%' OR
            c.national_id ILIKE '%' || p_search_term || '%'
        )
    ORDER BY c.first_name, c.surname
$$ LANGUAGE plpgsql;
END;
$ LANGUAGE plpgsql;

-- Get Clients by Insurance Type
CREATE OR REPLACE FUNCTION sp_get_clients_by_insurance_type(p_agent_id UUID,
    p_insurance_type VARCHAR(50))
RETURNS TABLE (
    client_id UUID,
    first_name VARCHAR(50),
    surname VARCHAR(50),
    last_name VARCHAR(50),
    phone_number VARCHAR(20),
    email VARCHAR(100),
    address VARCHAR(500),
    date_of_birth DATE,
    age INTEGER,
    is_client BOOLEAN,
    insurance_type VARCHAR(50),
    created_date TIMESTAMP,
    policy_count BIGINT
) AS $
BEGIN
    RETURN QUERY
    SELECT 
        c.client_id,
        c.first_name,
        c.surname,
        c.last_name,
        c.phone_number,
        c.email,
        c.address,
        c.date_of_birth,
        EXTRACT(YEAR FROM AGE(CURRENT_DATE, c.date_of_birth))::INTEGER as age,
        c.is_client,
        c.insurance_type,
        c.created_date,
        COUNT(cp.policy_id) as  $$
policy_count
    FROM clients c
    LEFT JOIN client_policies cp ON c.client_id = cp.client_id AND cp.is_active = true
    WHERE 
        c.agent_id = p_agent_id 
        AND c.is_active = true
        AND c.insurance_type = p_insurance_type
    GROUP BY 
        c.client_id, c.first_name, c.surname, c.last_name, c.phone_number,
        c.email, c.address, c.date_of_birth, c.is_client, c.insurance_type, c.created_date
    ORDER BY c.first_name, c.surname
$$ LANGUAGE plpgsql;
END;
$ LANGUAGE plpgsql;

-- Get Client with Full Details (main client info)
CREATE OR REPLACE FUNCTION sp_get_client_with_policies(p_client_id UUID,
    p_agent_id UUID)
RETURNS TABLE (
    client_id UUID,
    first_name VARCHAR(50),
    surname VARCHAR(50),
    last_name VARCHAR(50),
    phone_number VARCHAR(20),
    email VARCHAR(100),
    address VARCHAR(500),
    national_id VARCHAR(20),
    date_of_birth DATE,
    age INTEGER,
    is_client BOOLEAN,
    insurance_type VARCHAR(50),
    notes TEXT,
    created_date TIMESTAMP,
    modified_date TIMESTAMP
) AS $
BEGIN
    -- Client details
    RETURN QUERY
    SELECT 
        c.client_id,
        c.first_name,
        c.surname,
        c.last_name,
        c.phone_number,
        c.email,
        c.address,
        c.national_id,
        c.date_of_birth,
        EXTRACT(YEAR FROM AGE(CURRENT_DATE, c.date_of_birth))::INTEGER as  $$
age,
        c.is_client,
        c.insurance_type,
        c.notes,
        c.created_date,
        c.modified_date
    FROM clients c
    WHERE c.client_id = p_client_id AND c.agent_id = p_agent_id AND c.is_active = true
$$ LANGUAGE plpgsql;
END;
$ LANGUAGE plpgsql;

-- Get Client Policies (separate function for client policies)
CREATE OR REPLACE FUNCTION sp_get_client_policies_details(p_client_id UUID)
RETURNS TABLE (
    policy_id UUID,
    policy_name VARCHAR(255),
    policy_type VARCHAR(100),
    company_name VARCHAR(255),
    status VARCHAR(20),
    start_date DATE,
    end_date DATE,
    days_to_expiry INTEGER,
    notes TEXT,
    created_date TIMESTAMP
) AS $
 $
BEGIN
    -- Client policies
    RETURN QUERY
    SELECT 
        cp.policy_id,
        cp.policy_name,
        cp.policy_type,
        cp.company_name,
        cp.status,
        cp.start_date,
        cp.end_date,
        (cp.end_date - CURRENT_DATE)::INTEGER as  $$
days_to_expiry,
        cp.notes,
        cp.created_date
    FROM client_policies cp
    WHERE cp.client_id = p_client_id AND cp.is_active = true
    ORDER BY cp.end_date DESC
$$ LANGUAGE plpgsql;
END;
$ LANGUAGE plpgsql;

-- Get Client Recent Appointments (separate function)
CREATE OR REPLACE FUNCTION sp_get_client_recent_appointments(p_client_id UUID)
RETURNS TABLE (
    appointment_id UUID,
    title VARCHAR(255),
    appointment_date DATE,
    start_time TIME,
    type VARCHAR(50),
    status VARCHAR(20)
) AS  $$
$
 $
BEGIN
    -- Recent appointments (limit 5)
    RETURN QUERY
    SELECT 
        a.appointment_id,
        a.title,
        a.appointment_date,
        a.start_time,
        a.type,
        a.status
    FROM appointments a
    WHERE a.client_id = p_client_id AND a.is_active = true
    ORDER BY a.appointment_date DESC, a.start_time DESC
    LIMIT 5
$$ LANGUAGE plpgsql;
END;
$ LANGUAGE plpgsql;

-- Get Client Active Reminders (separate function)
CREATE OR REPLACE FUNCTION sp_get_client_active_reminders(p_client_id UUID)
RETURNS TABLE (
    reminder_id UUID,
    title VARCHAR(255),
    reminder_date DATE,
    reminder_time TIME,
    reminder_type VARCHAR(50),
    priority VARCHAR(20),
    status VARCHAR(20)
) AS  $$
$
 $
BEGIN
    -- Active reminders
    RETURN QUERY
    SELECT 
        r.reminder_id,
        r.title,
        r.reminder_date,
        r.reminder_time,
        r.reminder_type,
        r.priority,
        r.status
    FROM reminders r
    WHERE r.client_id = p_client_id AND r.status = 'Active'
    ORDER BY r.reminder_date, r.reminder_time
$$ LANGUAGE plpgsql;
END;
$ LANGUAGE plpgsql;

-- Create New Client
CREATE OR REPLACE FUNCTION sp_create_client(p_agent_id UUID,
    p_first_name VARCHAR(50),
    p_surname VARCHAR(50),
    p_last_name VARCHAR(50),
    p_phone_number VARCHAR(20),
    p_email VARCHAR(100),
    p_address VARCHAR(500),
    p_national_id VARCHAR(20),
    p_date_of_birth DATE,
    p_insurance_type VARCHAR(50),
    p_is_client BOOLEAN DEFAULT false,
    p_notes TEXT DEFAULT NULL)
RETURNS TABLE (
    success INTEGER,
    message TEXT,
    client_id UUID
) AS  $$
$
DECLARE
    v_client_id UUID := gen_random_uuid()
$$ LANGUAGE plpgsql;
    v_client_type TEXT := CASE WHEN p_is_client THEN 'client' ELSE 'prospect' END;
BEGIN
    -- Check for duplicate phone or email
    IF EXISTS(SELECT 1 FROM clients WHERE phone_number = p_phone_number AND agent_id = p_agent_id AND is_active = true) THEN
        RETURN QUERY SELECT 
            0 as success,
            'Phone number already exists'::TEXT as message,
            NULL::UUID as client_id;
        RETURN;
    END IF;
    
    IF EXISTS(SELECT 1 FROM clients WHERE email = p_email AND agent_id = p_agent_id AND is_active = true) THEN
        RETURN QUERY SELECT 
            0 as success,
            'Email already exists'::TEXT as message,
            NULL::UUID as client_id;
        RETURN;
    END IF;
    
    BEGIN
        INSERT INTO clients (
            client_id, agent_id, first_name, surname, last_name, phone_number,
            email, address, national_id, date_of_birth, is_client, insurance_type, notes
        )
        VALUES (
            v_client_id, p_agent_id, p_first_name, p_surname, p_last_name, p_phone_number,
            p_email, p_address, p_national_id, p_date_of_birth, p_is_client, p_insurance_type, p_notes
        );
        
        -- Log activity
        INSERT INTO activity_log (agent_id, activity_type, entity_type, entity_id, description)
        VALUES (
            p_agent_id, 
            CASE WHEN p_is_client THEN 'client_added' ELSE 'prospect_added' END,
            'client', 
            v_client_id, 
            'Added new ' || v_client_type || ': ' || p_first_name || ' ' || p_surname
        );
        
        RETURN QUERY SELECT 
            1 as success,
            CASE WHEN p_is_client THEN 'Client created successfully' ELSE 'Prospect created successfully' END::TEXT as message,
            v_client_id as client_id;
            
    EXCEPTION WHEN OTHERS THEN
        RETURN QUERY SELECT 
            0 as success,
            SQLERRM::TEXT as message,
            NULL::UUID as client_id;
    END;
END;
$ LANGUAGE plpgsql;

-- Get Completed Reminders
CREATE OR REPLACE FUNCTION sp_get_completed_reminders(p_agent_id UUID,
    p_start_date DATE DEFAULT NULL,
    p_end_date DATE DEFAULT NULL)
RETURNS TABLE (
    reminder_id UUID,
    client_id UUID,
    reminder_type VARCHAR(50),
    title VARCHAR(255),
    description TEXT,
    reminder_date DATE,
    reminder_time TIME,
    client_name VARCHAR(255),
    priority VARCHAR(20),
    status VARCHAR(20),
    completed_date TIMESTAMP,
    notes TEXT,
    client_phone VARCHAR(20)
) AS $
DECLARE
    v_start_date DATE := COALESCE(p_start_date, CURRENT_DATE - INTERVAL '30 days');
    v_end_date DATE := COALESCE(p_end_date, CURRENT_DATE);
BEGIN
    RETURN QUERY
    SELECT 
        r.reminder_id,
        r.client_id,
        r.reminder_type,
        r.title,
        r.description,
        r.reminder_date,
        r.reminder_time,
        r.client_name,
        r.priority,
        r.status,
        r.completed_date,
        r.notes,
        c.phone_number AS client_phone
    FROM reminders r
    LEFT JOIN clients c ON r.client_id = c.client_id
    WHERE r.agent_id = p_agent_id 
        AND r.status = 'Completed'
        AND r.completed_date BETWEEN v_start_date AND (v_end_date + INTERVAL '1 day')
    ORDER BY r.completed_date DESC;
END;
$ LANGUAGE plpgsql;

-- Update Client
CREATE OR REPLACE FUNCTION sp_update_client(p_client_id UUID,
    p_agent_id UUID,
    p_first_name VARCHAR(50),
    p_surname VARCHAR(50),
    p_last_name VARCHAR(50),
    p_phone_number VARCHAR(20),
    p_email VARCHAR(100),
    p_address VARCHAR(500),
    p_national_id VARCHAR(20),
    p_date_of_birth DATE,
    p_insurance_type VARCHAR(50),
    p_notes TEXT DEFAULT NULL)
RETURNS TABLE (
    success INTEGER,
    message TEXT
) AS $
BEGIN
    -- Check if client exists and belongs to agent
    IF NOT EXISTS(SELECT 1 FROM clients WHERE client_id = p_client_id AND agent_id = p_agent_id AND is_active = true) THEN
        RETURN QUERY SELECT 
            0 as success,
            'Client not found'::TEXT as  $$
message
$$ LANGUAGE plpgsql;
        RETURN;
    END IF;
    
    -- Check for duplicate phone or email (excluding current client)
    IF EXISTS(SELECT 1 FROM clients WHERE phone_number = p_phone_number AND agent_id = p_agent_id AND client_id != p_client_id AND is_active = true) THEN
        RETURN QUERY SELECT 
            0 as success,
            'Phone number already exists for another client'::TEXT as message;
        RETURN;
    END IF;
    
    IF EXISTS(SELECT 1 FROM clients WHERE email = p_email AND agent_id = p_agent_id AND client_id != p_client_id AND is_active = true) THEN
        RETURN QUERY SELECT 
            0 as success,
            'Email already exists for another client'::TEXT as message;
        RETURN;
    END IF;
    
    BEGIN
        UPDATE clients 
        SET 
            first_name = p_first_name,
            surname = p_surname,
            last_name = p_last_name,
            phone_number = p_phone_number,
            email = p_email,
            address = p_address,
            national_id = p_national_id,
            date_of_birth = p_date_of_birth,
            insurance_type = p_insurance_type,
            notes = p_notes,
            modified_date = NOW()
        WHERE client_id = p_client_id AND agent_id = p_agent_id;
        
        -- Log activity
        INSERT INTO activity_log (agent_id, activity_type, entity_type, entity_id, description)
        VALUES (
            p_agent_id, 
            'client_updated',
            'client', 
            p_client_id, 
            'Updated client: ' || p_first_name || ' ' || p_surname
        );
        
        RETURN QUERY SELECT 
            1 as success,
            'Client updated successfully'::TEXT as message;
            
    EXCEPTION WHEN OTHERS THEN
        RETURN QUERY SELECT 
            0 as success,
            SQLERRM::TEXT as message;
    END;
END;
$ LANGUAGE plpgsql;

-- Get Enhanced Client Statistics
CREATE OR REPLACE FUNCTION sp_get_enhanced_client_statistics(p_agent_id UUID)
RETURNS TABLE (
    total_clients BIGINT,
    total_prospects BIGINT,
    total_contacts BIGINT,
    active_policies BIGINT,
    expiring_policies BIGINT,
    today_birthdays BIGINT,
    month_birthdays BIGINT,
    new_this_week BIGINT,
    new_this_month BIGINT,
    insurance_type_breakdown JSONB
) AS $
 $
BEGIN
    RETURN QUERY
    SELECT 
        -- Client counts
        COUNT(CASE WHEN is_client = true THEN 1 END) as total_clients,
        COUNT(CASE WHEN is_client = false THEN 1 END) as total_prospects,
        COUNT(*) as total_contacts,
        
        -- Policy statistics
        (SELECT COUNT(*) FROM client_policies cp 
         INNER JOIN clients c ON cp.client_id = c.client_id 
         WHERE c.agent_id = p_agent_id AND cp.is_active = true AND cp.status = 'Active') as active_policies,
        
        (SELECT COUNT(*) FROM client_policies cp 
         INNER JOIN clients c ON cp.client_id = c.client_id 
         WHERE c.agent_id = p_agent_id AND cp.is_active = true 
         AND cp.end_date BETWEEN CURRENT_DATE AND (CURRENT_DATE + INTERVAL '30 days')) as expiring_policies,
        
        -- Birthday statistics
        COUNT(CASE WHEN EXTRACT(MONTH FROM date_of_birth) = EXTRACT(MONTH FROM CURRENT_DATE) 
                   AND EXTRACT(DAY FROM date_of_birth) = EXTRACT(DAY FROM CURRENT_DATE) THEN 1 END) as today_birthdays,
        
        COUNT(CASE WHEN EXTRACT(MONTH FROM date_of_birth) = EXTRACT(MONTH FROM CURRENT_DATE) THEN 1 END) as month_birthdays,
        
        -- Recent additions
        COUNT(CASE WHEN created_date >= (CURRENT_DATE - INTERVAL '7 days') THEN 1 END) as new_this_week,
        COUNT(CASE WHEN created_date >= (CURRENT_DATE - INTERVAL '30 days') THEN 1 END) as new_this_month,
        
        -- Insurance type breakdown as JSON
        (SELECT jsonb_agg(
            jsonb_build_object(
                'insurance_type', insurance_type,
                'count', count,
                'client_count', client_count,
                'prospect_count', prospect_count
            )
        ) FROM (
            SELECT 
                insurance_type,
                COUNT(*) as count,
                COUNT(CASE WHEN is_client = true THEN 1 END) as client_count,
                COUNT(CASE WHEN is_client = false THEN 1 END) as prospect_count
            FROM clients 
            WHERE agent_id = p_agent_id AND is_active = true
            GROUP BY insurance_type
        ) breakdown) as  $$
insurance_type_breakdown
         
    FROM clients 
    WHERE agent_id = p_agent_id AND is_active = true
$$ LANGUAGE plpgsql;
END;
$ LANGUAGE plpgsql;

-- Get Policy Statistics
CREATE OR REPLACE FUNCTION sp_get_policy_statistics(p_agent_id UUID)
RETURNS TABLE (
    active_policies BIGINT,
    expired_policies BIGINT,
    lapsed_policies BIGINT,
    expiring_policies BIGINT,
    policy_types BIGINT,
    insurance_companies BIGINT
) AS $
 $
BEGIN
    RETURN QUERY
    SELECT 
        COUNT(CASE WHEN cp.status = 'Active' THEN 1 END) AS active_policies,
        COUNT(CASE WHEN cp.status = 'Expired' THEN 1 END) AS expired_policies,
        COUNT(CASE WHEN cp.status = 'Lapsed' THEN 1 END) AS lapsed_policies,
        COUNT(CASE WHEN cp.end_date BETWEEN CURRENT_DATE AND (CURRENT_DATE + INTERVAL '30 days') THEN 1 END) AS expiring_policies,
        COUNT(DISTINCT pt.type_id) AS policy_types,
        COUNT(DISTINCT ic.company_id) AS  $$
insurance_companies
    FROM client_policies cp
    INNER JOIN clients c ON cp.client_id = c.client_id
    LEFT JOIN policy_type pt ON cp.type_id = pt.type_id
    LEFT JOIN insurance_company ic ON cp.company_id = ic.company_id
    WHERE c.agent_id = p_agent_id AND cp.is_active = true AND c.is_active = true
$$ LANGUAGE plpgsql;
END;
$ LANGUAGE plpgsql;

-- Create Policy Template
CREATE OR REPLACE FUNCTION sp_create_policy_template(p_agent_id UUID,
    p_template_name VARCHAR(100),
    p_type_id UUID,
    p_default_term_months INTEGER DEFAULT NULL,
    p_default_premium DECIMAL(18,2) DEFAULT NULL,
    p_coverage_description TEXT DEFAULT NULL,
    p_terms TEXT DEFAULT NULL,
    p_category_id UUID DEFAULT NULL)
RETURNS TABLE (
    template_id UUID
) AS  $$
$
DECLARE
    v_template_id UUID := gen_random_uuid()
$$ LANGUAGE plpgsql;
BEGIN
    INSERT INTO policy_template (
        template_id, agent_id, template_name, type_id, category_id,
        default_term_months, default_premium, coverage_description, terms
    )
    VALUES (
        v_template_id, p_agent_id, p_template_name, p_type_id, p_category_id,
        p_default_term_months, p_default_premium, p_coverage_description, p_terms
    );
    
    INSERT INTO activity_log (agent_id, activity_type, entity_type, entity_id, description)
    VALUES (
        p_agent_id, 'policy_template_created', 'policy_template', v_template_id, 
        'Policy template "' || p_template_name || '" created'
    );

    RETURN QUERY SELECT v_template_id;
END;
$ LANGUAGE plpgsql;

-- Get Policy Templates
CREATE OR REPLACE FUNCTION sp_get_policy_templates(p_agent_id UUID,
    p_type_id UUID DEFAULT NULL)
RETURNS TABLE (
    template_id UUID,
    template_name VARCHAR(100),
    type_id UUID,
    type_name VARCHAR(100),
    default_term_months INTEGER,
    default_premium DECIMAL(18,2),
    coverage_description TEXT,
    terms TEXT,
    category_id UUID,
    category_name VARCHAR(100),
    created_date TIMESTAMP
) AS  $$
$
 $
BEGIN
    RETURN QUERY
    SELECT 
        pt.template_id,
        pt.template_name,
        pt.type_id,
        ptype.type_name,
        pt.default_term_months,
        pt.default_premium,
        pt.coverage_description,
        pt.terms,
        pt.category_id,
        pc.category_name,
        pt.created_date
    FROM policy_template pt
    LEFT JOIN policy_type ptype ON pt.type_id = ptype.type_id
    LEFT JOIN policy_category pc ON pt.category_id = pc.category_id
    WHERE 
        pt.agent_id = p_agent_id 
        AND pt.is_active = true
        AND (p_type_id IS NULL OR pt.type_id = p_type_id)
    ORDER BY ptype.type_name, pt.template_name
$$ LANGUAGE plpgsql;
END;
$ LANGUAGE plpgsql;

-- Delete Policy Template
CREATE OR REPLACE FUNCTION sp_delete_policy_template(p_template_id UUID,
    p_agent_id UUID)
RETURNS TABLE (
    rows_affected INTEGER
) AS  $$
$
 $
DECLARE
    v_rows_affected INTEGER
$$ LANGUAGE plpgsql;
BEGIN
    UPDATE policy_template 
    SET is_active = false
    WHERE template_id = p_template_id AND agent_id = p_agent_id;
    
    GET DIAGNOSTICS v_rows_affected = ROW_COUNT;
    
    IF v_rows_affected > 0 THEN
        INSERT INTO activity_log (agent_id, activity_type, entity_type, entity_id, description)
        VALUES (
            p_agent_id, 'policy_template_deleted', 'policy_template', p_template_id, 
            'Policy template deleted'
        );
    END IF;
    
    RETURN QUERY SELECT v_rows_affected;
END;
$ LANGUAGE plpgsql;

-- Get Policy Catalog for Agent
CREATE OR REPLACE FUNCTION sp_get_policy_catalog(p_agent_id UUID,
    p_type_id UUID DEFAULT NULL,
    p_company_id UUID DEFAULT NULL)
RETURNS TABLE (
    policy_catalog_id UUID,
    policy_name VARCHAR(255),
    type_id UUID,
    type_name VARCHAR(100),
    company_id UUID,
    company_name VARCHAR(255),
    category_id UUID,
    category_name VARCHAR(100),
    notes TEXT,
    created_date TIMESTAMP,
    modified_date TIMESTAMP
) AS  $$
$
 $
BEGIN
    RETURN QUERY
    SELECT 
        pc.policy_catalog_id,
        pc.policy_name,
        pc.type_id,
        pt.type_name,
        pc.company_id,
        ic.company_name,
        pc.category_id,
        pcat.category_name,
        pc.notes,
        pc.created_date,
        pc.modified_date
    FROM policy_catalog pc
    LEFT JOIN policy_type pt ON pc.type_id = pt.type_id
    LEFT JOIN insurance_company ic ON pc.company_id = ic.company_id
    LEFT JOIN policy_category pcat ON pc.category_id = pcat.category_id
    WHERE 
        pc.agent_id = p_agent_id 
        AND pc.is_active = true
        AND (p_type_id IS NULL OR pc.type_id = p_type_id)
        AND (p_company_id IS NULL OR pc.company_id = p_company_id)
    ORDER BY pt.type_name, pc.policy_name
$$ LANGUAGE plpgsql;
END;
$ LANGUAGE plpgsql;

-- Update Reminder Setting
CREATE OR REPLACE FUNCTION sp_update_reminder_setting(p_agent_id UUID,
    p_reminder_type VARCHAR(50),
    p_is_enabled BOOLEAN DEFAULT NULL,
    p_days_before INTEGER DEFAULT NULL,
    p_time_of_day TIME DEFAULT NULL,
    p_repeat_daily BOOLEAN DEFAULT NULL)
RETURNS TABLE (
    success INTEGER,
    message TEXT
) AS $$
BEGIN
    IF EXISTS (SELECT 1 FROM reminder_settings WHERE agent_id = p_agent_id AND reminder_type = p_reminder_type) THEN
        UPDATE reminder_settings 
        SET 
            is_enabled = COALESCE(p_is_enabled, is_enabled),
            days_before = COALESCE(p_days_before, days_before),
            time_of_day = COALESCE(p_time_of_day, time_of_day),
            repeat_daily = COALESCE(p_repeat_daily, repeat_daily),
            modified_date = NOW()
        WHERE agent_id = p_agent_id AND reminder_type = p_reminder_type;
    ELSE
        INSERT INTO reminder_settings (
            agent_id, reminder_type, is_enabled, days_before, time_of_day, repeat_daily
        )
        VALUES (
            p_agent_id, p_reminder_type, COALESCE(p_is_enabled, true), 
            COALESCE(p_days_before, 1), COALESCE(p_time_of_day, '09:00'::TIME), 
            COALESCE(p_repeat_daily, false)
        );
    END IF;
    
    RETURN QUERY SELECT 1 AS success, 'Reminder setting updated successfully'::TEXT AS message;
END;
$ LANGUAGE plpgsql;

-- Create or Update Client
CREATE OR REPLACE FUNCTION sp_upsert_client(p_agent_id UUID,
    p_first_name VARCHAR(50),
    p_surname VARCHAR(50),
    p_last_name VARCHAR(50),
    p_phone_number VARCHAR(20),
    p_email VARCHAR(100),
    p_address VARCHAR(500),
    p_national_id VARCHAR(20),
    p_date_of_birth DATE,
    p_is_client BOOLEAN,
    p_client_id UUID DEFAULT NULL,
    p_notes TEXT DEFAULT NULL)
RETURNS TABLE (
    client_id UUID
) AS $$
DECLARE
    v_client_id UUID := COALESCE(p_client_id, gen_random_uuid());
    v_client_name TEXT := p_first_name || ' ' || p_surname;
BEGIN
    IF p_client_id IS NULL THEN
        -- Create new client
        INSERT INTO clients (
            client_id, agent_id, first_name, surname, last_name, phone_number, 
            email, address, national_id, date_of_birth, is_client, notes
        )
        VALUES (
            v_client_id, p_agent_id, p_first_name, p_surname, p_last_name, p_phone_number,
            p_email, p_address, p_national_id, p_date_of_birth, p_is_client, p_notes
        );
        
        -- Log activity
        INSERT INTO activity_log (agent_id, activity_type, entity_type, entity_id, description)
        VALUES (p_agent_id, 'client_created', 'client', v_client_id, 
                v_client_name || ' added as ' || CASE WHEN p_is_client THEN 'client' ELSE 'prospect' END);
    ELSE
        -- Update existing client
        v_client_id := p_client_id;
        
        UPDATE clients 
        SET 
            first_name = p_first_name,
            surname = p_surname,
            last_name = p_last_name,
            phone_number = p_phone_number,
            email = p_email,
            address = p_address,
            national_id = p_national_id,
            date_of_birth = p_date_of_birth,
            is_client = p_is_client,
            notes = p_notes,
            modified_date = NOW()
        WHERE clients.client_id = p_client_id;
        
        -- Log activity
        INSERT INTO activity_log (agent_id, activity_type, entity_type, entity_id, description)
        VALUES (p_agent_id, 'client_updated', 'client', v_client_id, v_client_name || ' updated');
    END IF;
    
    RETURN QUERY SELECT v_client_id;
END;
$ LANGUAGE plpgsql;

-- Get Clients
CREATE OR REPLACE FUNCTION sp_get_clients(p_agent_id UUID,
    p_search_term VARCHAR(100) DEFAULT NULL,
    p_filter_type VARCHAR(20) DEFAULT 'all',
    p_insurance_type VARCHAR(50) DEFAULT NULL)
RETURNS TABLE (
    client_id UUID,
    first_name VARCHAR(50),
    surname VARCHAR(50),
    last_name VARCHAR(50),
    phone_number VARCHAR(20),
    email VARCHAR(100),
    address VARCHAR(500),
    national_id VARCHAR(20),
    date_of_birth DATE,
    is_client BOOLEAN,
    insurance_type VARCHAR(50),
    notes TEXT,
    created_date TIMESTAMP,
    modified_date TIMESTAMP,
    policy_id UUID,
    policy_name VARCHAR(255),
    policy_type VARCHAR(100),
    policy_company VARCHAR(255),
    policy_status VARCHAR(20),
    policy_start_date DATE,
    policy_end_date DATE,
    policy_notes TEXT
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        c.client_id,
        c.first_name,
        c.surname,
        c.last_name,
        c.phone_number,
        c.email,
        c.address,
        c.national_id,
        c.date_of_birth,
        c.is_client,
        c.insurance_type,
        c.notes,
        c.created_date,
        c.modified_date,

        -- Policy Info from related tables
        cp.policy_id,
        cp.policy_name,
        pt.type_name AS policy_type,
        ic.company_name AS policy_company,
        cp.status AS policy_status,
        cp.start_date AS policy_start_date,
        cp.end_date AS policy_end_date,
        cp.notes AS policy_notes
    FROM clients c
    LEFT JOIN client_policies cp 
        ON c.client_id = cp.client_id AND cp.is_active = true
    LEFT JOIN policy_catalog pc
        ON cp.policy_catalog_id = pc.policy_catalog_id
    LEFT JOIN policy_types pt
        ON pc.type_id = pt.type_id
    LEFT JOIN insurance_companies ic
        ON pc.company_id = ic.company_id
    WHERE 
        c.agent_id = p_agent_id 
        AND c.is_active = true
        AND (
            p_search_term IS NULL OR 
            c.first_name ILIKE '%' || p_search_term || '%' OR
            c.surname ILIKE '%' || p_search_term || '%' OR
            c.last_name ILIKE '%' || p_search_term || '%' OR
            c.phone_number ILIKE '%' || p_search_term || '%' OR
            c.email ILIKE '%' || p_search_term || '%'
        )
        AND (
            p_filter_type = 'all' OR 
            (p_filter_type = 'clients' AND c.is_client = true) OR
            (p_filter_type = 'prospects' AND c.is_client = false)
        )
        AND (p_insurance_type IS NULL OR c.insurance_type = p_insurance_type)
    ORDER BY c.first_name, c.surname;
END;
$ LANGUAGE plpgsql;

-- Get Client
CREATE OR REPLACE FUNCTION sp_get_client(p_client_id UUID,
    p_agent_id UUID)
RETURNS TABLE (
    -- Client details
    client_id UUID,
    agent_id UUID,
    first_name VARCHAR(50),
    surname VARCHAR(50),
    last_name VARCHAR(50),
    phone_number VARCHAR(20),
    email VARCHAR(100),
    address VARCHAR(500),
    national_id VARCHAR(20),
    date_of_birth DATE,
    is_client BOOLEAN,
    insurance_type VARCHAR(50),
    notes TEXT,
    created_date TIMESTAMP,
    modified_date TIMESTAMP,
    is_active BOOLEAN,
    -- Policy details
    policy_id UUID,
    policy_name VARCHAR(255),
    policy_type VARCHAR(100),
    policy_company VARCHAR(255),
    policy_status VARCHAR(20),
    policy_start_date DATE,
    policy_end_date DATE,
    policy_notes TEXT
) AS $$
BEGIN
    -- Main client details with linked policy info
    RETURN QUERY
    SELECT 
        c.client_id,
        c.agent_id,
        c.first_name,
        c.surname,
        c.last_name,
        c.phone_number,
        c.email,
        c.address,
        c.national_id,
        c.date_of_birth,
        c.is_client,
        c.insurance_type,
        c.notes,
        c.created_date,
        c.modified_date,
        c.is_active,
        cp.policy_id,
        cp.policy_name,
        pt.type_name AS policy_type,
        ic.company_name AS policy_company,
        cp.status AS policy_status,
        cp.start_date AS policy_start_date,
        cp.end_date AS policy_end_date,
        cp.notes AS policy_notes
    FROM clients c
    LEFT JOIN client_policies cp 
        ON c.client_id = cp.client_id AND cp.is_active = true
    LEFT JOIN policy_catalog pc 
        ON cp.policy_catalog_id = pc.policy_catalog_id
    LEFT JOIN policy_types pt 
        ON pc.type_id = pt.type_id
    LEFT JOIN insurance_companies ic 
        ON pc.company_id = ic.company_id
    WHERE 
        c.client_id = p_client_id 
        AND c.agent_id = p_agent_id 
        AND c.is_active = true;
END;
$ LANGUAGE plpgsql;

-- Get Client Appointments (separate function since PostgreSQL functions can only return one result set)
CREATE OR REPLACE FUNCTION sp_get_client_appointments(p_client_id UUID,
    p_agent_id UUID)
RETURNS TABLE (
    appointment_id UUID,
    title VARCHAR(255),
    appointment_date DATE,
    start_time TIME,
    end_time TIME,
    type VARCHAR(50),
    status VARCHAR(20),
    location VARCHAR(255)
) AS $
BEGIN
    -- Appointments for the client
    RETURN QUERY
    SELECT 
        a.appointment_id,
        a.title,
        a.appointment_date,
        a.start_time,
        a.end_time,
        a.type,
        a.status,
        a.location
    FROM appointments a
    WHERE 
        a.client_id = p_client_id 
        AND a.agent_id = p_agent_id 
        AND a.is_active = true
    ORDER BY a.appointment_date DESC, a.start_time DESC;
END;
$ LANGUAGE plpgsql;

-- Delete Client
CREATE OR REPLACE FUNCTION sp_delete_client(p_client_id UUID,
    p_agent_id UUID)
RETURNS TABLE (
    rows_affected INTEGER
) AS $
DECLARE
    v_client_name TEXT;
    v_rows_affected INTEGER;
BEGIN
    -- Get client name for logging
    SELECT first_name || ' ' || surname INTO v_client_name 
    FROM clients WHERE client_id = p_client_id;
    
    -- Soft delete - set is_active to false
    UPDATE clients 
    SET is_active = false, modified_date = NOW()
    WHERE client_id = p_client_id AND agent_id = p_agent_id;
    
    GET DIAGNOSTICS v_rows_affected = ROW_COUNT;
    
    -- Also soft delete related appointments
    UPDATE appointments 
    SET is_active = false, modified_date = NOW()
    WHERE client_id = p_client_id AND agent_id = p_agent_id;
    
    -- Log activity
    INSERT INTO activity_log (agent_id, activity_type, entity_type, entity_id, description)
    VALUES (p_agent_id, 'client_deleted', 'client', p_client_id, v_client_name || ' deleted');
    
    RETURN QUERY SELECT v_rows_affected;
END;
$ LANGUAGE plpgsql;

-- Get Upcoming Reminders
CREATE OR REPLACE FUNCTION sp_get_upcoming_reminders(p_agent_id UUID,
    p_days_ahead INTEGER DEFAULT 7)
RETURNS TABLE (
    reminder_id UUID,
    client_id UUID,
    reminder_type VARCHAR(50),
    title VARCHAR(255),
    description TEXT,
    reminder_date DATE,
    reminder_time TIME,
    client_name VARCHAR(255),
    priority VARCHAR(20),
    status VARCHAR(20),
    notes TEXT,
    client_phone VARCHAR(20)
) AS $
DECLARE
    v_end_date DATE := CURRENT_DATE + INTERVAL '1 day' * p_days_ahead;
BEGIN
    RETURN QUERY
    SELECT 
        r.reminder_id,
        r.client_id,
        r.reminder_type,
        r.title,
        r.description,
        r.reminder_date,
        r.reminder_time,
        r.client_name,
        r.priority,
        r.status,
        r.notes,
        c.phone_number AS client_phone
    FROM reminders r
    LEFT JOIN clients c ON r.client_id = c.client_id
    WHERE r.agent_id = p_agent_id 
        AND r.status = 'Active'
        AND r.reminder_date BETWEEN CURRENT_DATE AND v_end_date
    ORDER BY r.reminder_date, r.reminder_time;
END;
$ LANGUAGE plpgsql;

-- Get Client Statistics
CREATE OR REPLACE FUNCTION sp_get_client_statistics(p_agent_id UUID)
RETURNS TABLE (
    total_contacts BIGINT,
    total_clients BIGINT,
    total_prospects BIGINT,
    today_birthdays BIGINT
) AS $
 $
BEGIN
    RETURN QUERY
    SELECT 
        COUNT(*) AS total_contacts,
        COUNT(CASE WHEN is_client = true THEN 1 END) AS total_clients,
        COUNT(CASE WHEN is_client = false THEN 1 END) AS total_prospects,
        COUNT(CASE WHEN 
            EXTRACT(DAY FROM date_of_birth) = EXTRACT(DAY FROM CURRENT_DATE) 
            AND EXTRACT(MONTH FROM date_of_birth) = EXTRACT(MONTH FROM CURRENT_DATE) 
            THEN 1 END) AS  $$
today_birthdays
    FROM clients
    WHERE agent_id = p_agent_id AND is_active = true
$$ LANGUAGE plpgsql;
END;
$ LANGUAGE plpgsql;

-- Get Today's Birthdays
CREATE OR REPLACE FUNCTION sp_get_today_birthdays(p_agent_id UUID)
RETURNS TABLE (
    client_id UUID,
    first_name VARCHAR(50),
    surname VARCHAR(50),
    last_name VARCHAR(50),
    phone_number VARCHAR(20),
    email VARCHAR(100),
    insurance_type VARCHAR(50),
    date_of_birth DATE,
    age INTEGER
) AS $
BEGIN
    RETURN QUERY
    SELECT 
        c.client_id,
        c.first_name,
        c.surname,
        c.last_name,
        c.phone_number,
        c.email,
        c.insurance_type,
        c.date_of_birth,
        EXTRACT(YEAR FROM AGE(CURRENT_DATE, c.date_of_birth))::INTEGER AS  $$
age
    FROM clients c
    WHERE 
        c.agent_id = p_agent_id 
        AND c.is_active = true
        AND EXTRACT(DAY FROM c.date_of_birth) = EXTRACT(DAY FROM CURRENT_DATE)
        AND EXTRACT(MONTH FROM c.date_of_birth) = EXTRACT(MONTH FROM CURRENT_DATE)
    ORDER BY c.first_name, c.surname
$$ LANGUAGE plpgsql;
END;
$ LANGUAGE plpgsql;

-- Get All Clients with Advanced Filters
CREATE OR REPLACE FUNCTION sp_get_all_clients(p_agent_id UUID,
    p_search_term VARCHAR(100) DEFAULT NULL,
    p_insurance_type VARCHAR(50) DEFAULT NULL,
    p_is_client BOOLEAN DEFAULT NULL,
    p_page_number INTEGER DEFAULT 1,
    p_page_size INTEGER DEFAULT 50)
RETURNS TABLE (
    client_id UUID,
    first_name VARCHAR(50),
    surname VARCHAR(50),
    last_name VARCHAR(50),
    phone_number VARCHAR(20),
    email VARCHAR(100),
    address VARCHAR(500),
    national_id VARCHAR(20),
    date_of_birth DATE,
    age INTEGER,
    is_client BOOLEAN,
    insurance_type VARCHAR(50),
    notes TEXT,
    created_date TIMESTAMP,
    modified_date TIMESTAMP,
    policy_count BIGINT,
    next_expiry_date DATE
) AS  $$
$
DECLARE
    v_offset INTEGER := (p_page_number - 1) * p_page_size
$$ LANGUAGE plpgsql;
BEGIN
    RETURN QUERY
    SELECT 
        c.client_id,
        c.first_name,
        c.surname,
        c.last_name,
        c.phone_number,
        c.email,
        c.address,
        c.national_id,
        c.date_of_birth,
        EXTRACT(YEAR FROM AGE(CURRENT_DATE, c.date_of_birth))::INTEGER as age,
        c.is_client,
        c.insurance_type,
        c.notes,
        c.created_date,
        c.modified_date,
        COUNT(cp.policy_id) as policy_count,
        MAX(cp.end_date) as next_expiry_date
    FROM clients c
    LEFT JOIN client_policies cp ON c.client_id = cp.client_id AND cp.is_active = true
    WHERE 
        c.agent_id = p_agent_id 
        AND c.is_active = true
        AND (p_search_term IS NULL OR 
             c.first_name ILIKE '%' || p_search_term || '%' OR 
             c.surname ILIKE '%' || p_search_term || '%' OR
             c.last_name ILIKE '%' || p_search_term || '%' OR
             c.phone_number ILIKE '%' || p_search_term || '%' OR
             c.email ILIKE '%' || p_search_term || '%')
        AND (p_insurance_type IS NULL OR c.insurance_type = p_insurance_type)
        AND (p_is_client IS NULL OR c.is_client = p_is_client)
    GROUP BY 
        c.client_id, c.first_name, c.surname, c.last_name, c.phone_number,
        c.email, c.address, c.national_id, c.date_of_birth, c.is_client,
        c.insurance_type, c.notes, c.created_date, c.modified_date
    ORDER BY c.created_date DESC
    LIMIT p_page_size OFFSET v_offset;
END;
$ LANGUAGE plpgsql;

-- Search Clients
CREATE OR REPLACE FUNCTION sp_search_clients(p_agent_id UUID,
    p_search_term VARCHAR(100))
RETURNS TABLE (
    client_id UUID,
    first_name VARCHAR(50),
    surname VARCHAR(50),
    last_name VARCHAR(50),
    phone_number VARCHAR(20),
    email VARCHAR(100),
    is_client BOOLEAN,
    insurance_type VARCHAR(50),
    age INTEGER
) AS $
BEGIN
    RETURN QUERY
    SELECT 
        c.client_id,
        c.first_name,
        c.surname,
        c.last_name,
        c.phone_number,
        c.email,
        c.is_client,
        c.insurance_type,
        EXTRACT(YEAR FROM AGE(CURRENT_DATE, c.date_of_birth))::INTEGER as  $$
age
    FROM clients c
    WHERE 
        c.agent_id = p_agent_id 
        AND c.is_active = true
        AND (
            c.first_name ILIKE '%' || p_search_term || '%' OR 
            c.surname ILIKE '%' || p_search_term || '%' OR
            c.last_name ILIKE '%' || p_search_term || '%' OR
            c.phone_number ILIKE '%' || p_search_term || '%' OR
            c.email ILIKE '%' || p_search_term || '%' OR
            c.national_id ILIKE '%' || p_search_term || '%'
        )
    ORDER BY c.first_name, c.surname
$$ LANGUAGE plpgsql;
END;
$ LANGUAGE plpgsql;

-- Get Clients by Insurance Type
CREATE OR REPLACE FUNCTION sp_get_clients_by_insurance_type(p_agent_id UUID,
    p_insurance_type VARCHAR(50))
RETURNS TABLE (
    client_id UUID,
    first_name VARCHAR(50),
    surname VARCHAR(50),
    last_name VARCHAR(50),
    phone_number VARCHAR(20),
    email VARCHAR(100),
    address VARCHAR(500),
    date_of_birth DATE,
    age INTEGER,
    is_client BOOLEAN,
    insurance_type VARCHAR(50),
    created_date TIMESTAMP,
    policy_count BIGINT
) AS $
BEGIN
    RETURN QUERY
    SELECT 
        c.client_id,
        c.first_name,
        c.surname,
        c.last_name,
        c.phone_number,
        c.email,
        c.address,
        c.date_of_birth,
        EXTRACT(YEAR FROM AGE(CURRENT_DATE, c.date_of_birth))::INTEGER as age,
        c.is_client,
        c.insurance_type,
        c.created_date,
        COUNT(cp.policy_id) as  $$
policy_count
    FROM clients c
    LEFT JOIN client_policies cp ON c.client_id = cp.client_id AND cp.is_active = true
    WHERE 
        c.agent_id = p_agent_id 
        AND c.is_active = true
        AND c.insurance_type = p_insurance_type
    GROUP BY 
        c.client_id, c.first_name, c.surname, c.last_name, c.phone_number,
        c.email, c.address, c.date_of_birth, c.is_client, c.insurance_type, c.created_date
    ORDER BY c.first_name, c.surname
$$ LANGUAGE plpgsql;
END;
$ LANGUAGE plpgsql;

-- Get Client with Full Details (main client info)
CREATE OR REPLACE FUNCTION sp_get_client_with_policies(p_client_id UUID,
    p_agent_id UUID)
RETURNS TABLE (
    client_id UUID,
    first_name VARCHAR(50),
    surname VARCHAR(50),
    last_name VARCHAR(50),
    phone_number VARCHAR(20),
    email VARCHAR(100),
    address VARCHAR(500),
    national_id VARCHAR(20),
    date_of_birth DATE,
    age INTEGER,
    is_client BOOLEAN,
    insurance_type VARCHAR(50),
    notes TEXT,
    created_date TIMESTAMP,
    modified_date TIMESTAMP
) AS $
BEGIN
    -- Client details
    RETURN QUERY
    SELECT 
        c.client_id,
        c.first_name,
        c.surname,
        c.last_name,
        c.phone_number,
        c.email,
        c.address,
        c.national_id,
        c.date_of_birth,
        EXTRACT(YEAR FROM AGE(CURRENT_DATE, c.date_of_birth))::INTEGER as  $$
age,
        c.is_client,
        c.insurance_type,
        c.notes,
        c.created_date,
        c.modified_date
    FROM clients c
    WHERE c.client_id = p_client_id AND c.agent_id = p_agent_id AND c.is_active = true
$$ LANGUAGE plpgsql;
END;
$ LANGUAGE plpgsql;

-- Get Client Policies (separate function for client policies)
CREATE OR REPLACE FUNCTION sp_get_client_policies_details(p_client_id UUID)
RETURNS TABLE (
    policy_id UUID,
    policy_name VARCHAR(255),
    policy_type VARCHAR(100),
    company_name VARCHAR(255),
    status VARCHAR(20),
    start_date DATE,
    end_date DATE,
    days_to_expiry INTEGER,
    notes TEXT,
    created_date TIMESTAMP
) AS $
 $
BEGIN
    -- Client policies
    RETURN QUERY
    SELECT 
        cp.policy_id,
        cp.policy_name,
        cp.policy_type,
        cp.company_name,
        cp.status,
        cp.start_date,
        cp.end_date,
        (cp.end_date - CURRENT_DATE)::INTEGER as  $$
days_to_expiry,
        cp.notes,
        cp.created_date
    FROM client_policies cp
    WHERE cp.client_id = p_client_id AND cp.is_active = true
    ORDER BY cp.end_date DESC
$$ LANGUAGE plpgsql;
END;
$ LANGUAGE plpgsql;

-- Get Client Recent Appointments (separate function)
CREATE OR REPLACE FUNCTION sp_get_client_recent_appointments(p_client_id UUID)
RETURNS TABLE (
    appointment_id UUID,
    title VARCHAR(255),
    appointment_date DATE,
    start_time TIME,
    type VARCHAR(50),
    status VARCHAR(20)
) AS  $$
$
 $
BEGIN
    -- Recent appointments (limit 5)
    RETURN QUERY
    SELECT 
        a.appointment_id,
        a.title,
        a.appointment_date,
        a.start_time,
        a.type,
        a.status
    FROM appointments a
    WHERE a.client_id = p_client_id AND a.is_active = true
    ORDER BY a.appointment_date DESC, a.start_time DESC
    LIMIT 5
$$ LANGUAGE plpgsql;
END;
$ LANGUAGE plpgsql;

-- Get Client Active Reminders (separate function)
CREATE OR REPLACE FUNCTION sp_get_client_active_reminders(p_client_id UUID)
RETURNS TABLE (
    reminder_id UUID,
    title VARCHAR(255),
    reminder_date DATE,
    reminder_time TIME,
    reminder_type VARCHAR(50),
    priority VARCHAR(20),
    status VARCHAR(20)
) AS  $$
$
 $
BEGIN
    -- Active reminders
    RETURN QUERY
    SELECT 
        r.reminder_id,
        r.title,
        r.reminder_date,
        r.reminder_time,
        r.reminder_type,
        r.priority,
        r.status
    FROM reminders r
    WHERE r.client_id = p_client_id AND r.status = 'Active'
    ORDER BY r.reminder_date, r.reminder_time
$$ LANGUAGE plpgsql;
END;
$ LANGUAGE plpgsql;

-- Create New Client
CREATE OR REPLACE FUNCTION sp_create_client(p_agent_id UUID,
    p_first_name VARCHAR(50),
    p_surname VARCHAR(50),
    p_last_name VARCHAR(50),
    p_phone_number VARCHAR(20),
    p_email VARCHAR(100),
    p_address VARCHAR(500),
    p_national_id VARCHAR(20),
    p_date_of_birth DATE,
    p_insurance_type VARCHAR(50),
    p_is_client BOOLEAN DEFAULT false,
    p_notes TEXT DEFAULT NULL)
RETURNS TABLE (
    success INTEGER,
    message TEXT,
    client_id UUID
) AS  $$
$
DECLARE
    v_client_id UUID := gen_random_uuid()
$$ LANGUAGE plpgsql;
    v_client_type TEXT := CASE WHEN p_is_client THEN 'client' ELSE 'prospect' END;
BEGIN
    -- Check for duplicate phone or email
    IF EXISTS(SELECT 1 FROM clients WHERE phone_number = p_phone_number AND agent_id = p_agent_id AND is_active = true) THEN
        RETURN QUERY SELECT 
            0 as success,
            'Phone number already exists'::TEXT as message,
            NULL::UUID as client_id;
        RETURN;
    END IF;
    
    IF EXISTS(SELECT 1 FROM clients WHERE email = p_email AND agent_id = p_agent_id AND is_active = true) THEN
        RETURN QUERY SELECT 
            0 as success,
            'Email already exists'::TEXT as message,
            NULL::UUID as client_id;
        RETURN;
    END IF;
    
    BEGIN
        INSERT INTO clients (
            client_id, agent_id, first_name, surname, last_name, phone_number,
            email, address, national_id, date_of_birth, is_client, insurance_type, notes
        )
        VALUES (
            v_client_id, p_agent_id, p_first_name, p_surname, p_last_name, p_phone_number,
            p_email, p_address, p_national_id, p_date_of_birth, p_is_client, p_insurance_type, p_notes
        );
        
        -- Log activity
        INSERT INTO activity_log (agent_id, activity_type, entity_type, entity_id, description)
        VALUES (
            p_agent_id, 
            CASE WHEN p_is_client THEN 'client_added' ELSE 'prospect_added' END,
            'client', 
            v_client_id, 
            'Added new ' || v_client_type || ': ' || p_first_name || ' ' || p_surname
        );
        
        RETURN QUERY SELECT 
            1 as success,
            CASE WHEN p_is_client THEN 'Client created successfully' ELSE 'Prospect created successfully' END::TEXT as message,
            v_client_id as client_id;
            
    EXCEPTION WHEN OTHERS THEN
        RETURN QUERY SELECT 
            0 as success,
            SQLERRM::TEXT as message,
            NULL::UUID as client_id;
    END;
END;
$ LANGUAGE plpgsql;

-- Get Completed Reminders
CREATE OR REPLACE FUNCTION sp_get_completed_reminders(p_agent_id UUID,
    p_start_date DATE DEFAULT NULL,
    p_end_date DATE DEFAULT NULL)
RETURNS TABLE (
    reminder_id UUID,
    client_id UUID,
    reminder_type VARCHAR(50),
    title VARCHAR(255),
    description TEXT,
    reminder_date DATE,
    reminder_time TIME,
    client_name VARCHAR(255),
    priority VARCHAR(20),
    status VARCHAR(20),
    completed_date TIMESTAMP,
    notes TEXT,
    client_phone VARCHAR(20)
) AS $
DECLARE
    v_start_date DATE := COALESCE(p_start_date, CURRENT_DATE - INTERVAL '30 days');
    v_end_date DATE := COALESCE(p_end_date, CURRENT_DATE);
BEGIN
    RETURN QUERY
    SELECT 
        r.reminder_id,
        r.client_id,
        r.reminder_type,
        r.title,
        r.description,
        r.reminder_date,
        r.reminder_time,
        r.client_name,
        r.priority,
        r.status,
        r.completed_date,
        r.notes,
        c.phone_number AS client_phone
    FROM reminders r
    LEFT JOIN clients c ON r.client_id = c.client_id
    WHERE r.agent_id = p_agent_id 
        AND r.status = 'Completed'
        AND r.completed_date BETWEEN v_start_date AND (v_end_date + INTERVAL '1 day')
    ORDER BY r.completed_date DESC;
END;
$ LANGUAGE plpgsql;

-- Update Client
CREATE OR REPLACE FUNCTION sp_update_client(p_client_id UUID,
    p_agent_id UUID,
    p_first_name VARCHAR(50),
    p_surname VARCHAR(50),
    p_last_name VARCHAR(50),
    p_phone_number VARCHAR(20),
    p_email VARCHAR(100),
    p_address VARCHAR(500),
    p_national_id VARCHAR(20),
    p_date_of_birth DATE,
    p_insurance_type VARCHAR(50),
    p_notes TEXT DEFAULT NULL)
RETURNS TABLE (
    success INTEGER,
    message TEXT
) AS $
BEGIN
    -- Check if client exists and belongs to agent
    IF NOT EXISTS(SELECT 1 FROM clients WHERE client_id = p_client_id AND agent_id = p_agent_id AND is_active = true) THEN
        RETURN QUERY SELECT 
            0 as success,
            'Client not found'::TEXT as  $$
message
$$ LANGUAGE plpgsql;
        RETURN;
    END IF;
    
    -- Check for duplicate phone or email (excluding current client)
    IF EXISTS(SELECT 1 FROM clients WHERE phone_number = p_phone_number AND agent_id = p_agent_id AND client_id != p_client_id AND is_active = true) THEN
        RETURN QUERY SELECT 
            0 as success,
            'Phone number already exists for another client'::TEXT as message;
        RETURN;
    END IF;
    
    IF EXISTS(SELECT 1 FROM clients WHERE email = p_email AND agent_id = p_agent_id AND client_id != p_client_id AND is_active = true) THEN
        RETURN QUERY SELECT 
            0 as success,
            'Email already exists for another client'::TEXT as message;
        RETURN;
    END IF;
    
    BEGIN
        UPDATE clients 
        SET 
            first_name = p_first_name,
            surname = p_surname,
            last_name = p_last_name,
            phone_number = p_phone_number,
            email = p_email,
            address = p_address,
            national_id = p_national_id,
            date_of_birth = p_date_of_birth,
            insurance_type = p_insurance_type,
            notes = p_notes,
            modified_date = NOW()
        WHERE client_id = p_client_id AND agent_id = p_agent_id;
        
        -- Log activity
        INSERT INTO activity_log (agent_id, activity_type, entity_type, entity_id, description)
        VALUES (
            p_agent_id, 
            'client_updated',
            'client', 
            p_client_id, 
            'Updated client: ' || p_first_name || ' ' || p_surname
        );
        
        RETURN QUERY SELECT 
            1 as success,
            'Client updated successfully'::TEXT as message;
            
    EXCEPTION WHEN OTHERS THEN
        RETURN QUERY SELECT 
            0 as success,
            SQLERRM::TEXT as message;
    END;
END;
$ LANGUAGE plpgsql;

-- Get Enhanced Client Statistics
CREATE OR REPLACE FUNCTION sp_get_enhanced_client_statistics(p_agent_id UUID)
RETURNS TABLE (
    total_clients BIGINT,
    total_prospects BIGINT,
    total_contacts BIGINT,
    active_policies BIGINT,
    expiring_policies BIGINT,
    today_birthdays BIGINT,
    month_birthdays BIGINT,
    new_this_week BIGINT,
    new_this_month BIGINT,
    insurance_type_breakdown JSONB
) AS $
 $
BEGIN
    RETURN QUERY
    SELECT 
        -- Client counts
        COUNT(CASE WHEN is_client = true THEN 1 END) as total_clients,
        COUNT(CASE WHEN is_client = false THEN 1 END) as total_prospects,
        COUNT(*) as total_contacts,
        
        -- Policy statistics
        (SELECT COUNT(*) FROM client_policies cp 
         INNER JOIN clients c ON cp.client_id = c.client_id 
         WHERE c.agent_id = p_agent_id AND cp.is_active = true AND cp.status = 'Active') as active_policies,
        
        (SELECT COUNT(*) FROM client_policies cp 
         INNER JOIN clients c ON cp.client_id = c.client_id 
         WHERE c.agent_id = p_agent_id AND cp.is_active = true 
         AND cp.end_date BETWEEN CURRENT_DATE AND (CURRENT_DATE + INTERVAL '30 days')) as expiring_policies,
        
        -- Birthday statistics
        COUNT(CASE WHEN EXTRACT(MONTH FROM date_of_birth) = EXTRACT(MONTH FROM CURRENT_DATE) 
                   AND EXTRACT(DAY FROM date_of_birth) = EXTRACT(DAY FROM CURRENT_DATE) THEN 1 END) as today_birthdays,
        
        COUNT(CASE WHEN EXTRACT(MONTH FROM date_of_birth) = EXTRACT(MONTH FROM CURRENT_DATE) THEN 1 END) as month_birthdays,
        
        -- Recent additions
        COUNT(CASE WHEN created_date >= (CURRENT_DATE - INTERVAL '7 days') THEN 1 END) as new_this_week,
        COUNT(CASE WHEN created_date >= (CURRENT_DATE - INTERVAL '30 days') THEN 1 END) as new_this_month,
        
        -- Insurance type breakdown as JSON
        (SELECT jsonb_agg(
            jsonb_build_object(
                'insurance_type', insurance_type,
                'count', count,
                'client_count', client_count,
                'prospect_count', prospect_count
            )
        ) FROM (
            SELECT 
                insurance_type,
                COUNT(*) as count,
                COUNT(CASE WHEN is_client = true THEN 1 END) as client_count,
                COUNT(CASE WHEN is_client = false THEN 1 END) as prospect_count
            FROM clients 
            WHERE agent_id = p_agent_id AND is_active = true
            GROUP BY insurance_type
        ) breakdown) as  $$
insurance_type_breakdown
         
    FROM clients 
    WHERE agent_id = p_agent_id AND is_active = true
$$ LANGUAGE plpgsql;
END;
$ LANGUAGE plpgsql;

-- Get Policy Statistics
CREATE OR REPLACE FUNCTION sp_get_policy_statistics(p_agent_id UUID)
RETURNS TABLE (
    active_policies BIGINT,
    expired_policies BIGINT,
    lapsed_policies BIGINT,
    expiring_policies BIGINT,
    policy_types BIGINT,
    insurance_companies BIGINT
) AS $
 $
BEGIN
    RETURN QUERY
    SELECT 
        COUNT(CASE WHEN cp.status = 'Active' THEN 1 END) AS active_policies,
        COUNT(CASE WHEN cp.status = 'Expired' THEN 1 END) AS expired_policies,
        COUNT(CASE WHEN cp.status = 'Lapsed' THEN 1 END) AS lapsed_policies,
        COUNT(CASE WHEN cp.end_date BETWEEN CURRENT_DATE AND (CURRENT_DATE + INTERVAL '30 days') THEN 1 END) AS expiring_policies,
        COUNT(DISTINCT pt.type_id) AS policy_types,
        COUNT(DISTINCT ic.company_id) AS  $$
insurance_companies
    FROM client_policies cp
    INNER JOIN clients c ON cp.client_id = c.client_id
    LEFT JOIN policy_type pt ON cp.type_id = pt.type_id
    LEFT JOIN insurance_company ic ON cp.company_id = ic.company_id
    WHERE c.agent_id = p_agent_id AND cp.is_active = true AND c.is_active = true
$$ LANGUAGE plpgsql;
END;
$ LANGUAGE plpgsql;

-- Create Policy Template
CREATE OR REPLACE FUNCTION sp_create_policy_template(p_agent_id UUID,
    p_template_name VARCHAR(100),
    p_type_id UUID,
    p_default_term_months INTEGER DEFAULT NULL,
    p_default_premium DECIMAL(18,2) DEFAULT NULL,
    p_coverage_description TEXT DEFAULT NULL,
    p_terms TEXT DEFAULT NULL,
    p_category_id UUID DEFAULT NULL)
RETURNS TABLE (
    template_id UUID
) AS  $$
$
DECLARE
    v_template_id UUID := gen_random_uuid()
$$ LANGUAGE plpgsql;
BEGIN
    INSERT INTO policy_template (
        template_id, agent_id, template_name, type_id, category_id,
        default_term_months, default_premium, coverage_description, terms
    )
    VALUES (
        v_template_id, p_agent_id, p_template_name, p_type_id, p_category_id,
        p_default_term_months, p_default_premium, p_coverage_description, p_terms
    );
    
    INSERT INTO activity_log (agent_id, activity_type, entity_type, entity_id, description)
    VALUES (
        p_agent_id, 'policy_template_created', 'policy_template', v_template_id, 
        'Policy template "' || p_template_name || '" created'
    );

    RETURN QUERY SELECT v_template_id;
END;
$ LANGUAGE plpgsql;

-- Get Policy Templates
CREATE OR REPLACE FUNCTION sp_get_policy_templates(p_agent_id UUID,
    p_type_id UUID DEFAULT NULL)
RETURNS TABLE (
    template_id UUID,
    template_name VARCHAR(100),
    type_id UUID,
    type_name VARCHAR(100),
    default_term_months INTEGER,
    default_premium DECIMAL(18,2),
    coverage_description TEXT,
    terms TEXT,
    category_id UUID,
    category_name VARCHAR(100),
    created_date TIMESTAMP
) AS  $$
$
 $
BEGIN
    RETURN QUERY
    SELECT 
        pt.template_id,
        pt.template_name,
        pt.type_id,
        ptype.type_name,
        pt.default_term_months,
        pt.default_premium,
        pt.coverage_description,
        pt.terms,
        pt.category_id,
        pc.category_name,
        pt.created_date
    FROM policy_template pt
    LEFT JOIN policy_type ptype ON pt.type_id = ptype.type_id
    LEFT JOIN policy_category pc ON pt.category_id = pc.category_id
    WHERE 
        pt.agent_id = p_agent_id 
        AND pt.is_active = true
        AND (p_type_id IS NULL OR pt.type_id = p_type_id)
    ORDER BY ptype.type_name, pt.template_name
$$ LANGUAGE plpgsql;
END;
$ LANGUAGE plpgsql;

-- Delete Policy Template
CREATE OR REPLACE FUNCTION sp_delete_policy_template(p_template_id UUID,
    p_agent_id UUID)
RETURNS TABLE (
    rows_affected INTEGER
) AS  $$
$
 $
DECLARE
    v_rows_affected INTEGER
$$ LANGUAGE plpgsql;
BEGIN
    UPDATE policy_template 
    SET is_active = false
    WHERE template_id = p_template_id AND agent_id = p_agent_id;
    
    GET DIAGNOSTICS v_rows_affected = ROW_COUNT;
    
    IF v_rows_affected > 0 THEN
        INSERT INTO activity_log (agent_id, activity_type, entity_type, entity_id, description)
        VALUES (
            p_agent_id, 'policy_template_deleted', 'policy_template', p_template_id, 
            'Policy template deleted'
        );
    END IF;
    
    RETURN QUERY SELECT v_rows_affected;
END;
$ LANGUAGE plpgsql;

-- Get Policy Catalog for Agent
CREATE OR REPLACE FUNCTION sp_get_policy_catalog(p_agent_id UUID,
    p_type_id UUID DEFAULT NULL,
    p_company_id UUID DEFAULT NULL)
RETURNS TABLE (
    policy_catalog_id UUID,
    policy_name VARCHAR(255),
    type_id UUID,
    type_name VARCHAR(100),
    company_id UUID,
    company_name VARCHAR(255),
    category_id UUID,
    category_name VARCHAR(100),
    notes TEXT,
    created_date TIMESTAMP,
    modified_date TIMESTAMP
) AS  $$
$
 $
BEGIN
    RETURN QUERY
    SELECT 
        pc.policy_catalog_id,
        pc.policy_name,
        pc.type_id,
        pt.type_name,
        pc.company_id,
        ic.company_name,
        pc.category_id,
        pcat.category_name,
        pc.notes,
        pc.created_date,
        pc.modified_date
    FROM policy_catalog pc
    LEFT JOIN policy_type pt ON pc.type_id = pt.type_id
    LEFT JOIN insurance_company ic ON pc.company_id = ic.company_id
    LEFT JOIN policy_category pcat ON pc.category_id = pcat.category_id
    WHERE 
        pc.agent_id = p_agent_id 
        AND pc.is_active = true
        AND (p_type_id IS NULL OR pc.type_id = p_type_id)
        AND (p_company_id IS NULL OR pc.company_id = p_company_id)
    ORDER BY pt.type_name, pc.policy_name
$$ LANGUAGE plpgsql;
END;
$ LANGUAGE plpgsql;

-- Update Reminder Setting
CREATE OR REPLACE FUNCTION sp_update_reminder_setting(p_agent_id UUID,
    p_reminder_type VARCHAR(50),
    p_is_enabled BOOLEAN DEFAULT NULL,
    p_days_before INTEGER DEFAULT NULL,
    p_time_of_day TIME DEFAULT NULL,
    p_repeat_daily BOOLEAN DEFAULT NULL)
RETURNS TABLE (
    success INTEGER,
    message TEXT
) AS $$
BEGIN
    IF EXISTS (SELECT 1 FROM reminder_settings WHERE agent_id = p_agent_id AND reminder_type = p_reminder_type) THEN
        UPDATE reminder_settings 
        SET 
            is_enabled = COALESCE(p_is_enabled, is_enabled),
            days_before = COALESCE(p_days_before, days_before),
            time_of_day = COALESCE(p_time_of_day, time_of_day),
            repeat_daily = COALESCE(p_repeat_daily, repeat_daily),
            modified_date = NOW()
        WHERE agent_id = p_agent_id AND reminder_type = p_reminder_type;
    ELSE
        INSERT INTO reminder_settings (
            agent_id, reminder_type, is_enabled, days_before, time_of_day, repeat_daily
        )
        VALUES (
            p_agent_id, p_reminder_type, COALESCE(p_is_enabled, true), 
            COALESCE(p_days_before, 1), COALESCE(p_time_of_day, '09:00'::TIME), 
            COALESCE(p_repeat_daily, false)
        );
    END IF;
    
    RETURN QUERY SELECT 1 AS success, 'Reminder setting updated successfully'::TEXT AS message;
END;
$ LANGUAGE plpgsql;

-- Create Policy Catalog Item
CREATE OR REPLACE FUNCTION sp_create_policy_catalog_item(p_agent_id UUID,
    p_policy_name VARCHAR(100),
    p_type_id UUID,
    p_company_id UUID DEFAULT NULL,
    p_category_id UUID DEFAULT NULL,
    p_notes TEXT DEFAULT NULL)
RETURNS TABLE (
    policy_catalog_id UUID,
    error_message TEXT
) AS  $$
$
DECLARE
    v_policy_catalog_id UUID := gen_random_uuid()
$$ LANGUAGE plpgsql;
BEGIN
    -- Validate TypeId exists
    IF NOT EXISTS (SELECT 1 FROM policy_type WHERE type_id = p_type_id AND is_active = true) THEN
        RETURN QUERY SELECT NULL::UUID, 'Policy type not found or inactive'::TEXT;
        RETURN;
    END IF;
    
    -- Validate CompanyId if provided
    IF p_company_id IS NOT NULL AND NOT EXISTS (SELECT 1 FROM insurance_company WHERE company_id = p_company_id AND is_active = true) THEN
        RETURN QUERY SELECT NULL::UUID, 'Insurance company not found or inactive'::TEXT;
        RETURN;
    END IF;
    
    INSERT INTO policy_catalog (
        policy_catalog_id, agent_id, policy_name, type_id, 
        company_id, category_id, notes, is_active, created_date
    )
    VALUES (
        v_policy_catalog_id, p_agent_id, p_policy_name, p_type_id, 
        p_company_id, p_category_id, p_notes, true, NOW()
    );
    
    INSERT INTO activity_log (agent_id, activity_type, entity_type, entity_id, description)
    VALUES (p_agent_id, 'policy_catalog_created', 'policy_catalog', v_policy_catalog_id, 
            'Policy "' || p_policy_name || '" added to catalog');
    
    RETURN QUERY SELECT v_policy_catalog_id, NULL::TEXT;
END;
$ LANGUAGE plpgsql;

-- Update Policy Catalog Item
CREATE OR REPLACE FUNCTION sp_update_policy_catalog_item(p_policy_catalog_id UUID,
    p_agent_id UUID,
    p_policy_name VARCHAR(100) DEFAULT NULL,
    p_type_id UUID DEFAULT NULL,
    p_company_id UUID DEFAULT NULL,
    p_category_id UUID DEFAULT NULL,
    p_notes TEXT DEFAULT NULL,
    p_is_active BOOLEAN DEFAULT NULL)
RETURNS TABLE (
    rows_affected INTEGER,
    error_message TEXT
) AS  $$
$
DECLARE
    v_rows_affected INTEGER
$$ LANGUAGE plpgsql;
BEGIN
    -- Validate TypeId if provided
    IF p_type_id IS NOT NULL AND NOT EXISTS (SELECT 1 FROM policy_type WHERE type_id = p_type_id AND is_active = true) THEN
        RETURN QUERY SELECT 0, 'Policy type not found or inactive'::TEXT;
        RETURN;
    END IF;
    
    -- Validate CompanyId if provided
    IF p_company_id IS NOT NULL AND NOT EXISTS (SELECT 1 FROM insurance_company WHERE company_id = p_company_id AND is_active = true) THEN
        RETURN QUERY SELECT 0, 'Insurance company not found or inactive'::TEXT;
        RETURN;
    END IF;
    
    UPDATE policy_catalog 
    SET 
        policy_name = COALESCE(p_policy_name, policy_name),
        type_id = COALESCE(p_type_id, type_id),
        company_id = COALESCE(p_company_id, company_id),
        category_id = COALESCE(p_category_id, category_id),
        notes = COALESCE(p_notes, notes),
        is_active = COALESCE(p_is_active, is_active),
        modified_date = NOW()
    WHERE policy_catalog_id = p_policy_catalog_id 
      AND agent_id = p_agent_id;
    
    GET DIAGNOSTICS v_rows_affected = ROW_COUNT;
    
    IF v_rows_affected > 0 THEN
        INSERT INTO activity_log (agent_id, activity_type, entity_type, entity_id, description)
        VALUES (p_agent_id, 'policy_catalog_updated', 'policy_catalog', p_policy_catalog_id, 
                'Policy catalog item updated');
    END IF;
    
    RETURN QUERY SELECT v_rows_affected, NULL::TEXT;
END;
$ LANGUAGE plpgsql;

-- Delete Policy from Catalog
CREATE OR REPLACE FUNCTION sp_delete_policy_catalog(p_policy_catalog_id UUID,
    p_agent_id UUID)
RETURNS TABLE (
    rows_affected INTEGER
) AS  $$
$
 $
DECLARE
    v_policy_name VARCHAR(100)
$$ LANGUAGE plpgsql;
    v_rows_affected INTEGER;
BEGIN
    -- Get policy name for logging
    SELECT policy_name INTO v_policy_name 
    FROM policy_catalog 
    WHERE policy_catalog_id = p_policy_catalog_id;
    
    -- Soft delete
    UPDATE policy_catalog 
    SET is_active = false, modified_date = NOW()
    WHERE policy_catalog_id = p_policy_catalog_id AND agent_id = p_agent_id;
    
    GET DIAGNOSTICS v_rows_affected = ROW_COUNT;
    
    -- Log activity
    IF v_rows_affected > 0 THEN
        INSERT INTO activity_log (agent_id, activity_type, entity_type, entity_id, description)
        VALUES (p_agent_id, 'policy_catalog_deleted', 'policy_catalog', p_policy_catalog_id, 
                'Policy "' || v_policy_name || '" removed from catalog');
    END IF;
    
    RETURN QUERY SELECT v_rows_affected;
END;
$ LANGUAGE plpgsql;

-- Create or Update Client Policy
CREATE OR REPLACE FUNCTION sp_upsert_client_policy(p_client_id UUID,
    p_policy_name VARCHAR(100),
    p_type_id UUID,
    p_status VARCHAR(20),
    p_start_date DATE,
    p_end_date DATE,
    p_policy_id UUID DEFAULT NULL,
    p_company_id UUID DEFAULT NULL,
    p_policy_catalog_id UUID DEFAULT NULL,
    p_notes TEXT DEFAULT NULL)
RETURNS TABLE (
    policy_id UUID,
    error_message TEXT
) AS  $$
$
DECLARE
    v_agent_id UUID
$$ LANGUAGE plpgsql;
    v_policy_id UUID := COALESCE(p_policy_id, gen_random_uuid());
BEGIN
    -- Get agent ID from client
    SELECT agent_id INTO v_agent_id FROM clients WHERE client_id = p_client_id;
    
    IF v_agent_id IS NULL THEN
        RETURN QUERY SELECT NULL::UUID, 'Client not found'::TEXT;
        RETURN;
    END IF;

    -- Validate TypeId
    IF NOT EXISTS (SELECT 1 FROM policy_type WHERE type_id = p_type_id AND is_active = true) THEN
        RETURN QUERY SELECT NULL::UUID, 'Policy type not found or inactive'::TEXT;
        RETURN;
    END IF;

    -- Validate CompanyId if provided
    IF p_company_id IS NOT NULL AND NOT EXISTS (SELECT 1 FROM insurance_company WHERE company_id = p_company_id AND is_active = true) THEN
        RETURN QUERY SELECT NULL::UUID, 'Insurance company not found or inactive'::TEXT;
        RETURN;
    END IF;

    IF p_policy_id IS NULL THEN
        -- Create new client policy
        INSERT INTO client_policies (
            policy_id, client_id, policy_name, type_id, company_id, policy_catalog_id,
            status, start_date, end_date, notes
        )
        VALUES (
            v_policy_id, p_client_id, p_policy_name, p_type_id, p_company_id, p_policy_catalog_id,
            p_status, p_start_date, p_end_date, p_notes
        );

        -- Log activity
        INSERT INTO activity_log (agent_id, activity_type, entity_type, entity_id, description)
        VALUES (
            v_agent_id, 'client_policy_created', 'client_policy', v_policy_id, 
            'Policy "' || p_policy_name || '" assigned to client'
        );
    ELSE
        -- Update existing client policy
        UPDATE client_policies 
        SET 
            policy_name = p_policy_name,
            type_id = p_type_id,
            company_id = p_company_id,
            policy_catalog_id = p_policy_catalog_id,
            status = p_status,
            start_date = p_start_date,
            end_date = p_end_date,
            notes = p_notes,
            modified_date = NOW()
        WHERE policy_id = p_policy_id;

        -- Log activity
        INSERT INTO activity_log (agent_id, activity_type, entity_type, entity_id, description)
        VALUES (
            v_agent_id, 'client_policy_updated', 'client_policy', v_policy_id, 
            'Policy "' || p_policy_name || '" updated for client'
        );
    END IF;

    -- Return the policy ID
    RETURN QUERY SELECT v_policy_id, NULL::TEXT;
END;
$ LANGUAGE plpgsql;

-- Get Client Policies
CREATE OR REPLACE FUNCTION sp_get_client_policies(p_client_id UUID,
    p_status VARCHAR(20) DEFAULT NULL,
    p_type_id UUID DEFAULT NULL)
RETURNS TABLE (
    policy_id UUID,
    client_id UUID,
    policy_catalog_id UUID,
    policy_name VARCHAR(100),
    type_id UUID,
    type_name VARCHAR(100),
    company_id UUID,
    company_name VARCHAR(255),
    status VARCHAR(20),
    start_date DATE,
    end_date DATE,
    notes TEXT,
    created_date TIMESTAMP,
    modified_date TIMESTAMP,
    is_active BOOLEAN,
    days_until_expiry INTEGER,
    client_name TEXT,
    client_phone VARCHAR(20)
) AS $
BEGIN
    RETURN QUERY
    SELECT 
        cp.policy_id,
        cp.client_id,
        cp.policy_catalog_id,
        cp.policy_name,
        cp.type_id,
        pt.type_name,
        cp.company_id,
        ic.company_name,
        cp.status,
        cp.start_date,
        cp.end_date,
        cp.notes,
        cp.created_date,
        cp.modified_date,
        cp.is_active,
        (cp.end_date - CURRENT_DATE)::INTEGER AS days_until_expiry,
        (c.first_name || ' ' || c.surname)::TEXT AS client_name,
        c.phone_number AS  $$
client_phone
    FROM client_policies cp
    INNER JOIN clients c ON cp.client_id = c.client_id
    LEFT JOIN policy_type pt ON cp.type_id = pt.type_id
    LEFT JOIN insurance_company ic ON cp.company_id = ic.company_id
    WHERE 
        cp.client_id = p_client_id
        AND cp.is_active = true
        AND (p_status IS NULL OR cp.status = p_status)
        AND (p_type_id IS NULL OR cp.type_id = p_type_id)
    ORDER BY cp.start_date DESC
$$ LANGUAGE plpgsql;
END;
$ LANGUAGE plpgsql;

-- Create or Update Client
CREATE OR REPLACE FUNCTION sp_upsert_client(p_agent_id UUID,
    p_first_name VARCHAR(50),
    p_surname VARCHAR(50),
    p_last_name VARCHAR(50),
    p_phone_number VARCHAR(20),
    p_email VARCHAR(100),
    p_address VARCHAR(500),
    p_national_id VARCHAR(20),
    p_date_of_birth DATE,
    p_is_client BOOLEAN,
    p_client_id UUID DEFAULT NULL,
    p_notes TEXT DEFAULT NULL)
RETURNS TABLE (
    client_id UUID
) AS $$
DECLARE
    v_client_id UUID := COALESCE(p_client_id, gen_random_uuid());
    v_client_name TEXT := p_first_name || ' ' || p_surname;
BEGIN
    IF p_client_id IS NULL THEN
        -- Create new client
        INSERT INTO clients (
            client_id, agent_id, first_name, surname, last_name, phone_number, 
            email, address, national_id, date_of_birth, is_client, notes
        )
        VALUES (
            v_client_id, p_agent_id, p_first_name, p_surname, p_last_name, p_phone_number,
            p_email, p_address, p_national_id, p_date_of_birth, p_is_client, p_notes
        );
        
        -- Log activity
        INSERT INTO activity_log (agent_id, activity_type, entity_type, entity_id, description)
        VALUES (p_agent_id, 'client_created', 'client', v_client_id, 
                v_client_name || ' added as ' || CASE WHEN p_is_client THEN 'client' ELSE 'prospect' END);
    ELSE
        -- Update existing client
        v_client_id := p_client_id;
        
        UPDATE clients 
        SET 
            first_name = p_first_name,
            surname = p_surname,
            last_name = p_last_name,
            phone_number = p_phone_number,
            email = p_email,
            address = p_address,
            national_id = p_national_id,
            date_of_birth = p_date_of_birth,
            is_client = p_is_client,
            notes = p_notes,
            modified_date = NOW()
        WHERE clients.client_id = p_client_id;
        
        -- Log activity
        INSERT INTO activity_log (agent_id, activity_type, entity_type, entity_id, description)
        VALUES (p_agent_id, 'client_updated', 'client', v_client_id, v_client_name || ' updated');
    END IF;
    
    RETURN QUERY SELECT v_client_id;
END;
$ LANGUAGE plpgsql;

-- Get Clients
CREATE OR REPLACE FUNCTION sp_get_clients(p_agent_id UUID,
    p_search_term VARCHAR(100) DEFAULT NULL,
    p_filter_type VARCHAR(20) DEFAULT 'all',
    p_insurance_type VARCHAR(50) DEFAULT NULL)
RETURNS TABLE (
    client_id UUID,
    first_name VARCHAR(50),
    surname VARCHAR(50),
    last_name VARCHAR(50),
    phone_number VARCHAR(20),
    email VARCHAR(100),
    address VARCHAR(500),
    national_id VARCHAR(20),
    date_of_birth DATE,
    is_client BOOLEAN,
    insurance_type VARCHAR(50),
    notes TEXT,
    created_date TIMESTAMP,
    modified_date TIMESTAMP,
    policy_id UUID,
    policy_name VARCHAR(255),
    policy_type VARCHAR(100),
    policy_company VARCHAR(255),
    policy_status VARCHAR(20),
    policy_start_date DATE,
    policy_end_date DATE,
    policy_notes TEXT
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        c.client_id,
        c.first_name,
        c.surname,
        c.last_name,
        c.phone_number,
        c.email,
        c.address,
        c.national_id,
        c.date_of_birth,
        c.is_client,
        c.insurance_type,
        c.notes,
        c.created_date,
        c.modified_date,

        -- Policy Info from related tables
        cp.policy_id,
        cp.policy_name,
        pt.type_name AS policy_type,
        ic.company_name AS policy_company,
        cp.status AS policy_status,
        cp.start_date AS policy_start_date,
        cp.end_date AS policy_end_date,
        cp.notes AS policy_notes
    FROM clients c
    LEFT JOIN client_policies cp 
        ON c.client_id = cp.client_id AND cp.is_active = true
    LEFT JOIN policy_catalog pc
        ON cp.policy_catalog_id = pc.policy_catalog_id
    LEFT JOIN policy_types pt
        ON pc.type_id = pt.type_id
    LEFT JOIN insurance_companies ic
        ON pc.company_id = ic.company_id
    WHERE 
        c.agent_id = p_agent_id 
        AND c.is_active = true
        AND (
            p_search_term IS NULL OR 
            c.first_name ILIKE '%' || p_search_term || '%' OR
            c.surname ILIKE '%' || p_search_term || '%' OR
            c.last_name ILIKE '%' || p_search_term || '%' OR
            c.phone_number ILIKE '%' || p_search_term || '%' OR
            c.email ILIKE '%' || p_search_term || '%'
        )
        AND (
            p_filter_type = 'all' OR 
            (p_filter_type = 'clients' AND c.is_client = true) OR
            (p_filter_type = 'prospects' AND c.is_client = false)
        )
        AND (p_insurance_type IS NULL OR c.insurance_type = p_insurance_type)
    ORDER BY c.first_name, c.surname;
END;
$ LANGUAGE plpgsql;

-- Get Client
CREATE OR REPLACE FUNCTION sp_get_client(p_client_id UUID,
    p_agent_id UUID)
RETURNS TABLE (
    -- Client details
    client_id UUID,
    agent_id UUID,
    first_name VARCHAR(50),
    surname VARCHAR(50),
    last_name VARCHAR(50),
    phone_number VARCHAR(20),
    email VARCHAR(100),
    address VARCHAR(500),
    national_id VARCHAR(20),
    date_of_birth DATE,
    is_client BOOLEAN,
    insurance_type VARCHAR(50),
    notes TEXT,
    created_date TIMESTAMP,
    modified_date TIMESTAMP,
    is_active BOOLEAN,
    -- Policy details
    policy_id UUID,
    policy_name VARCHAR(255),
    policy_type VARCHAR(100),
    policy_company VARCHAR(255),
    policy_status VARCHAR(20),
    policy_start_date DATE,
    policy_end_date DATE,
    policy_notes TEXT
) AS $$
BEGIN
    -- Main client details with linked policy info
    RETURN QUERY
    SELECT 
        c.client_id,
        c.agent_id,
        c.first_name,
        c.surname,
        c.last_name,
        c.phone_number,
        c.email,
        c.address,
        c.national_id,
        c.date_of_birth,
        c.is_client,
        c.insurance_type,
        c.notes,
        c.created_date,
        c.modified_date,
        c.is_active,
        cp.policy_id,
        cp.policy_name,
        pt.type_name AS policy_type,
        ic.company_name AS policy_company,
        cp.status AS policy_status,
        cp.start_date AS policy_start_date,
        cp.end_date AS policy_end_date,
        cp.notes AS policy_notes
    FROM clients c
    LEFT JOIN client_policies cp 
        ON c.client_id = cp.client_id AND cp.is_active = true
    LEFT JOIN policy_catalog pc 
        ON cp.policy_catalog_id = pc.policy_catalog_id
    LEFT JOIN policy_types pt 
        ON pc.type_id = pt.type_id
    LEFT JOIN insurance_companies ic 
        ON pc.company_id = ic.company_id
    WHERE 
        c.client_id = p_client_id 
        AND c.agent_id = p_agent_id 
        AND c.is_active = true;
END;
$ LANGUAGE plpgsql;

-- Get Client Appointments (separate function since PostgreSQL functions can only return one result set)
CREATE OR REPLACE FUNCTION sp_get_client_appointments(p_client_id UUID,
    p_agent_id UUID)
RETURNS TABLE (
    appointment_id UUID,
    title VARCHAR(255),
    appointment_date DATE,
    start_time TIME,
    end_time TIME,
    type VARCHAR(50),
    status VARCHAR(20),
    location VARCHAR(255)
) AS $
BEGIN
    -- Appointments for the client
    RETURN QUERY
    SELECT 
        a.appointment_id,
        a.title,
        a.appointment_date,
        a.start_time,
        a.end_time,
        a.type,
        a.status,
        a.location
    FROM appointments a
    WHERE 
        a.client_id = p_client_id 
        AND a.agent_id = p_agent_id 
        AND a.is_active = true
    ORDER BY a.appointment_date DESC, a.start_time DESC;
END;
$ LANGUAGE plpgsql;

-- Delete Client
CREATE OR REPLACE FUNCTION sp_delete_client(p_client_id UUID,
    p_agent_id UUID)
RETURNS TABLE (
    rows_affected INTEGER
) AS $
DECLARE
    v_client_name TEXT;
    v_rows_affected INTEGER;
BEGIN
    -- Get client name for logging
    SELECT first_name || ' ' || surname INTO v_client_name 
    FROM clients WHERE client_id = p_client_id;
    
    -- Soft delete - set is_active to false
    UPDATE clients 
    SET is_active = false, modified_date = NOW()
    WHERE client_id = p_client_id AND agent_id = p_agent_id;
    
    GET DIAGNOSTICS v_rows_affected = ROW_COUNT;
    
    -- Also soft delete related appointments
    UPDATE appointments 
    SET is_active = false, modified_date = NOW()
    WHERE client_id = p_client_id AND agent_id = p_agent_id;
    
    -- Log activity
    INSERT INTO activity_log (agent_id, activity_type, entity_type, entity_id, description)
    VALUES (p_agent_id, 'client_deleted', 'client', p_client_id, v_client_name || ' deleted');
    
    RETURN QUERY SELECT v_rows_affected;
END;
$ LANGUAGE plpgsql;

-- ============================================
-- PostgreSQL Stored Procedures for Policy Management
-- Converted from SQL Server format
-- ============================================

-- Create Client Policy (using PolicyCatalog)
CREATE OR REPLACE FUNCTION sp_CreateClientPolicy(p_client_id UUID,
    p_policy_catalog_id UUID,
    p_start_date DATE,
    p_end_date DATE,
    p_status VARCHAR(20) DEFAULT 'Active',
    p_notes TEXT DEFAULT NULL)
RETURNS TABLE(policy_id UUID, error_message TEXT)
LANGUAGE plpgsql
AS $$
DECLARE
    v_policy_id UUID := gen_random_uuid();
    v_policy_name VARCHAR(100);
    v_type_id UUID;
    v_company_id UUID;
    v_agent_id UUID;
BEGIN
    -- Get policy details from PolicyCatalog
    SELECT 
        pc.policy_name,
        pc.type_id,
        pc.company_id
    INTO v_policy_name, v_type_id, v_company_id
    FROM policy_catalog pc
    WHERE pc.policy_catalog_id = p_policy_catalog_id AND pc.is_active = true;

    IF v_policy_name IS NULL THEN
        RETURN QUERY SELECT NULL::UUID, 'Policy Catalog item not found or inactive'::TEXT;
        RETURN;
    END IF;

    -- Get agent ID
    SELECT agent_id INTO v_agent_id FROM clients WHERE client_id = p_client_id;

    INSERT INTO client_policies (
        policy_id, client_id, policy_catalog_id, policy_name, type_id, company_id, 
        status, start_date, end_date, notes, is_active, created_date
    )
    VALUES (
        v_policy_id, p_client_id, p_policy_catalog_id, v_policy_name, v_type_id, v_company_id,
        p_status, p_start_date, p_end_date, p_notes, true, NOW() AT TIME ZONE 'UTC'
    );
    
    -- Log activity
    INSERT INTO activity_log (agent_id, activity_type, entity_type, entity_id, description)
    VALUES (
        v_agent_id, 'client_policy_created', 'client_policy', v_policy_id, 
        'Policy "' || v_policy_name || '" assigned to client from catalog'
    );
    
    RETURN QUERY SELECT v_policy_id, NULL::TEXT;
END;
$;

-- Get Expiring Policies
CREATE OR REPLACE FUNCTION sp_GetExpiringPolicies(p_agent_id UUID,
    p_days_ahead INTEGER DEFAULT 30)
RETURNS TABLE(
    policy_id UUID,
    client_id UUID,
    policy_name VARCHAR(100),
    type_name VARCHAR(100),
    company_name VARCHAR(100),
    status VARCHAR(20),
    start_date DATE,
    end_date DATE,
    notes TEXT,
    client_name TEXT,
    client_phone VARCHAR(20),
    client_email VARCHAR(100),
    days_until_expiry INTEGER
)
LANGUAGE plpgsql
AS $
DECLARE
    v_start_date DATE := CURRENT_DATE;
    v_end_date DATE := CURRENT_DATE + INTERVAL '1 day' * p_days_ahead;
BEGIN
    RETURN QUERY
    SELECT 
        cp.policy_id,
        cp.client_id,
        cp.policy_name,
        pt.type_name,
        ic.company_name,
        cp.status,
        cp.start_date,
        cp.end_date,
        cp.notes,
        (c.first_name || ' ' || c.surname)::TEXT AS client_name,
        c.phone_number,
        c.email,
        (cp.end_date - v_start_date)::INTEGER AS days_until_expiry
    FROM client_policies cp
    INNER JOIN clients c ON cp.client_id = c.client_id
    LEFT JOIN policy_type pt ON cp.type_id = pt.type_id
    LEFT JOIN insurance_company ic ON cp.company_id = ic.company_id
    WHERE 
        c.agent_id = p_agent_id 
        AND cp.status = 'Active'
        AND cp.is_active = true
        AND c.is_active = true
        AND cp.end_date BETWEEN v_start_date AND v_end_date
    ORDER BY cp.end_date ASC;
END;
$;

-- Get Insurance Companies
CREATE OR REPLACE FUNCTION sp_GetInsuranceCompanies(p_is_active BOOLEAN DEFAULT true)
RETURNS TABLE(
    company_id UUID,
    company_name VARCHAR(100),
    is_active BOOLEAN,
    created_date TIMESTAMP
)
LANGUAGE plpgsql
AS $
BEGIN
    RETURN QUERY
    SELECT 
        ic.company_id,
        ic.company_name,
        ic.is_active,
        ic.created_date
    FROM insurance_company ic
    WHERE (p_is_active IS NULL OR ic.is_active = p_is_active)
    ORDER BY ic.company_name ASC;
END;
$;

-- Get Policy Types
CREATE OR REPLACE FUNCTION sp_GetPolicyTypes(p_is_active BOOLEAN DEFAULT true)
RETURNS TABLE(
    type_id UUID,
    type_name VARCHAR(100),
    is_active BOOLEAN,
    created_date TIMESTAMP
)
LANGUAGE plpgsql
AS $
BEGIN
    RETURN QUERY
    SELECT 
        pt.type_id,
        pt.type_name,
        pt.is_active,
        pt.created_date
    FROM policy_type pt
    WHERE (p_is_active IS NULL OR pt.is_active = p_is_active)
    ORDER BY pt.type_name ASC;
END;
$;

-- Get Policy Categories
CREATE OR REPLACE FUNCTION sp_GetPolicyCategories(p_is_active BOOLEAN DEFAULT true)
RETURNS TABLE(
    category_id UUID,
    category_name VARCHAR(100),
    description TEXT,
    is_active BOOLEAN,
    created_date TIMESTAMP
)
LANGUAGE plpgsql
AS $
BEGIN
    RETURN QUERY
    SELECT 
        pc.category_id,
        pc.category_name,
        pc.description,
        pc.is_active,
        pc.created_date
    FROM policy_category pc
    WHERE (p_is_active IS NULL OR pc.is_active = p_is_active)
    ORDER BY pc.category_name ASC;
END;
$;

-- Validate Policy Data
CREATE OR REPLACE FUNCTION sp_ValidatePolicyData(p_policy_name VARCHAR(100),
    p_type_id UUID,
    p_company_id UUID DEFAULT NULL,
    p_start_date DATE DEFAULT NULL,
    p_end_date DATE DEFAULT NULL)
RETURNS TABLE(is_valid BOOLEAN, validation_errors TEXT)
LANGUAGE plpgsql
AS $$
DECLARE
    v_is_valid BOOLEAN := true;
    v_validation_errors TEXT := '';
BEGIN
    -- Validate Policy Name
    IF p_policy_name IS NULL OR LENGTH(TRIM(p_policy_name)) = 0 THEN
        v_is_valid := false;
        v_validation_errors := v_validation_errors || 'Policy name is required. ';
    END IF;
    
    -- Validate Policy Type ID
    IF p_type_id IS NULL OR NOT EXISTS (
        SELECT 1 FROM policy_type WHERE type_id = p_type_id AND is_active = true
    ) THEN
        v_is_valid := false;
        v_validation_errors := v_validation_errors || 'Valid policy type is required. ';
    END IF;
    
    -- Validate Company
    IF p_company_id IS NOT NULL AND NOT EXISTS (
        SELECT 1 FROM insurance_company WHERE company_id = p_company_id AND is_active = true
    ) THEN
        v_is_valid := false;
        v_validation_errors := v_validation_errors || 'Valid insurance company is required. ';
    END IF;
    
    -- Validate Dates
    IF p_start_date IS NOT NULL AND p_end_date IS NOT NULL AND p_start_date >= p_end_date THEN
        v_is_valid := false;
        v_validation_errors := v_validation_errors || 'End date must be after start date. ';
    END IF;
    
    RETURN QUERY SELECT v_is_valid, RTRIM(v_validation_errors);
END;
$;

-- Get Policy Statistics
CREATE OR REPLACE FUNCTION sp_GetPolicyStatistics(p_agent_id UUID)
RETURNS TABLE(
    active_policies BIGINT,
    expired_policies BIGINT,
    lapsed_policies BIGINT,
    expiring_policies BIGINT,
    policy_types BIGINT,
    insurance_companies BIGINT
)
LANGUAGE plpgsql
AS $
BEGIN
    RETURN QUERY
    SELECT 
        COUNT(CASE WHEN cp.status = 'Active' THEN 1 END) AS active_policies,
        COUNT(CASE WHEN cp.status = 'Expired' THEN 1 END) AS expired_policies,
        COUNT(CASE WHEN cp.status = 'Lapsed' THEN 1 END) AS lapsed_policies,
        COUNT(CASE WHEN cp.end_date BETWEEN CURRENT_DATE AND CURRENT_DATE + INTERVAL '30 days' THEN 1 END) AS expiring_policies,
        COUNT(DISTINCT pt.type_id) AS policy_types,
        COUNT(DISTINCT ic.company_id) AS insurance_companies
    FROM client_policies cp
    INNER JOIN clients c ON cp.client_id = c.client_id
    LEFT JOIN policy_type pt ON cp.type_id = pt.type_id
    LEFT JOIN insurance_company ic ON cp.company_id = ic.company_id
    WHERE c.agent_id = p_agent_id AND cp.is_active = true AND c.is_active = true;
END;
$;

-- Create Policy Template
CREATE OR REPLACE FUNCTION sp_CreatePolicyTemplate(p_agent_id UUID,
    p_template_name VARCHAR(100),
    p_type_id UUID,
    p_default_term_months INTEGER DEFAULT NULL,
    p_default_premium DECIMAL(18,2) DEFAULT NULL,
    p_coverage_description TEXT DEFAULT NULL,
    p_terms TEXT DEFAULT NULL,
    p_category_id UUID DEFAULT NULL)
RETURNS TABLE(template_id UUID)
LANGUAGE plpgsql
AS $$
DECLARE
    v_template_id UUID := gen_random_uuid();
BEGIN
    INSERT INTO policy_template (
        template_id, agent_id, template_name, type_id, category_id,
        default_term_months, default_premium, coverage_description, terms
    )
    VALUES (
        v_template_id, p_agent_id, p_template_name, p_type_id, p_category_id,
        p_default_term_months, p_default_premium, p_coverage_description, p_terms
    );
    
    INSERT INTO activity_log (agent_id, activity_type, entity_type, entity_id, description)
    VALUES (
        p_agent_id, 'policy_template_created', 'policy_template', v_template_id, 
        'Policy template "' || p_template_name || '" created'
    );

    RETURN QUERY SELECT v_template_id;
END;
$;

-- Get Policy Templates
CREATE OR REPLACE FUNCTION sp_GetPolicyTemplates(p_agent_id UUID,
    p_type_id UUID DEFAULT NULL)
RETURNS TABLE(
    template_id UUID,
    template_name VARCHAR(100),
    type_id UUID,
    type_name VARCHAR(100),
    default_term_months INTEGER,
    default_premium DECIMAL(18,2),
    coverage_description TEXT,
    terms TEXT,
    category_id UUID,
    category_name VARCHAR(100),
    created_date TIMESTAMP
)
LANGUAGE plpgsql
AS $
BEGIN
    RETURN QUERY
    SELECT 
        pt.template_id,
        pt.template_name,
        pt.type_id,
        ptype.type_name,
        pt.default_term_months,
        pt.default_premium,
        pt.coverage_description,
        pt.terms,
        pt.category_id,
        pc.category_name,
        pt.created_date
    FROM policy_template pt
    LEFT JOIN policy_type ptype ON pt.type_id = ptype.type_id
    LEFT JOIN policy_category pc ON pt.category_id = pc.category_id
    WHERE 
        pt.agent_id = p_agent_id 
        AND pt.is_active = true
        AND (p_type_id IS NULL OR pt.type_id = p_type_id)
    ORDER BY ptype.type_name, pt.template_name;
END;
$;
-- ============================================
-- PostgreSQL Stored Procedures for Policy Management
-- Converted from SQL Server format
-- ============================================

-- Create Client Policy (using PolicyCatalog)
CREATE OR REPLACE FUNCTION sp_CreateClientPolicy(p_client_id UUID,
    p_policy_catalog_id UUID,
    p_start_date DATE,
    p_end_date DATE,
    p_status VARCHAR(20) DEFAULT 'Active',
    p_notes TEXT DEFAULT NULL)
RETURNS TABLE(policy_id UUID, error_message TEXT)
LANGUAGE plpgsql
AS $$
DECLARE
    v_policy_id UUID := gen_random_uuid();
    v_policy_name VARCHAR(100);
    v_type_id UUID;
    v_company_id UUID;
    v_agent_id UUID;
BEGIN
    -- Get policy details from PolicyCatalog
    SELECT 
        pc.policy_name,
        pc.type_id,
        pc.company_id
    INTO v_policy_name, v_type_id, v_company_id
    FROM policy_catalog pc
    WHERE pc.policy_catalog_id = p_policy_catalog_id AND pc.is_active = true;

    IF v_policy_name IS NULL THEN
        RETURN QUERY SELECT NULL::UUID, 'Policy Catalog item not found or inactive'::TEXT;
        RETURN;
    END IF;

    -- Get agent ID
    SELECT agent_id INTO v_agent_id FROM clients WHERE client_id = p_client_id;

    INSERT INTO client_policies (
        policy_id, client_id, policy_catalog_id, policy_name, type_id, company_id, 
        status, start_date, end_date, notes, is_active, created_date
    )
    VALUES (
        v_policy_id, p_client_id, p_policy_catalog_id, v_policy_name, v_type_id, v_company_id,
        p_status, p_start_date, p_end_date, p_notes, true, NOW() AT TIME ZONE 'UTC'
    );
    
    -- Log activity
    INSERT INTO activity_log (agent_id, activity_type, entity_type, entity_id, description)
    VALUES (
        v_agent_id, 'client_policy_created', 'client_policy', v_policy_id, 
        'Policy "' || v_policy_name || '" assigned to client from catalog'
    );
    
    RETURN QUERY SELECT v_policy_id, NULL::TEXT;
END;
$;

-- Delete Policy Template
CREATE OR REPLACE FUNCTION sp_DeletePolicyTemplate(p_template_id UUID,
    p_agent_id UUID)
RETURNS TABLE(rows_affected INTEGER)
LANGUAGE plpgsql
AS $
 $
DECLARE
    v_rows_affected INTEGER;
BEGIN
    UPDATE policy_template 
    SET is_active = false
    WHERE template_id = p_template_id AND agent_id = p_agent_id;
    
    GET DIAGNOSTICS v_rows_affected = ROW_COUNT;
    
    IF v_rows_affected > 0 THEN
        INSERT INTO activity_log (agent_id, activity_type, entity_type, entity_id, description)
        VALUES (
            p_agent_id, 'policy_template_deleted', 'policy_template', p_template_id, 
            'Policy template deleted'
        );
    END IF;
    
    RETURN QUERY SELECT v_rows_affected;
END;
$;

-- Get Policy Catalog for Agent
CREATE OR REPLACE FUNCTION sp_GetPolicyCatalog(p_agent_id UUID,
    p_type_id UUID DEFAULT NULL,
    p_company_id UUID DEFAULT NULL)
RETURNS TABLE(
    policy_catalog_id UUID,
    policy_name VARCHAR(100),
    type_id UUID,
    type_name VARCHAR(100),
    company_id UUID,
    company_name VARCHAR(100),
    category_id UUID,
    category_name VARCHAR(100),
    notes TEXT,
    created_date TIMESTAMP,
    modified_date TIMESTAMP
)
LANGUAGE plpgsql
AS $
 $
BEGIN
    RETURN QUERY
    SELECT 
        pc.policy_catalog_id,
        pc.policy_name,
        pc.type_id,
        pt.type_name,
        pc.company_id,
        ic.company_name,
        pc.category_id,
        pcat.category_name,
        pc.notes,
        pc.created_date,
        pc.modified_date
    FROM policy_catalog pc
    LEFT JOIN policy_type pt ON pc.type_id = pt.type_id
    LEFT JOIN insurance_company ic ON pc.company_id = ic.company_id
    LEFT JOIN policy_category pcat ON pc.category_id = pcat.category_id
    WHERE 
        pc.agent_id = p_agent_id 
        AND pc.is_active = true
        AND (p_type_id IS NULL OR pc.type_id = p_type_id)
        AND (p_company_id IS NULL OR pc.company_id = p_company_id)
    ORDER BY pt.type_name, pc.policy_name;
END;
$;

-- Create Policy Catalog Item
CREATE OR REPLACE FUNCTION sp_CreatePolicyCatalogItem(p_agent_id UUID,
    p_policy_name VARCHAR(100),
    p_type_id UUID,
    p_company_id UUID DEFAULT NULL,
    p_category_id UUID DEFAULT NULL,
    p_notes TEXT DEFAULT NULL)
RETURNS TABLE(policy_catalog_id UUID, error_message TEXT)
LANGUAGE plpgsql
AS $
DECLARE
    v_policy_catalog_id UUID := gen_random_uuid();
BEGIN
    -- Validate TypeId exists
    IF NOT EXISTS (SELECT 1 FROM policy_type WHERE type_id = p_type_id AND is_active = true) THEN
        RETURN QUERY SELECT NULL::UUID, 'Policy type not found or inactive'::TEXT;
        RETURN;
    END IF;
    
    -- Validate CompanyId if provided
    IF p_company_id IS NOT NULL AND NOT EXISTS (
        SELECT 1 FROM insurance_company WHERE company_id = p_company_id AND is_active = true
    ) THEN
        RETURN QUERY SELECT NULL::UUID, 'Insurance company not found or inactive'::TEXT;
        RETURN;
    END IF;
    
    INSERT INTO policy_catalog (
        policy_catalog_id, agent_id, policy_name, type_id, 
        company_id, category_id, notes, is_active, created_date
    )
    VALUES (
        v_policy_catalog_id, p_agent_id, p_policy_name, p_type_id, 
        p_company_id, p_category_id, p_notes, true, NOW() AT TIME ZONE 'UTC'
    );
    
    INSERT INTO activity_log (agent_id, activity_type, entity_type, entity_id, description)
    VALUES (p_agent_id, 'policy_catalog_created', 'policy_catalog', v_policy_catalog_id, 
            'Policy "' || p_policy_name || '" added to catalog');
    
    RETURN QUERY SELECT v_policy_catalog_id, NULL::TEXT;
END;
$;

-- Update Policy Catalog Item
CREATE OR REPLACE FUNCTION sp_UpdatePolicyCatalogItem(p_policy_catalog_id UUID,
    p_agent_id UUID,
    p_policy_name VARCHAR(100) DEFAULT NULL,
    p_type_id UUID DEFAULT NULL,
    p_company_id UUID DEFAULT NULL,
    p_category_id UUID DEFAULT NULL,
    p_notes TEXT DEFAULT NULL,
    p_is_active BOOLEAN DEFAULT NULL)
RETURNS TABLE(rows_affected INTEGER, error_message TEXT)
LANGUAGE plpgsql
AS $
DECLARE
    v_rows_affected INTEGER;
BEGIN
    -- Validate TypeId if provided
    IF p_type_id IS NOT NULL AND NOT EXISTS (
        SELECT 1 FROM policy_type WHERE type_id = p_type_id AND is_active = true
    ) THEN
        RETURN QUERY SELECT 0, 'Policy type not found or inactive'::TEXT;
        RETURN;
    END IF;
    
    -- Validate CompanyId if provided
    IF p_company_id IS NOT NULL AND NOT EXISTS (
        SELECT 1 FROM insurance_company WHERE company_id = p_company_id AND is_active = true
    ) THEN
        RETURN QUERY SELECT 0, 'Insurance company not found or inactive'::TEXT;
        RETURN;
    END IF;
    
    UPDATE policy_catalog 
    SET 
        policy_name = COALESCE(p_policy_name, policy_name),
        type_id = COALESCE(p_type_id, type_id),
        company_id = COALESCE(p_company_id, company_id),
        category_id = COALESCE(p_category_id, category_id),
        notes = COALESCE(p_notes, notes),
        is_active = COALESCE(p_is_active, is_active),
        modified_date = NOW() AT TIME ZONE 'UTC'
    WHERE policy_catalog_id = p_policy_catalog_id 
      AND agent_id = p_agent_id;
    
    GET DIAGNOSTICS v_rows_affected = ROW_COUNT;
    
    IF v_rows_affected > 0 THEN
        INSERT INTO activity_log (agent_id, activity_type, entity_type, entity_id, description)
        VALUES (p_agent_id, 'policy_catalog_updated', 'policy_catalog', p_policy_catalog_id, 
                'Policy catalog item updated');
    END IF;
    
    RETURN QUERY SELECT v_rows_affected, NULL::TEXT;
END;
$;

-- Delete Policy from Catalog
CREATE OR REPLACE FUNCTION sp_DeletePolicyCatalog(p_policy_catalog_id UUID,
    p_agent_id UUID)
RETURNS TABLE(rows_affected INTEGER)
LANGUAGE plpgsql
AS $
 $
DECLARE
    v_policy_name VARCHAR(100);
    v_rows_affected INTEGER;
BEGIN
    -- Get policy name for logging
    SELECT policy_name INTO v_policy_name 
    FROM policy_catalog 
    WHERE policy_catalog_id = p_policy_catalog_id;
    
    -- Soft delete
    UPDATE policy_catalog 
    SET is_active = false, modified_date = NOW() AT TIME ZONE 'UTC'
    WHERE policy_catalog_id = p_policy_catalog_id AND agent_id = p_agent_id;
    
    GET DIAGNOSTICS v_rows_affected = ROW_COUNT;
    
    -- Log activity
    IF v_rows_affected > 0 AND v_policy_name IS NOT NULL THEN
        INSERT INTO activity_log (agent_id, activity_type, entity_type, entity_id, description)
        VALUES (p_agent_id, 'policy_catalog_deleted', 'policy_catalog', p_policy_catalog_id, 
                'Policy "' || v_policy_name || '" removed from catalog');
    END IF;
    
    RETURN QUERY SELECT v_rows_affected;
END;
$;

-- Create or Update Client Policy
CREATE OR REPLACE FUNCTION sp_UpsertClientPolicy(p_client_id UUID,
    p_policy_name VARCHAR(100),
    p_type_id UUID,
    p_status VARCHAR(20),
    p_start_date DATE,
    p_end_date DATE,
    p_policy_id UUID DEFAULT NULL,
    p_company_id UUID DEFAULT NULL,
    p_policy_catalog_id UUID DEFAULT NULL,
    p_notes TEXT DEFAULT NULL)
RETURNS TABLE(policy_id UUID, error_message TEXT)
LANGUAGE plpgsql
AS $
DECLARE
    v_agent_id UUID;
    v_policy_id UUID := p_policy_id;
BEGIN
    -- Get agent ID from client
    SELECT agent_id INTO v_agent_id FROM clients WHERE client_id = p_client_id;

    -- Validate TypeId
    IF NOT EXISTS (SELECT 1 FROM policy_type WHERE type_id = p_type_id AND is_active = true) THEN
        RETURN QUERY SELECT NULL::UUID, 'Policy type not found or inactive'::TEXT;
        RETURN;
    END IF;

    -- Validate CompanyId if provided
    IF p_company_id IS NOT NULL AND NOT EXISTS (
        SELECT 1 FROM insurance_company WHERE company_id = p_company_id AND is_active = true
    ) THEN
        RETURN QUERY SELECT NULL::UUID, 'Insurance company not found or inactive'::TEXT;
        RETURN;
    END IF;

    IF v_policy_id IS NULL THEN
        -- Create new client policy
        v_policy_id := gen_random_uuid();

        INSERT INTO client_policies (
            policy_id, client_id, policy_name, type_id, company_id, policy_catalog_id,
            status, start_date, end_date, notes
        )
        VALUES (
            v_policy_id, p_client_id, p_policy_name, p_type_id, p_company_id, p_policy_catalog_id,
            p_status, p_start_date, p_end_date, p_notes
        );

        -- Log activity
        INSERT INTO activity_log (agent_id, activity_type, entity_type, entity_id, description)
        VALUES (
            v_agent_id, 'client_policy_created', 'client_policy', v_policy_id, 
            'Policy "' || p_policy_name || '" assigned to client'
        );
    ELSE
        -- Update existing client policy
        UPDATE client_policies 
        SET 
            policy_name = p_policy_name,
            type_id = p_type_id,
            company_id = p_company_id,
            policy_catalog_id = p_policy_catalog_id,
            status = p_status,
            start_date = p_start_date,
            end_date = p_end_date,
            notes = p_notes,
            modified_date = NOW() AT TIME ZONE 'UTC'
        WHERE policy_id = v_policy_id;

        -- Log activity
        INSERT INTO activity_log (agent_id, activity_type, entity_type, entity_id, description)
        VALUES (
            v_agent_id, 'client_policy_updated', 'client_policy', v_policy_id, 
            'Policy "' || p_policy_name || '" updated for client'
        );
    END IF;

    -- Return the policy ID
    RETURN QUERY SELECT v_policy_id, NULL::TEXT;
END;
$;

-- Get Client Policies
CREATE OR REPLACE FUNCTION sp_GetClientPolicies(p_client_id UUID,
    p_status VARCHAR(20) DEFAULT NULL,
    p_type_id UUID DEFAULT NULL)
RETURNS TABLE(
    policy_id UUID,
    client_id UUID,
    policy_catalog_id UUID,
    policy_name VARCHAR(100),
    type_id UUID,
    type_name VARCHAR(100),
    company_id UUID,
    company_name VARCHAR(100),
    status VARCHAR(20),
    start_date DATE,
    end_date DATE,
    notes TEXT,
    created_date TIMESTAMP,
    modified_date TIMESTAMP,
    is_active BOOLEAN,
    days_until_expiry INTEGER,
    client_name TEXT,
    client_phone VARCHAR(20)
)
LANGUAGE plpgsql
AS $
BEGIN
    RETURN QUERY
    SELECT 
        cp.policy_id,
        cp.client_id,
        cp.policy_catalog_id,
        cp.policy_name,
        cp.type_id,
        pt.type_name,
        cp.company_id,
        ic.company_name,
        cp.status,
        cp.start_date,
        cp.end_date,
        cp.notes,
        cp.created_date,
        cp.modified_date,
        cp.is_active,
        (cp.end_date - CURRENT_DATE)::INTEGER AS days_until_expiry,
        (c.first_name || ' ' || c.surname)::TEXT AS  $$
client_name,
        c.phone_number
    FROM client_policies cp
    INNER JOIN clients c ON cp.client_id = c.client_id
    LEFT JOIN policy_type pt ON cp.type_id = pt.type_id
    LEFT JOIN insurance_company ic ON cp.company_id = ic.company_id
    WHERE 
        cp.client_id = p_client_id
        AND cp.is_active = true
        AND (p_status IS NULL OR cp.status = p_status)
        AND (p_type_id IS NULL OR cp.type_id = p_type_id)
    ORDER BY cp.start_date DESC
$$ LANGUAGE plpgsql;
END;
$;

-- Get Expiring Policies
CREATE OR REPLACE FUNCTION sp_GetExpiringPolicies(p_agent_id UUID,
    p_days_ahead INTEGER DEFAULT 30)
RETURNS TABLE(
    policy_id UUID,
    client_id UUID,
    policy_name VARCHAR(100),
    type_name VARCHAR(100),
    company_name VARCHAR(100),
    status VARCHAR(20),
    start_date DATE,
    end_date DATE,
    notes TEXT,
    client_name TEXT,
    client_phone VARCHAR(20),
    client_email VARCHAR(100),
    days_until_expiry INTEGER
)
LANGUAGE plpgsql
AS $
DECLARE
    v_start_date DATE := CURRENT_DATE;
    v_end_date DATE := CURRENT_DATE + INTERVAL '1 day' * p_days_ahead;
BEGIN
    RETURN QUERY
    SELECT 
        cp.policy_id,
        cp.client_id,
        cp.policy_name,
        pt.type_name,
        ic.company_name,
        cp.status,
        cp.start_date,
        cp.end_date,
        cp.notes,
        (c.first_name || ' ' || c.surname)::TEXT AS client_name,
        c.phone_number,
        c.email,
        (cp.end_date - v_start_date)::INTEGER AS days_until_expiry
    FROM client_policies cp
    INNER JOIN clients c ON cp.client_id = c.client_id
    LEFT JOIN policy_type pt ON cp.type_id = pt.type_id
    LEFT JOIN insurance_company ic ON cp.company_id = ic.company_id
    WHERE 
        c.agent_id = p_agent_id 
        AND cp.status = 'Active'
        AND cp.is_active = true
        AND c.is_active = true
        AND cp.end_date BETWEEN v_start_date AND v_end_date
    ORDER BY cp.end_date ASC;
END;
$;

-- Get Insurance Companies
CREATE OR REPLACE FUNCTION sp_GetInsuranceCompanies(p_is_active BOOLEAN DEFAULT true)
RETURNS TABLE(
    company_id UUID,
    company_name VARCHAR(100),
    is_active BOOLEAN,
    created_date TIMESTAMP
)
LANGUAGE plpgsql
AS $
BEGIN
    RETURN QUERY
    SELECT 
        ic.company_id,
        ic.company_name,
        ic.is_active,
        ic.created_date
    FROM insurance_company ic
    WHERE (p_is_active IS NULL OR ic.is_active = p_is_active)
    ORDER BY ic.company_name ASC;
END;
$;

-- Get Policy Types
CREATE OR REPLACE FUNCTION sp_GetPolicyTypes(p_is_active BOOLEAN DEFAULT true)
RETURNS TABLE(
    type_id UUID,
    type_name VARCHAR(100),
    is_active BOOLEAN,
    created_date TIMESTAMP
)
LANGUAGE plpgsql
AS $
BEGIN
    RETURN QUERY
    SELECT 
        pt.type_id,
        pt.type_name,
        pt.is_active,
        pt.created_date
    FROM policy_type pt
    WHERE (p_is_active IS NULL OR pt.is_active = p_is_active)
    ORDER BY pt.type_name ASC;
END;
$;

-- Get Policy Categories
CREATE OR REPLACE FUNCTION sp_GetPolicyCategories(p_is_active BOOLEAN DEFAULT true)
RETURNS TABLE(
    category_id UUID,
    category_name VARCHAR(100),
    description TEXT,
    is_active BOOLEAN,
    created_date TIMESTAMP
)
LANGUAGE plpgsql
AS $
BEGIN
    RETURN QUERY
    SELECT 
        pc.category_id,
        pc.category_name,
        pc.description,
        pc.is_active,
        pc.created_date
    FROM policy_category pc
    WHERE (p_is_active IS NULL OR pc.is_active = p_is_active)
    ORDER BY pc.category_name ASC;
END;
$;

-- Validate Policy Data
CREATE OR REPLACE FUNCTION sp_ValidatePolicyData(p_policy_name VARCHAR(100),
    p_type_id UUID,
    p_company_id UUID DEFAULT NULL,
    p_start_date DATE DEFAULT NULL,
    p_end_date DATE DEFAULT NULL)
RETURNS TABLE(is_valid BOOLEAN, validation_errors TEXT)
LANGUAGE plpgsql
AS $$
DECLARE
    v_is_valid BOOLEAN := true;
    v_validation_errors TEXT := '';
BEGIN
    -- Validate Policy Name
    IF p_policy_name IS NULL OR LENGTH(TRIM(p_policy_name)) = 0 THEN
        v_is_valid := false;
        v_validation_errors := v_validation_errors || 'Policy name is required. ';
    END IF;
    
    -- Validate Policy Type ID
    IF p_type_id IS NULL OR NOT EXISTS (
        SELECT 1 FROM policy_type WHERE type_id = p_type_id AND is_active = true
    ) THEN
        v_is_valid := false;
        v_validation_errors := v_validation_errors || 'Valid policy type is required. ';
    END IF;
    
    -- Validate Company
    IF p_company_id IS NOT NULL AND NOT EXISTS (
        SELECT 1 FROM insurance_company WHERE company_id = p_company_id AND is_active = true
    ) THEN
        v_is_valid := false;
        v_validation_errors := v_validation_errors || 'Valid insurance company is required. ';
    END IF;
    
    -- Validate Dates
    IF p_start_date IS NOT NULL AND p_end_date IS NOT NULL AND p_start_date >= p_end_date THEN
        v_is_valid := false;
        v_validation_errors := v_validation_errors || 'End date must be after start date. ';
    END IF;
    
    RETURN QUERY SELECT v_is_valid, RTRIM(v_validation_errors);
END;
$;

-- Get Policy Statistics
CREATE OR REPLACE FUNCTION sp_GetPolicyStatistics(p_agent_id UUID)
RETURNS TABLE(
    active_policies BIGINT,
    expired_policies BIGINT,
    lapsed_policies BIGINT,
    expiring_policies BIGINT,
    policy_types BIGINT,
    insurance_companies BIGINT
)
LANGUAGE plpgsql
AS $
BEGIN
    RETURN QUERY
    SELECT 
        COUNT(CASE WHEN cp.status = 'Active' THEN 1 END) AS active_policies,
        COUNT(CASE WHEN cp.status = 'Expired' THEN 1 END) AS expired_policies,
        COUNT(CASE WHEN cp.status = 'Lapsed' THEN 1 END) AS lapsed_policies,
        COUNT(CASE WHEN cp.end_date BETWEEN CURRENT_DATE AND CURRENT_DATE + INTERVAL '30 days' THEN 1 END) AS expiring_policies,
        COUNT(DISTINCT pt.type_id) AS policy_types,
        COUNT(DISTINCT ic.company_id) AS insurance_companies
    FROM client_policies cp
    INNER JOIN clients c ON cp.client_id = c.client_id
    LEFT JOIN policy_type pt ON cp.type_id = pt.type_id
    LEFT JOIN insurance_company ic ON cp.company_id = ic.company_id
    WHERE c.agent_id = p_agent_id AND cp.is_active = true AND c.is_active = true;
END;
$;

-- Create Policy Template
CREATE OR REPLACE FUNCTION sp_CreatePolicyTemplate(p_agent_id UUID,
    p_template_name VARCHAR(100),
    p_type_id UUID,
    p_default_term_months INTEGER DEFAULT NULL,
    p_default_premium DECIMAL(18,2) DEFAULT NULL,
    p_coverage_description TEXT DEFAULT NULL,
    p_terms TEXT DEFAULT NULL,
    p_category_id UUID DEFAULT NULL)
RETURNS TABLE(template_id UUID)
LANGUAGE plpgsql
AS $$
DECLARE
    v_template_id UUID := gen_random_uuid();
BEGIN
    INSERT INTO policy_template (
        template_id, agent_id, template_name, type_id, category_id,
        default_term_months, default_premium, coverage_description, terms
    )
    VALUES (
        v_template_id, p_agent_id, p_template_name, p_type_id, p_category_id,
        p_default_term_months, p_default_premium, p_coverage_description, p_terms
    );
    
    INSERT INTO activity_log (agent_id, activity_type, entity_type, entity_id, description)
    VALUES (
        p_agent_id, 'policy_template_created', 'policy_template', v_template_id, 
        'Policy template "' || p_template_name || '" created'
    );

    RETURN QUERY SELECT v_template_id;
END;
$;

-- Get Policy Templates
CREATE OR REPLACE FUNCTION sp_GetPolicyTemplates(p_agent_id UUID,
    p_type_id UUID DEFAULT NULL)
RETURNS TABLE(
    template_id UUID,
    template_name VARCHAR(100),
    type_id UUID,
    type_name VARCHAR(100),
    default_term_months INTEGER,
    default_premium DECIMAL(18,2),
    coverage_description TEXT,
    terms TEXT,
    category_id UUID,
    category_name VARCHAR(100),
    created_date TIMESTAMP
)
LANGUAGE plpgsql
AS $
BEGIN
    RETURN QUERY
    SELECT 
        pt.template_id,
        pt.template_name,
        pt.type_id,
        ptype.type_name,
        pt.default_term_months,
        pt.default_premium,
        pt.coverage_description,
        pt.terms,
        pt.category_id,
        pc.category_name,
        pt.created_date
    FROM policy_template pt
    LEFT JOIN policy_type ptype ON pt.type_id = ptype.type_id
    LEFT JOIN policy_category pc ON pt.category_id = pc.category_id
    WHERE 
        pt.agent_id = p_agent_id 
        AND pt.is_active = true
        AND (p_type_id IS NULL OR pt.type_id = p_type_id)
    ORDER BY ptype.type_name, pt.template_name;
END;
$;

-- ============================================
-- PostgreSQL Stored Procedures for Policy Management
-- Converted from SQL Server format
-- ============================================

-- Create Client Policy (using PolicyCatalog)
CREATE OR REPLACE FUNCTION sp_CreateClientPolicy(p_client_id UUID,
    p_policy_catalog_id UUID,
    p_start_date DATE,
    p_end_date DATE,
    p_status VARCHAR(20) DEFAULT 'Active',
    p_notes TEXT DEFAULT NULL)
RETURNS TABLE(policy_id UUID, error_message TEXT)
LANGUAGE plpgsql
AS $$
DECLARE
    v_policy_id UUID := gen_random_uuid();
    v_policy_name VARCHAR(100);
    v_type_id UUID;
    v_company_id UUID;
    v_agent_id UUID;
BEGIN
    -- Get policy details from PolicyCatalog
    SELECT 
        pc.policy_name,
        pc.type_id,
        pc.company_id
    INTO v_policy_name, v_type_id, v_company_id
    FROM policy_catalog pc
    WHERE pc.policy_catalog_id = p_policy_catalog_id AND pc.is_active = true;

    IF v_policy_name IS NULL THEN
        RETURN QUERY SELECT NULL::UUID, 'Policy Catalog item not found or inactive'::TEXT;
        RETURN;
    END IF;

    -- Get agent ID
    SELECT agent_id INTO v_agent_id FROM clients WHERE client_id = p_client_id;

    INSERT INTO client_policies (
        policy_id, client_id, policy_catalog_id, policy_name, type_id, company_id, 
        status, start_date, end_date, notes, is_active, created_date
    )
    VALUES (
        v_policy_id, p_client_id, p_policy_catalog_id, v_policy_name, v_type_id, v_company_id,
        p_status, p_start_date, p_end_date, p_notes, true, NOW() AT TIME ZONE 'UTC'
    );
    
    -- Log activity
    INSERT INTO activity_log (agent_id, activity_type, entity_type, entity_id, description)
    VALUES (
        v_agent_id, 'client_policy_created', 'client_policy', v_policy_id, 
        'Policy "' || v_policy_name || '" assigned to client from catalog'
    );
    
    RETURN QUERY SELECT v_policy_id, NULL::TEXT;
END;
$;

-- Delete Policy Template
CREATE OR REPLACE FUNCTION sp_DeletePolicyTemplate(p_template_id UUID,
    p_agent_id UUID)
RETURNS TABLE(rows_affected INTEGER)
LANGUAGE plpgsql
AS $
 $
DECLARE
    v_rows_affected INTEGER;
BEGIN
    UPDATE policy_template 
    SET is_active = false
    WHERE template_id = p_template_id AND agent_id = p_agent_id;
    
    GET DIAGNOSTICS v_rows_affected = ROW_COUNT;
    
    IF v_rows_affected > 0 THEN
        INSERT INTO activity_log (agent_id, activity_type, entity_type, entity_id, description)
        VALUES (
            p_agent_id, 'policy_template_deleted', 'policy_template', p_template_id, 
            'Policy template deleted'
        );
    END IF;
    
    RETURN QUERY SELECT v_rows_affected;
END;
$;

-- Get Policy Catalog for Agent
CREATE OR REPLACE FUNCTION sp_GetPolicyCatalog(p_agent_id UUID,
    p_type_id UUID DEFAULT NULL,
    p_company_id UUID DEFAULT NULL)
RETURNS TABLE(
    policy_catalog_id UUID,
    policy_name VARCHAR(100),
    type_id UUID,
    type_name VARCHAR(100),
    company_id UUID,
    company_name VARCHAR(100),
    category_id UUID,
    category_name VARCHAR(100),
    notes TEXT,
    created_date TIMESTAMP,
    modified_date TIMESTAMP
)
LANGUAGE plpgsql
AS $
 $
BEGIN
    RETURN QUERY
    SELECT 
        pc.policy_catalog_id,
        pc.policy_name,
        pc.type_id,
        pt.type_name,
        pc.company_id,
        ic.company_name,
        pc.category_id,
        pcat.category_name,
        pc.notes,
        pc.created_date,
        pc.modified_date
    FROM policy_catalog pc
    LEFT JOIN policy_type pt ON pc.type_id = pt.type_id
    LEFT JOIN insurance_company ic ON pc.company_id = ic.company_id
    LEFT JOIN policy_category pcat ON pc.category_id = pcat.category_id
    WHERE 
        pc.agent_id = p_agent_id 
        AND pc.is_active = true
        AND (p_type_id IS NULL OR pc.type_id = p_type_id)
        AND (p_company_id IS NULL OR pc.company_id = p_company_id)
    ORDER BY pt.type_name, pc.policy_name;
END;
$;

-- Create Policy Catalog Item
CREATE OR REPLACE FUNCTION sp_CreatePolicyCatalogItem(p_agent_id UUID,
    p_policy_name VARCHAR(100),
    p_type_id UUID,
    p_company_id UUID DEFAULT NULL,
    p_category_id UUID DEFAULT NULL,
    p_notes TEXT DEFAULT NULL)
RETURNS TABLE(policy_catalog_id UUID, error_message TEXT)
LANGUAGE plpgsql
AS $
DECLARE
    v_policy_catalog_id UUID := gen_random_uuid();
BEGIN
    -- Validate TypeId exists
    IF NOT EXISTS (SELECT 1 FROM policy_type WHERE type_id = p_type_id AND is_active = true) THEN
        RETURN QUERY SELECT NULL::UUID, 'Policy type not found or inactive'::TEXT;
        RETURN;
    END IF;
    
    -- Validate CompanyId if provided
    IF p_company_id IS NOT NULL AND NOT EXISTS (
        SELECT 1 FROM insurance_company WHERE company_id = p_company_id AND is_active = true
    ) THEN
        RETURN QUERY SELECT NULL::UUID, 'Insurance company not found or inactive'::TEXT;
        RETURN;
    END IF;
    
    INSERT INTO policy_catalog (
        policy_catalog_id, agent_id, policy_name, type_id, 
        company_id, category_id, notes, is_active, created_date
    )
    VALUES (
        v_policy_catalog_id, p_agent_id, p_policy_name, p_type_id, 
        p_company_id, p_category_id, p_notes, true, NOW() AT TIME ZONE 'UTC'
    );
    
    INSERT INTO activity_log (agent_id, activity_type, entity_type, entity_id, description)
    VALUES (p_agent_id, 'policy_catalog_created', 'policy_catalog', v_policy_catalog_id, 
            'Policy "' || p_policy_name || '" added to catalog');
    
    RETURN QUERY SELECT v_policy_catalog_id, NULL::TEXT;
END;
$;

-- Update Policy Catalog Item
CREATE OR REPLACE FUNCTION sp_UpdatePolicyCatalogItem(p_policy_catalog_id UUID,
    p_agent_id UUID,
    p_policy_name VARCHAR(100) DEFAULT NULL,
    p_type_id UUID DEFAULT NULL,
    p_company_id UUID DEFAULT NULL,
    p_category_id UUID DEFAULT NULL,
    p_notes TEXT DEFAULT NULL,
    p_is_active BOOLEAN DEFAULT NULL)
RETURNS TABLE(rows_affected INTEGER, error_message TEXT)
LANGUAGE plpgsql
AS $
DECLARE
    v_rows_affected INTEGER;
BEGIN
    -- Validate TypeId if provided
    IF p_type_id IS NOT NULL AND NOT EXISTS (
        SELECT 1 FROM policy_type WHERE type_id = p_type_id AND is_active = true
    ) THEN
        RETURN QUERY SELECT 0, 'Policy type not found or inactive'::TEXT;
        RETURN;
    END IF;
    
    -- Validate CompanyId if provided
    IF p_company_id IS NOT NULL AND NOT EXISTS (
        SELECT 1 FROM insurance_company WHERE company_id = p_company_id AND is_active = true
    ) THEN
        RETURN QUERY SELECT 0, 'Insurance company not found or inactive'::TEXT;
        RETURN;
    END IF;
    
    UPDATE policy_catalog 
    SET 
        policy_name = COALESCE(p_policy_name, policy_name),
        type_id = COALESCE(p_type_id, type_id),
        company_id = COALESCE(p_company_id, company_id),
        category_id = COALESCE(p_category_id, category_id),
        notes = COALESCE(p_notes, notes),
        is_active = COALESCE(p_is_active, is_active),
        modified_date = NOW() AT TIME ZONE 'UTC'
    WHERE policy_catalog_id = p_policy_catalog_id 
      AND agent_id = p_agent_id;
    
    GET DIAGNOSTICS v_rows_affected = ROW_COUNT;
    
    IF v_rows_affected > 0 THEN
        INSERT INTO activity_log (agent_id, activity_type, entity_type, entity_id, description)
        VALUES (p_agent_id, 'policy_catalog_updated', 'policy_catalog', p_policy_catalog_id, 
                'Policy catalog item updated');
    END IF;
    
    RETURN QUERY SELECT v_rows_affected, NULL::TEXT;
END;
$;

-- Delete Policy from Catalog
CREATE OR REPLACE FUNCTION sp_DeletePolicyCatalog(p_policy_catalog_id UUID,
    p_agent_id UUID)
RETURNS TABLE(rows_affected INTEGER)
LANGUAGE plpgsql
AS $
 $
DECLARE
    v_policy_name VARCHAR(100);
    v_rows_affected INTEGER;
BEGIN
    -- Get policy name for logging
    SELECT policy_name INTO v_policy_name 
    FROM policy_catalog 
    WHERE policy_catalog_id = p_policy_catalog_id;
    
    -- Soft delete
    UPDATE policy_catalog 
    SET is_active = false, modified_date = NOW() AT TIME ZONE 'UTC'
    WHERE policy_catalog_id = p_policy_catalog_id AND agent_id = p_agent_id;
    
    GET DIAGNOSTICS v_rows_affected = ROW_COUNT;
    
    -- Log activity
    IF v_rows_affected > 0 AND v_policy_name IS NOT NULL THEN
        INSERT INTO activity_log (agent_id, activity_type, entity_type, entity_id, description)
        VALUES (p_agent_id, 'policy_catalog_deleted', 'policy_catalog', p_policy_catalog_id, 
                'Policy "' || v_policy_name || '" removed from catalog');
    END IF;
    
    RETURN QUERY SELECT v_rows_affected;
END;
$;

-- Create or Update Client Policy
CREATE OR REPLACE FUNCTION sp_UpsertClientPolicy(p_client_id UUID,
    p_policy_name VARCHAR(100),
    p_type_id UUID,
    p_status VARCHAR(20),
    p_start_date DATE,
    p_end_date DATE,
    p_policy_id UUID DEFAULT NULL,
    p_company_id UUID DEFAULT NULL,
    p_policy_catalog_id UUID DEFAULT NULL,
    p_notes TEXT DEFAULT NULL)
RETURNS TABLE(policy_id UUID, error_message TEXT)
LANGUAGE plpgsql
AS $
DECLARE
    v_agent_id UUID;
    v_policy_id UUID := p_policy_id;
BEGIN
    -- Get agent ID from client
    SELECT agent_id INTO v_agent_id FROM clients WHERE client_id = p_client_id;

    -- Validate TypeId
    IF NOT EXISTS (SELECT 1 FROM policy_type WHERE type_id = p_type_id AND is_active = true) THEN
        RETURN QUERY SELECT NULL::UUID, 'Policy type not found or inactive'::TEXT;
        RETURN;
    END IF;

    -- Validate CompanyId if provided
    IF p_company_id IS NOT NULL AND NOT EXISTS (
        SELECT 1 FROM insurance_company WHERE company_id = p_company_id AND is_active = true
    ) THEN
        RETURN QUERY SELECT NULL::UUID, 'Insurance company not found or inactive'::TEXT;
        RETURN;
    END IF;

    IF v_policy_id IS NULL THEN
        -- Create new client policy
        v_policy_id := gen_random_uuid();

        INSERT INTO client_policies (
            policy_id, client_id, policy_name, type_id, company_id, policy_catalog_id,
            status, start_date, end_date, notes
        )
        VALUES (
            v_policy_id, p_client_id, p_policy_name, p_type_id, p_company_id, p_policy_catalog_id,
            p_status, p_start_date, p_end_date, p_notes
        );

        -- Log activity
        INSERT INTO activity_log (agent_id, activity_type, entity_type, entity_id, description)
        VALUES (
            v_agent_id, 'client_policy_created', 'client_policy', v_policy_id, 
            'Policy "' || p_policy_name || '" assigned to client'
        );
    ELSE
        -- Update existing client policy
        UPDATE client_policies 
        SET 
            policy_name = p_policy_name,
            type_id = p_type_id,
            company_id = p_company_id,
            policy_catalog_id = p_policy_catalog_id,
            status = p_status,
            start_date = p_start_date,
            end_date = p_end_date,
            notes = p_notes,
            modified_date = NOW() AT TIME ZONE 'UTC'
        WHERE policy_id = v_policy_id;

        -- Log activity
        INSERT INTO activity_log (agent_id, activity_type, entity_type, entity_id, description)
        VALUES (
            v_agent_id, 'client_policy_updated', 'client_policy', v_policy_id, 
            'Policy "' || p_policy_name || '" updated for client'
        );
    END IF;

    -- Return the policy ID
    RETURN QUERY SELECT v_policy_id, NULL::TEXT;
END;
$;

-- Get Client Policies
CREATE OR REPLACE FUNCTION sp_GetClientPolicies(p_client_id UUID,
    p_status VARCHAR(20) DEFAULT NULL,
    p_type_id UUID DEFAULT NULL)
RETURNS TABLE(
    policy_id UUID,
    client_id UUID,
    policy_catalog_id UUID,
    policy_name VARCHAR(100),
    type_id UUID,
    type_name VARCHAR(100),
    company_id UUID,
    company_name VARCHAR(100),
    status VARCHAR(20),
    start_date DATE,
    end_date DATE,
    notes TEXT,
    created_date TIMESTAMP,
    modified_date TIMESTAMP,
    is_active BOOLEAN,
    days_until_expiry INTEGER,
    client_name TEXT,
    client_phone VARCHAR(20)
)
LANGUAGE plpgsql
AS $
BEGIN
    RETURN QUERY
    SELECT 
        cp.policy_id,
        cp.client_id,
        cp.policy_catalog_id,
        cp.policy_name,
        cp.type_id,
        pt.type_name,
        cp.company_id,
        ic.company_name,
        cp.status,
        cp.start_date,
        cp.end_date,
        cp.notes,
        cp.created_date,
        cp.modified_date,
        cp.is_active,
        (cp.end_date - CURRENT_DATE)::INTEGER AS days_until_expiry,
        (c.first_name || ' ' || c.surname)::TEXT AS  $$
client_name,
        c.phone_number
    FROM client_policies cp
    INNER JOIN clients c ON cp.client_id = c.client_id
    LEFT JOIN policy_type pt ON cp.type_id = pt.type_id
    LEFT JOIN insurance_company ic ON cp.company_id = ic.company_id
    WHERE 
        cp.client_id = p_client_id
        AND cp.is_active = true
        AND (p_status IS NULL OR cp.status = p_status)
        AND (p_type_id IS NULL OR cp.type_id = p_type_id)
    ORDER BY cp.start_date DESC
$$ LANGUAGE plpgsql;
END;
$;

-- Get Expiring Policies
CREATE OR REPLACE FUNCTION sp_GetExpiringPolicies(p_agent_id UUID,
    p_days_ahead INTEGER DEFAULT 30)
RETURNS TABLE(
    policy_id UUID,
    client_id UUID,
    policy_name VARCHAR(100),
    type_name VARCHAR(100),
    company_name VARCHAR(100),
    status VARCHAR(20),
    start_date DATE,
    end_date DATE,
    notes TEXT,
    client_name TEXT,
    client_phone VARCHAR(20),
    client_email VARCHAR(100),
    days_until_expiry INTEGER
)
LANGUAGE plpgsql
AS $
DECLARE
    v_start_date DATE := CURRENT_DATE;
    v_end_date DATE := CURRENT_DATE + INTERVAL '1 day' * p_days_ahead;
BEGIN
    RETURN QUERY
    SELECT 
        cp.policy_id,
        cp.client_id,
        cp.policy_name,
        pt.type_name,
        ic.company_name,
        cp.status,
        cp.start_date,
        cp.end_date,
        cp.notes,
        (c.first_name || ' ' || c.surname)::TEXT AS client_name,
        c.phone_number,
        c.email,
        (cp.end_date - v_start_date)::INTEGER AS days_until_expiry
    FROM client_policies cp
    INNER JOIN clients c ON cp.client_id = c.client_id
    LEFT JOIN policy_type pt ON cp.type_id = pt.type_id
    LEFT JOIN insurance_company ic ON cp.company_id = ic.company_id
    WHERE 
        c.agent_id = p_agent_id 
        AND cp.status = 'Active'
        AND cp.is_active = true
        AND c.is_active = true
        AND cp.end_date BETWEEN v_start_date AND v_end_date
    ORDER BY cp.end_date ASC;
END;
$;

-- Update Client Policy
CREATE OR REPLACE FUNCTION sp_UpdateClientPolicy(p_policy_id UUID,
    p_policy_catalog_id UUID DEFAULT NULL,
    p_policy_name VARCHAR(100) DEFAULT NULL,
    p_type_id UUID DEFAULT NULL,
    p_company_id UUID DEFAULT NULL,
    p_status VARCHAR(20) DEFAULT NULL,
    p_start_date DATE DEFAULT NULL,
    p_end_date DATE DEFAULT NULL,
    p_notes TEXT DEFAULT NULL,
    p_is_active BOOLEAN DEFAULT NULL)
RETURNS TABLE(rows_affected INTEGER, error_message TEXT)
LANGUAGE plpgsql
AS $
DECLARE
    v_agent_id UUID;
    v_rows_affected INTEGER;
BEGIN
    -- Get agent ID from the client associated with this policy
    SELECT c.agent_id INTO v_agent_id
    FROM client_policies cp
    INNER JOIN clients c ON cp.client_id = c.client_id
    WHERE cp.policy_id = p_policy_id;

    -- Validate PolicyCatalogId if provided
    IF p_policy_catalog_id IS NOT NULL THEN
        IF NOT EXISTS (
            SELECT 1 
            FROM policy_catalog 
            WHERE policy_catalog_id = p_policy_catalog_id 
              AND is_active = true
        ) THEN
            RETURN QUERY SELECT 0, 'Policy Catalog item not found or inactive'::TEXT;
            RETURN;
        END IF;
    END IF;

    -- Validate TypeId if provided
    IF p_type_id IS NOT NULL AND NOT EXISTS (
        SELECT 1 FROM policy_type WHERE type_id = p_type_id AND is_active = true
    ) THEN
        RETURN QUERY SELECT 0, 'Policy type not found or inactive'::TEXT;
        RETURN;
    END IF;

    -- Validate CompanyId if provided
    IF p_company_id IS NOT NULL AND NOT EXISTS (
        SELECT 1 FROM insurance_company WHERE company_id = p_company_id AND is_active = true
    ) THEN
        RETURN QUERY SELECT 0, 'Insurance company not found or inactive'::TEXT;
        RETURN;
    END IF;

    UPDATE client_policies 
    SET 
        policy_catalog_id = COALESCE(p_policy_catalog_id, policy_catalog_id),
        policy_name = COALESCE(p_policy_name, policy_name),
        type_id = COALESCE(p_type_id, type_id),
        company_id = COALESCE(p_company_id, company_id),
        status = COALESCE(p_status, status),
        start_date = COALESCE(p_start_date, start_date),
        end_date = COALESCE(p_end_date, end_date),
        notes = COALESCE(p_notes, notes),
        is_active = COALESCE(p_is_active, is_active),
        modified_date = NOW() AT TIME ZONE 'UTC'
    WHERE policy_id = p_policy_id;
    
    GET DIAGNOSTICS v_rows_affected = ROW_COUNT;
    
    IF v_rows_affected > 0 AND v_agent_id IS NOT NULL THEN
        INSERT INTO activity_log (agent_id, activity_type, entity_type, entity_id, description)
        VALUES (
            v_agent_id, 'client_policy_updated', 'client_policy', p_policy_id, 
            'Client policy updated'
        );
    END IF;
    
    RETURN QUERY SELECT v_rows_affected, NULL::TEXT;
END;
$;

-- Get Policy Statistics (Enhanced Version)
CREATE OR REPLACE FUNCTION sp_GetPolicyStatisticsDetailed(p_agent_id UUID)
RETURNS TABLE(
    total_policies BIGINT,
    active_policies BIGINT,
    expired_policies BIGINT,
    lapsed_policies BIGINT,
    inactive_policies BIGINT,
    expiring_in_30_days BIGINT,
    expiring_in_7_days BIGINT,
    new_policies_this_month BIGINT,
    motor_policies BIGINT,
    life_policies BIGINT,
    health_policies BIGINT,
    travel_policies BIGINT,
    property_policies BIGINT,
    marine_policies BIGINT,
    business_policies BIGINT,
    catalog_policies BIGINT,
    policy_types BIGINT,
    insurance_companies BIGINT
)
LANGUAGE plpgsql
AS $
 $
DECLARE
    v_today DATE := CURRENT_DATE;
    v_month_start DATE := DATE_TRUNC('month', CURRENT_DATE)::DATE;
    v_month_end DATE := (DATE_TRUNC('month', CURRENT_DATE) + INTERVAL '1 month - 1 day')::DATE;
BEGIN
    RETURN QUERY
    SELECT 
        -- Total Policies
        COUNT(DISTINCT cp.policy_id) AS total_policies,
        COUNT(DISTINCT CASE WHEN cp.status = 'Active' THEN cp.policy_id END) AS active_policies,
        COUNT(DISTINCT CASE WHEN cp.status = 'Expired' THEN cp.policy_id END) AS expired_policies,
        COUNT(DISTINCT CASE WHEN cp.status = 'Lapsed' THEN cp.policy_id END) AS lapsed_policies,
        COUNT(DISTINCT CASE WHEN cp.status = 'Inactive' THEN cp.policy_id END) AS inactive_policies,

        -- Expiring Soon (next 30 days)
        COUNT(DISTINCT CASE WHEN cp.end_date BETWEEN v_today AND v_today + INTERVAL '30 days' 
                             AND cp.status = 'Active' THEN cp.policy_id END) AS expiring_in_30_days,
        COUNT(DISTINCT CASE WHEN cp.end_date BETWEEN v_today AND v_today + INTERVAL '7 days' 
                             AND cp.status = 'Active' THEN cp.policy_id END) AS expiring_in_7_days,

        -- New Policies This Month
        COUNT(DISTINCT CASE WHEN cp.start_date BETWEEN v_month_start AND v_month_end THEN cp.policy_id END) AS new_policies_this_month,

        -- Policies by Type
        COUNT(DISTINCT CASE WHEN pt.type_name = 'Motor' THEN cp.policy_id END) AS motor_policies,
        COUNT(DISTINCT CASE WHEN pt.type_name = 'Life' THEN cp.policy_id END) AS life_policies,
        COUNT(DISTINCT CASE WHEN pt.type_name = 'Health' THEN cp.policy_id END) AS health_policies,
        COUNT(DISTINCT CASE WHEN pt.type_name = 'Travel' THEN cp.policy_id END) AS travel_policies,
        COUNT(DISTINCT CASE WHEN pt.type_name = 'Property' THEN cp.policy_id END) AS property_policies,
        COUNT(DISTINCT CASE WHEN pt.type_name = 'Marine' THEN cp.policy_id END) AS marine_policies,
        COUNT(DISTINCT CASE WHEN pt.type_name = 'Business' THEN cp.policy_id END) AS business_policies,

        -- Catalog Statistics
        COUNT(DISTINCT pc.policy_catalog_id) AS catalog_policies,
        COUNT(DISTINCT pt.type_id) AS policy_types,
        COUNT(DISTINCT ic.company_id) AS insurance_companies
        
    FROM client_policies cp
    INNER JOIN clients c ON cp.client_id = c.client_id
    LEFT JOIN policy_catalog pc ON cp.policy_catalog_id = pc.policy_catalog_id
    LEFT JOIN policy_type pt ON cp.type_id = pt.type_id
    LEFT JOIN insurance_company ic ON cp.company_id = ic.company_id
    WHERE c.agent_id = p_agent_id 
      AND cp.is_active = true 
      AND c.is_active = true;
END;
$;

-- Get Expiring Policies with Period Parameter
CREATE OR REPLACE FUNCTION sp_GetExpiringPoliciesByPeriod(p_period VARCHAR(20),
    p_agent_id UUID DEFAULT NULL)
RETURNS TABLE(
    policy_id UUID,
    client_id UUID,
    client_name TEXT,
    client_phone VARCHAR(20),
    client_email VARCHAR(100),
    policy_name VARCHAR(100),
    policy_type VARCHAR(100),
    company_name VARCHAR(100),
    start_date DATE,
    end_date DATE,
    status VARCHAR(20),
    notes TEXT,
    days_until_expiry INTEGER
)
LANGUAGE plpgsql
AS $
DECLARE
    v_days INTEGER;
BEGIN
    v_days := CASE UPPER(p_period)
                WHEN '1D' THEN 1
                WHEN '1W' THEN 7
                WHEN '1M' THEN 30
                WHEN '1Y' THEN 365
                WHEN '2Y' THEN 730
                WHEN '3Y' THEN 1095
                ELSE NULL
              END;

    IF v_days IS NULL THEN
        RAISE EXCEPTION 'Invalid period specified. Use 1D, 1W, 1M, 1Y, 2Y, or 3Y.';
    END IF;

    RETURN QUERY
    SELECT 
        cp.policy_id,
        cp.client_id,
        (c.first_name || ' ' || c.surname)::TEXT AS client_name,
        c.phone_number AS client_phone,
        c.email AS client_email,
        cp.policy_name,
        pt.type_name AS policy_type,
        ic.company_name,
        cp.start_date,
        cp.end_date,
        cp.status,
        cp.notes,
        (cp.end_date - CURRENT_DATE)::INTEGER AS days_until_expiry
    FROM client_policies cp
    INNER JOIN clients c ON cp.client_id = c.client_id
    LEFT JOIN policy_type pt ON cp.type_id = pt.type_id
    LEFT JOIN insurance_company ic ON cp.company_id = ic.company_id
    WHERE 
        cp.is_active = true
        AND cp.status = 'Active'
        AND c.is_active = true
        AND (p_agent_id IS NULL OR c.agent_id = p_agent_id)
        AND cp.end_date BETWEEN CURRENT_DATE AND CURRENT_DATE + INTERVAL '1 day' * v_days
    ORDER BY cp.end_date ASC;
END;
$;

-- Create Policy Category
CREATE OR REPLACE FUNCTION sp_CreatePolicyCategory(p_category_name VARCHAR(50),
    p_description VARCHAR(200) DEFAULT NULL)
RETURNS TABLE(category_id UUID, error_message TEXT)
LANGUAGE plpgsql
AS $
DECLARE
    v_category_id UUID := gen_random_uuid();
BEGIN
    IF EXISTS (SELECT 1 FROM policy_category WHERE category_name = p_category_name AND is_active = true) THEN
        RETURN QUERY SELECT NULL::UUID, 'Category already exists'::TEXT;
        RETURN;
    END IF;

    INSERT INTO policy_category (category_id, category_name, description, is_active, created_date)
    VALUES (v_category_id, p_category_name, p_description, true, NOW() AT TIME ZONE 'UTC');

    RETURN QUERY SELECT v_category_id, NULL::TEXT;
END;
$;

-- Update Policy Template
CREATE OR REPLACE FUNCTION sp_UpdatePolicyTemplate(p_template_id UUID,
    p_agent_id UUID,
    p_template_name VARCHAR(100) DEFAULT NULL,
    p_type_id UUID DEFAULT NULL,
    p_default_term_months INTEGER DEFAULT NULL,
    p_default_premium DECIMAL(18,2) DEFAULT NULL,
    p_coverage_description TEXT DEFAULT NULL,
    p_terms TEXT DEFAULT NULL,
    p_category_id UUID DEFAULT NULL,
    p_is_active BOOLEAN DEFAULT NULL)
RETURNS TABLE(rows_affected INTEGER, error_message TEXT)
LANGUAGE plpgsql
AS $
DECLARE
    v_rows_affected INTEGER;
BEGIN
    -- Validate TypeId if provided
    IF p_type_id IS NOT NULL AND NOT EXISTS (
        SELECT 1 FROM policy_type WHERE type_id = p_type_id AND is_active = true
    ) THEN
        RETURN QUERY SELECT 0, 'Policy type not found or inactive'::TEXT;
        RETURN;
    END IF;
    
    -- Validate CategoryId if provided
    IF p_category_id IS NOT NULL AND NOT EXISTS (
        SELECT 1 FROM policy_category WHERE category_id = p_category_id AND is_active = true
    ) THEN
        RETURN QUERY SELECT 0, 'Policy category not found or inactive'::TEXT;
        RETURN;
    END IF;
    
    UPDATE policy_template 
    SET 
        template_name = COALESCE(p_template_name, template_name),
        type_id = COALESCE(p_type_id, type_id),
        default_term_months = COALESCE(p_default_term_months, default_term_months),
        default_premium = COALESCE(p_default_premium, default_premium),
        coverage_description = COALESCE(p_coverage_description, coverage_description),
        terms = COALESCE(p_terms, terms),
        category_id = COALESCE(p_category_id, category_id),
        is_active = COALESCE(p_is_active, is_active)
    WHERE template_id = p_template_id 
      AND agent_id = p_agent_id;
    
    GET DIAGNOSTICS v_rows_affected = ROW_COUNT;
    
    IF v_rows_affected > 0 THEN
        INSERT INTO activity_log (agent_id, activity_type, entity_type, entity_id, description)
        VALUES (
            p_agent_id, 'policy_template_updated', 'policy_template', p_template_id, 
            'Policy template updated'
        );
    END IF;
    
    RETURN QUERY SELECT v_rows_affected, NULL::TEXT;
END;
$;

-- Delete Client Policy (Soft Delete)
CREATE OR REPLACE FUNCTION sp_DeleteClientPolicy(p_policy_id UUID,
    p_agent_id UUID)
RETURNS TABLE(rows_affected INTEGER)
LANGUAGE plpgsql
AS $
 $
DECLARE
    v_policy_name VARCHAR(100);
    v_rows_affected INTEGER;
BEGIN
    -- Get policy name for logging
    SELECT cp.policy_name INTO v_policy_name
    FROM client_policies cp
    INNER JOIN clients c ON cp.client_id = c.client_id
    WHERE cp.policy_id = p_policy_id AND c.agent_id = p_agent_id;
    
    -- Soft delete
    UPDATE client_policies 
    SET is_active = false, modified_date = NOW() AT TIME ZONE 'UTC'
    WHERE policy_id = p_policy_id 
      AND EXISTS (
          SELECT 1 FROM clients c 
          WHERE c.client_id = client_policies.client_id 
            AND c.agent_id = p_agent_id
      );
    
    GET DIAGNOSTICS v_rows_affected = ROW_COUNT;
    
    IF v_rows_affected > 0 THEN
        INSERT INTO activity_log (agent_id, activity_type, entity_type, entity_id, description)
        VALUES (
            p_agent_id, 'client_policy_deleted', 'client_policy', p_policy_id, 
            'Policy "' || COALESCE(v_policy_name, 'Unknown') || '" deleted for client'
        );
    END IF;
    
    RETURN QUERY SELECT v_rows_affected;
END;
$;

-- Get Insurance Companies
CREATE OR REPLACE FUNCTION sp_GetInsuranceCompanies(p_is_active BOOLEAN DEFAULT true)
RETURNS TABLE(
    company_id UUID,
    company_name VARCHAR(100),
    is_active BOOLEAN,
    created_date TIMESTAMP
)
LANGUAGE plpgsql
AS $
BEGIN
    RETURN QUERY
    SELECT 
        ic.company_id,
        ic.company_name,
        ic.is_active,
        ic.created_date
    FROM insurance_company ic
    WHERE (p_is_active IS NULL OR ic.is_active = p_is_active)
    ORDER BY ic.company_name ASC;
END;
$;

-- Get Policy Types
CREATE OR REPLACE FUNCTION sp_GetPolicyTypes(p_is_active BOOLEAN DEFAULT true)
RETURNS TABLE(
    type_id UUID,
    type_name VARCHAR(100),
    is_active BOOLEAN,
    created_date TIMESTAMP
)
LANGUAGE plpgsql
AS $
BEGIN
    RETURN QUERY
    SELECT 
        pt.type_id,
        pt.type_name,
        pt.is_active,
        pt.created_date
    FROM policy_type pt
    WHERE (p_is_active IS NULL OR pt.is_active = p_is_active)
    ORDER BY pt.type_name ASC;
END;
$;

-- Get Policy Categories
CREATE OR REPLACE FUNCTION sp_GetPolicyCategories(p_is_active BOOLEAN DEFAULT true)
RETURNS TABLE(
    category_id UUID,
    category_name VARCHAR(100),
    description TEXT,
    is_active BOOLEAN,
    created_date TIMESTAMP
)
LANGUAGE plpgsql
AS $
BEGIN
    RETURN QUERY
    SELECT 
        pc.category_id,
        pc.category_name,
        pc.description,
        pc.is_active,
        pc.created_date
    FROM policy_category pc
    WHERE (p_is_active IS NULL OR pc.is_active = p_is_active)
    ORDER BY pc.category_name ASC;
END;
$;

-- Validate Policy Data
CREATE OR REPLACE FUNCTION sp_ValidatePolicyData(p_policy_name VARCHAR(100),
    p_type_id UUID,
    p_company_id UUID DEFAULT NULL,
    p_start_date DATE DEFAULT NULL,
    p_end_date DATE DEFAULT NULL)
RETURNS TABLE(is_valid BOOLEAN, validation_errors TEXT)
LANGUAGE plpgsql
AS $$
DECLARE
    v_is_valid BOOLEAN := true;
    v_validation_errors TEXT := '';
BEGIN
    -- Validate Policy Name
    IF p_policy_name IS NULL OR LENGTH(TRIM(p_policy_name)) = 0 THEN
        v_is_valid := false;
        v_validation_errors := v_validation_errors || 'Policy name is required. ';
    END IF;
    
    -- Validate Policy Type ID
    IF p_type_id IS NULL OR NOT EXISTS (
        SELECT 1 FROM policy_type WHERE type_id = p_type_id AND is_active = true
    ) THEN
        v_is_valid := false;
        v_validation_errors := v_validation_errors || 'Valid policy type is required. ';
    END IF;
    
    -- Validate Company
    IF p_company_id IS NOT NULL AND NOT EXISTS (
        SELECT 1 FROM insurance_company WHERE company_id = p_company_id AND is_active = true
    ) THEN
        v_is_valid := false;
        v_validation_errors := v_validation_errors || 'Valid insurance company is required. ';
    END IF;
    
    -- Validate Dates
    IF p_start_date IS NOT NULL AND p_end_date IS NOT NULL AND p_start_date >= p_end_date THEN
        v_is_valid := false;
        v_validation_errors := v_validation_errors || 'End date must be after start date. ';
    END IF;
    
    RETURN QUERY SELECT v_is_valid, RTRIM(v_validation_errors);
END;
$;

-- Get Policy Statistics
CREATE OR REPLACE FUNCTION sp_GetPolicyStatistics(p_agent_id UUID)
RETURNS TABLE(
    active_policies BIGINT,
    expired_policies BIGINT,
    lapsed_policies BIGINT,
    expiring_policies BIGINT,
    policy_types BIGINT,
    insurance_companies BIGINT
)
LANGUAGE plpgsql
AS $
BEGIN
    RETURN QUERY
    SELECT 
        COUNT(CASE WHEN cp.status = 'Active' THEN 1 END) AS active_policies,
        COUNT(CASE WHEN cp.status = 'Expired' THEN 1 END) AS expired_policies,
        COUNT(CASE WHEN cp.status = 'Lapsed' THEN 1 END) AS lapsed_policies,
        COUNT(CASE WHEN cp.end_date BETWEEN CURRENT_DATE AND CURRENT_DATE + INTERVAL '30 days' THEN 1 END) AS expiring_policies,
        COUNT(DISTINCT pt.type_id) AS policy_types,
        COUNT(DISTINCT ic.company_id) AS insurance_companies
    FROM client_policies cp
    INNER JOIN clients c ON cp.client_id = c.client_id
    LEFT JOIN policy_type pt ON cp.type_id = pt.type_id
    LEFT JOIN insurance_company ic ON cp.company_id = ic.company_id
    WHERE c.agent_id = p_agent_id AND cp.is_active = true AND c.is_active = true;
END;
$;

-- Create Policy Template
CREATE OR REPLACE FUNCTION sp_CreatePolicyTemplate(p_agent_id UUID,
    p_template_name VARCHAR(100),
    p_type_id UUID,
    p_default_term_months INTEGER DEFAULT NULL,
    p_default_premium DECIMAL(18,2) DEFAULT NULL,
    p_coverage_description TEXT DEFAULT NULL,
    p_terms TEXT DEFAULT NULL,
    p_category_id UUID DEFAULT NULL)
RETURNS TABLE(template_id UUID)
LANGUAGE plpgsql
AS $$
DECLARE
    v_template_id UUID := gen_random_uuid();
BEGIN
    INSERT INTO policy_template (
        template_id, agent_id, template_name, type_id, category_id,
        default_term_months, default_premium, coverage_description, terms
    )
    VALUES (
        v_template_id, p_agent_id, p_template_name, p_type_id, p_category_id,
        p_default_term_months, p_default_premium, p_coverage_description, p_terms
    );
    
    INSERT INTO activity_log (agent_id, activity_type, entity_type, entity_id, description)
    VALUES (
        p_agent_id, 'policy_template_created', 'policy_template', v_template_id, 
        'Policy template "' || p_template_name || '" created'
    );

    RETURN QUERY SELECT v_template_id;
END;
$;

-- Get Policy Templates
CREATE OR REPLACE FUNCTION sp_GetPolicyTemplates(p_agent_id UUID,
    p_type_id UUID DEFAULT NULL)
RETURNS TABLE(
    template_id UUID,
    template_name VARCHAR(100),
    type_id UUID,
    type_name VARCHAR(100),
    default_term_months INTEGER,
    default_premium DECIMAL(18,2),
    coverage_description TEXT,
    terms TEXT,
    category_id UUID,
    category_name VARCHAR(100),
    created_date TIMESTAMP
)
LANGUAGE plpgsql
AS $
BEGIN
    RETURN QUERY
    SELECT 
        pt.template_id,
        pt.template_name,
        pt.type_id,
        ptype.type_name,
        pt.default_term_months,
        pt.default_premium,
        pt.coverage_description,
        pt.terms,
        pt.category_id,
        pc.category_name,
        pt.created_date
    FROM policy_template pt
    LEFT JOIN policy_type ptype ON pt.type_id = ptype.type_id
    LEFT JOIN policy_category pc ON pt.category_id = pc.category_id
    WHERE 
        pt.agent_id = p_agent_id 
        AND pt.is_active = true
        AND (p_type_id IS NULL OR pt.type_id = p_type_id)
    ORDER BY ptype.type_name, pt.template_name;
END;
$;
-- ============================================
-- Indexes and Performance Optimization
-- ============================================

-- ============================================
-- PostgreSQL Indexes, Constraints, Views and Functions
-- Converted from SQL Server format
-- ============================================

-- ============================================
-- INDEXES
-- ============================================

-- Agent Table Indexes
CREATE INDEX CONCURRENTLY IF NOT EXISTS ix_agent_email ON agent(email);
CREATE INDEX CONCURRENTLY IF NOT EXISTS ix_agent_is_active ON agent(is_active);

-- Clients Table Indexes
CREATE INDEX CONCURRENTLY IF NOT EXISTS ix_clients_agent_id ON clients(agent_id);
CREATE INDEX CONCURRENTLY IF NOT EXISTS ix_clients_is_active ON clients(is_active);
CREATE INDEX CONCURRENTLY IF NOT EXISTS ix_clients_is_client ON clients(is_client);
CREATE INDEX CONCURRENTLY IF NOT EXISTS ix_clients_phone_number ON clients(phone_number);
CREATE INDEX CONCURRENTLY IF NOT EXISTS ix_clients_email ON clients(email);
CREATE INDEX CONCURRENTLY IF NOT EXISTS ix_clients_date_of_birth ON clients(date_of_birth);
CREATE INDEX CONCURRENTLY IF NOT EXISTS ix_clients_insurance_type ON clients(insurance_type);
CREATE INDEX CONCURRENTLY IF NOT EXISTS ix_clients_search ON clients(agent_id, is_active) INCLUDE (first_name, surname, last_name, phone_number, email);

-- Appointments Table Indexes
CREATE INDEX CONCURRENTLY IF NOT EXISTS ix_appointments_agent_id ON appointments(agent_id);
CREATE INDEX CONCURRENTLY IF NOT EXISTS ix_appointments_client_id ON appointments(client_id);
CREATE INDEX CONCURRENTLY IF NOT EXISTS ix_appointments_date ON appointments(appointment_date);
CREATE INDEX CONCURRENTLY IF NOT EXISTS ix_appointments_status ON appointments(status);
CREATE INDEX CONCURRENTLY IF NOT EXISTS ix_appointments_type ON appointments(type);
CREATE INDEX CONCURRENTLY IF NOT EXISTS ix_appointments_is_active ON appointments(is_active);
CREATE INDEX CONCURRENTLY IF NOT EXISTS ix_appointments_dashboard ON appointments(agent_id, appointment_date, is_active) INCLUDE (client_name, title, start_time, end_time, status);

-- Client Policies Indexes
CREATE INDEX CONCURRENTLY IF NOT EXISTS ix_client_policies_client_id ON client_policies(client_id);
CREATE INDEX CONCURRENTLY IF NOT EXISTS ix_client_policies_status ON client_policies(status);
CREATE INDEX CONCURRENTLY IF NOT EXISTS ix_client_policies_end_date ON client_policies(end_date);
CREATE INDEX CONCURRENTLY IF NOT EXISTS ix_client_policies_is_active ON client_policies(is_active);
CREATE INDEX CONCURRENTLY IF NOT EXISTS ix_client_policies_expiring ON client_policies(status, end_date, is_active);

-- Reminders Table Indexes
CREATE INDEX CONCURRENTLY IF NOT EXISTS ix_reminders_agent_id ON reminders(agent_id);
CREATE INDEX CONCURRENTLY IF NOT EXISTS ix_reminders_client_id ON reminders(client_id);
CREATE INDEX CONCURRENTLY IF NOT EXISTS ix_reminders_date ON reminders(reminder_date);
CREATE INDEX CONCURRENTLY IF NOT EXISTS ix_reminders_status ON reminders(status);
CREATE INDEX CONCURRENTLY IF NOT EXISTS ix_reminders_type ON reminders(reminder_type);
CREATE INDEX CONCURRENTLY IF NOT EXISTS ix_reminders_active ON reminders(agent_id, status, reminder_date);

-- Policy Catalog Indexes
CREATE INDEX CONCURRENTLY IF NOT EXISTS ix_policy_catalog_agent_id ON policy_catalog(agent_id);
CREATE INDEX CONCURRENTLY IF NOT EXISTS ix_policy_catalog_type ON policy_catalog(type_id);
CREATE INDEX CONCURRENTLY IF NOT EXISTS ix_policy_catalog_company ON policy_catalog(company_id);
CREATE INDEX CONCURRENTLY IF NOT EXISTS ix_policy_catalog_is_active ON policy_catalog(is_active);

-- Automated Messages Indexes
CREATE INDEX CONCURRENTLY IF NOT EXISTS ix_automated_messages_agent_id ON automated_messages(agent_id);
CREATE INDEX CONCURRENTLY IF NOT EXISTS ix_automated_messages_status ON automated_messages(status);
CREATE INDEX CONCURRENTLY IF NOT EXISTS ix_automated_messages_scheduled_date ON automated_messages(scheduled_date);

-- Activity Log Indexes
CREATE INDEX CONCURRENTLY IF NOT EXISTS ix_activity_log_agent_id ON activity_log(agent_id);
CREATE INDEX CONCURRENTLY IF NOT EXISTS ix_activity_log_date ON activity_log(activity_date);
CREATE INDEX CONCURRENTLY IF NOT EXISTS ix_activity_log_type ON activity_log(activity_type);
CREATE INDEX CONCURRENTLY IF NOT EXISTS ix_activity_log_entity ON activity_log(entity_type, entity_id);

-- Dashboard Statistics Indexes
CREATE INDEX CONCURRENTLY IF NOT EXISTS ix_dashboard_statistics_agent_date ON dashboard_statistics(agent_id, stat_date);

-- Performance Metrics Indexes
CREATE INDEX CONCURRENTLY IF NOT EXISTS ix_performance_metrics_agent_date ON performance_metrics(agent_id, metric_date);

-- Monthly Reports Indexes
CREATE INDEX CONCURRENTLY IF NOT EXISTS ix_monthly_reports_agent_month ON monthly_reports(agent_id, report_month);

-- Settings Tables Indexes
CREATE INDEX CONCURRENTLY IF NOT EXISTS ix_reminder_settings_agent_id ON reminder_settings(agent_id);
CREATE INDEX CONCURRENTLY IF NOT EXISTS ix_agent_notification_preferences_agent_id ON agent_notification_preferences(agent_id);
CREATE INDEX CONCURRENTLY IF NOT EXISTS ix_system_preferences_agent_id ON system_preferences(agent_id);
CREATE INDEX CONCURRENTLY IF NOT EXISTS ix_message_templates_agent_id ON message_templates(agent_id);
CREATE INDEX CONCURRENTLY IF NOT EXISTS ix_message_templates_type ON message_templates(message_type);

-- Daily Notes Indexes
CREATE INDEX CONCURRENTLY IF NOT EXISTS ix_daily_notes_agent_date ON daily_notes(agent_id, note_date);

-- Message Recipients Indexes
CREATE INDEX CONCURRENTLY IF NOT EXISTS ix_message_recipients_message_id ON message_recipients(message_id);
CREATE INDEX CONCURRENTLY IF NOT EXISTS ix_message_recipients_client_id ON message_recipients(client_id);
CREATE INDEX CONCURRENTLY IF NOT EXISTS ix_message_recipients_status ON message_recipients(delivery_status);

-- ============================================
-- UNIQUE CONSTRAINTS
-- ============================================

-- Ensure email uniqueness across active agents
CREATE UNIQUE INDEX ux_agent_email_active 
ON agent(email) 
WHERE is_active = true;

-- ============================================
-- CHECK CONSTRAINTS
-- ============================================

-- Ensure phone number format validation (basic constraint)
ALTER TABLE clients 
ADD CONSTRAINT ck_clients_phone_format 
CHECK (phone_number ~ '^\+254[0-9]{9}$' 
       OR phone_number ~ '^07[0-9]{8}$'
       OR phone_number ~ '^01[0-9]{8}$');

-- Ensure appointment end time is after start time
ALTER TABLE appointments 
ADD CONSTRAINT ck_appointments_time_order 
CHECK (end_time > start_time);

-- Ensure policy end date is after start date
ALTER TABLE client_policies 
ADD CONSTRAINT ck_client_policies_date_order 
CHECK (end_date > start_date);

-- Ensure reminder date is not in the past (for new reminders)
ALTER TABLE reminders 
ADD CONSTRAINT ck_reminders_future_date 
CHECK (reminder_date >= CURRENT_DATE OR status != 'Active');

-- Ensure scheduled message date is in the future
ALTER TABLE automated_messages 
ADD CONSTRAINT ck_automated_messages_scheduled_date 
CHECK (scheduled_date > NOW() OR status != 'Scheduled');

-- ============================================
-- VIEWS FOR COMMON QUERIES
-- ============================================

-- Active Clients View
CREATE OR REPLACE VIEW vw_active_clients AS
SELECT 
    c.*,
    cp.policy_id,
    cp.policy_name,
    pt.type_name as policy_type,
    ic.company_name AS policy_company,
    cp.status AS policy_status,
    cp.start_date AS policy_start_date,
    cp.end_date AS policy_end_date,
    EXTRACT(YEAR FROM age(c.date_of_birth)) AS age
FROM clients c
LEFT JOIN client_policies cp ON c.client_id = cp.client_id AND cp.is_active = true
LEFT JOIN policy_type pt ON cp.type_id = pt.type_id
LEFT JOIN insurance_company ic ON cp.company_id = ic.company_id
WHERE c.is_active = true;

-- Today's Dashboard View
CREATE OR REPLACE VIEW vw_today_dashboard AS
SELECT 
    c.agent_id,
    -- Today's Appointments
    COUNT(DISTINCT CASE WHEN a.appointment_date = CURRENT_DATE AND a.status NOT IN ('Cancelled') THEN a.appointment_id END) AS today_appointments,
    -- Today's Reminders
    COUNT(DISTINCT CASE WHEN r.reminder_date = CURRENT_DATE AND r.status = 'Active' THEN r.reminder_id END) AS today_reminders,
    -- Today's Birthdays
    COUNT(DISTINCT CASE WHEN EXTRACT(DAY FROM c.date_of_birth) = EXTRACT(DAY FROM CURRENT_DATE) 
                            AND EXTRACT(MONTH FROM c.date_of_birth) = EXTRACT(MONTH FROM CURRENT_DATE) 
                       THEN c.client_id END) AS today_birthdays,
    -- Expiring Policies (next 30 days)
    COUNT(DISTINCT CASE WHEN cp.end_date BETWEEN CURRENT_DATE AND CURRENT_DATE + INTERVAL '30 days' 
                            AND cp.status = 'Active' THEN cp.policy_id END) AS expiring_policies
FROM clients c
LEFT JOIN appointments a ON c.client_id = a.client_id AND a.is_active = true
LEFT JOIN reminders r ON c.client_id = r.client_id
LEFT JOIN client_policies cp ON c.client_id = cp.client_id AND cp.is_active = true
WHERE c.is_active = true
GROUP BY c.agent_id;

-- Expiring Policies View
CREATE OR REPLACE VIEW vw_expiring_policies AS
SELECT 
    c.agent_id,
    cp.policy_id,
    cp.policy_name,
    pt.type_name as policy_type,
    ic.company_name,
    cp.end_date,
    c.client_id,
    c.first_name || ' ' || c.surname AS client_name,
    c.phone_number,
    c.email,
    (cp.end_date - CURRENT_DATE) AS days_until_expiry
FROM client_policies cp
INNER JOIN clients c ON cp.client_id = c.client_id
LEFT JOIN policy_type pt ON cp.type_id = pt.type_id
LEFT JOIN insurance_company ic ON cp.company_id = ic.company_id
WHERE 
    cp.status = 'Active' 
    AND cp.is_active = true 
    AND c.is_active = true
    AND cp.end_date BETWEEN CURRENT_DATE AND CURRENT_DATE + INTERVAL '60 days';

-- ============================================
-- TRIGGERS FOR AUDIT AND BUSINESS LOGIC
-- ============================================

-- Function for updating modified_date
CREATE OR REPLACE FUNCTION update_modified_date()
RETURNS TRIGGER AS $
BEGIN
    NEW.modified_date = NOW() AT TIME ZONE 'UTC';
    RETURN NEW;
END;
$ LANGUAGE plpgsql;

-- Trigger to update modified_date on clients table
DROP TRIGGER IF EXISTS tr_clients_update_modified_date ON clients;
CREATE TRIGGER tr_clients_update_modified_date
    BEFORE UPDATE ON clients
    FOR EACH ROW
    EXECUTE FUNCTION update_modified_date();

-- Trigger to update modified_date on appointments table
DROP TRIGGER IF EXISTS tr_appointments_update_modified_date ON appointments;
CREATE TRIGGER tr_appointments_update_modified_date
    BEFORE UPDATE ON appointments
    FOR EACH ROW
    EXECUTE FUNCTION update_modified_date();

-- Function to log appointment status changes
CREATE OR REPLACE FUNCTION log_appointment_status_change()
RETURNS TRIGGER AS $
BEGIN
    IF NEW.status != OLD.status THEN
        INSERT INTO activity_log (agent_id, activity_type, entity_type, entity_id, description)
        VALUES (
            NEW.agent_id,
            'appointment_status_changed',
            'appointment',
            NEW.appointment_id,
            'Appointment "' || NEW.title || '" status changed from ' || OLD.status || ' to ' || NEW.status
        );
    END IF;
    RETURN NEW;
END;
$ LANGUAGE plpgsql;

-- Trigger to log appointment status changes
DROP TRIGGER IF EXISTS tr_appointments_status_change ON appointments;
CREATE TRIGGER tr_appointments_status_change
    AFTER UPDATE ON appointments
    FOR EACH ROW
    EXECUTE FUNCTION log_appointment_status_change();

-- Function to auto-create reminders for policy expiry
CREATE OR REPLACE FUNCTION create_policy_expiry_reminder()
RETURNS TRIGGER AS $
BEGIN
    IF NEW.status = 'Active' AND NEW.end_date > CURRENT_DATE + INTERVAL '30 days' THEN
        INSERT INTO reminders (
            client_id, agent_id, reminder_type, title, description, reminder_date, priority, enable_push_notification
        )
        SELECT 
            NEW.client_id,
            c.agent_id,
            'Policy Expiry',
            'Policy Expiring: ' || NEW.policy_name,
            'Policy expires on ' || TO_CHAR(NEW.end_date, 'Month DD, YYYY'),
            NEW.end_date - INTERVAL '30 days',
            'High',
            true
        FROM clients c
        WHERE c.client_id = NEW.client_id
        AND NOT EXISTS (
            SELECT 1 FROM reminders r 
            WHERE r.client_id = NEW.client_id 
            AND r.reminder_type = 'Policy Expiry' 
            AND r.reminder_date = NEW.end_date - INTERVAL '30 days'
            AND r.status = 'Active'
        );
    END IF;
    RETURN NEW;
END;
$ LANGUAGE plpgsql;

-- Trigger to auto-create reminders for policy expiry
DROP TRIGGER IF EXISTS tr_client_policies_expiry_reminder ON client_policies;
CREATE TRIGGER tr_client_policies_expiry_reminder
    AFTER INSERT OR UPDATE ON client_policies
    FOR EACH ROW
    EXECUTE FUNCTION create_policy_expiry_reminder();

-- ============================================
-- FUNCTIONS FOR COMMON CALCULATIONS
-- ============================================

-- Function to calculate client age
CREATE OR REPLACE FUNCTION fn_calculate_age(date_of_birth DATE)
RETURNS INTEGER AS $
DECLARE
    age INTEGER;
BEGIN
    age := EXTRACT(YEAR FROM age(date_of_birth));
    RETURN age;
END;
$ LANGUAGE plpgsql;

-- Function to get days until expiry
CREATE OR REPLACE FUNCTION fn_days_until_expiry(expiry_date DATE)
RETURNS INTEGER AS $
BEGIN
    RETURN (expiry_date - CURRENT_DATE);
END;
$ LANGUAGE plpgsql;

-- Function to format client full name
CREATE OR REPLACE FUNCTION fn_format_client_name(first_name VARCHAR(50),
    surname VARCHAR(50),
    last_name VARCHAR(50) DEFAULT NULL)
RETURNS VARCHAR(152) AS $$
BEGIN
    RETURN TRIM(first_name || ' ' || surname || ' ' || COALESCE(last_name, ''));
END;
$ LANGUAGE plpgsql;

-- ============================================
-- POLICY CATALOG PROCEDURES
-- ============================================

-- Get Policy Catalog
CREATE OR REPLACE FUNCTION sp_get_policy_catalog(p_agent_id UUID DEFAULT NULL,
    p_company_id UUID DEFAULT NULL,
    p_category_id UUID DEFAULT NULL,
    p_type_id UUID DEFAULT NULL,
    p_is_active BOOLEAN DEFAULT true)
RETURNS TABLE(
    policy_catalog_id UUID,
    agent_id UUID,
    policy_name VARCHAR(100),
    company_id UUID,
    company_name VARCHAR(100),
    notes TEXT,
    is_active BOOLEAN,
    created_date TIMESTAMP,
    modified_date TIMESTAMP,
    category_id UUID,
    category_name VARCHAR(100),
    type_id UUID,
    type_name VARCHAR(100)
)
LANGUAGE plpgsql
AS $
BEGIN
    RETURN QUERY
    SELECT 
        pc.policy_catalog_id,
        pc.agent_id,
        pc.policy_name,
        pc.company_id,
        ic.company_name,
        pc.notes,
        pc.is_active,
        pc.created_date,
        pc.modified_date,
        pc.category_id,
        pcat.category_name,
        pc.type_id,
        pt.type_name
    FROM policy_catalog pc
        LEFT JOIN insurance_company ic ON pc.company_id = ic.company_id
        LEFT JOIN policy_category pcat ON pc.category_id = pcat.category_id
        LEFT JOIN policy_type pt ON pc.type_id = pt.type_id
    WHERE (p_agent_id IS NULL OR pc.agent_id = p_agent_id)
        AND (p_company_id IS NULL OR pc.company_id = p_company_id)
        AND (p_category_id IS NULL OR pc.category_id = p_category_id)
        AND (p_type_id IS NULL OR pc.type_id = p_type_id)
        AND (p_is_active IS NULL OR pc.is_active = p_is_active)
    ORDER BY pc.policy_name;
END;
$;

-- Create Policy Catalog Item
CREATE OR REPLACE FUNCTION sp_create_policy_catalog_item(p_agent_id UUID,
    p_policy_name VARCHAR(100),
    p_company_id UUID,
    p_notes TEXT DEFAULT NULL,
    p_category_id UUID DEFAULT NULL,
    p_type_id UUID DEFAULT NULL)
RETURNS TABLE(policy_catalog_id UUID)
LANGUAGE plpgsql
AS $$
DECLARE
    v_policy_catalog_id UUID := gen_random_uuid();
BEGIN
    INSERT INTO policy_catalog (
        policy_catalog_id, agent_id, policy_name, company_id, 
        notes, category_id, type_id, is_active, created_date
    )
    VALUES (
        v_policy_catalog_id, p_agent_id, p_policy_name, p_company_id,
        p_notes, p_category_id, p_type_id, true, NOW() AT TIME ZONE 'UTC'
    );
    
    RETURN QUERY SELECT v_policy_catalog_id;
END;
$;

-- Update Policy Catalog Item
CREATE OR REPLACE FUNCTION sp_update_policy_catalog_item(p_policy_catalog_id UUID,
    p_policy_name VARCHAR(100) DEFAULT NULL,
    p_company_id UUID DEFAULT NULL,
    p_notes TEXT DEFAULT NULL,
    p_category_id UUID DEFAULT NULL,
    p_type_id UUID DEFAULT NULL,
    p_is_active BOOLEAN DEFAULT NULL)
RETURNS TABLE(rows_affected INTEGER)
LANGUAGE plpgsql
AS $$
DECLARE
    v_rows_affected INTEGER;
BEGIN
    UPDATE policy_catalog
    SET 
        policy_name = COALESCE(p_policy_name, policy_name),
        company_id = COALESCE(p_company_id, company_id),
        notes = COALESCE(p_notes, notes),
        category_id = COALESCE(p_category_id, category_id),
        type_id = COALESCE(p_type_id, type_id),
        is_active = COALESCE(p_is_active, is_active),
        modified_date = NOW() AT TIME ZONE 'UTC'
    WHERE policy_catalog_id = p_policy_catalog_id;
    
    GET DIAGNOSTICS v_rows_affected = ROW_COUNT;
    
    RETURN QUERY SELECT v_rows_affected;
END;
$;

-- Update Policy Catalog Item
CREATE OR REPLACE FUNCTION sp_update_policy_catalog_item(p_policy_catalog_id UUID,
    p_policy_name VARCHAR(100) DEFAULT NULL,
    p_company_id UUID DEFAULT NULL,
    p_notes TEXT DEFAULT NULL,
    p_category_id UUID DEFAULT NULL,
    p_type_id UUID DEFAULT NULL,
    p_is_active BOOLEAN DEFAULT NULL)
RETURNS TABLE(rows_affected INTEGER)
LANGUAGE plpgsql
AS $$
DECLARE
    v_rows_affected INTEGER;
BEGIN
    UPDATE policy_catalog
    SET 
        policy_name = COALESCE(p_policy_name, policy_name),
        company_id = COALESCE(p_company_id, company_id),
        notes = COALESCE(p_notes, notes),
        category_id = COALESCE(p_category_id, category_id),
        type_id = COALESCE(p_type_id, type_id),
        is_active = COALESCE(p_is_active, is_active),
        modified_date = NOW() AT TIME ZONE 'UTC'
    WHERE policy_catalog_id = p_policy_catalog_id;
    
    GET DIAGNOSTICS v_rows_affected = ROW_COUNT;
    
    RETURN QUERY SELECT v_rows_affected;
END;
$;

-- Delete Policy Catalog Item
CREATE OR REPLACE FUNCTION sp_delete_policy_catalog_item(p_policy_catalog_id UUID,
    p_hard_delete BOOLEAN DEFAULT false)
RETURNS TABLE(rows_affected INTEGER)
LANGUAGE plpgsql
AS $
DECLARE
    v_rows_affected INTEGER;
BEGIN
    IF p_hard_delete = true THEN
        DELETE FROM policy_catalog WHERE policy_catalog_id = p_policy_catalog_id;
    ELSE
        UPDATE policy_catalog 
        SET is_active = false, modified_date = NOW() AT TIME ZONE 'UTC'
        WHERE policy_catalog_id = p_policy_catalog_id;
    END IF;
    
    GET DIAGNOSTICS v_rows_affected = ROW_COUNT;
    
    RETURN QUERY SELECT v_rows_affected;
END;
$;

-- Upsert Policy Catalog
CREATE OR REPLACE FUNCTION sp_upsert_policy_catalog(p_agent_id UUID,
    p_policy_name VARCHAR(100),
    p_company_id UUID,
    p_policy_catalog_id UUID DEFAULT NULL,
    p_notes TEXT DEFAULT NULL,
    p_category_id UUID DEFAULT NULL,
    p_type_id UUID DEFAULT NULL)
RETURNS TABLE(policy_catalog_id UUID)
LANGUAGE plpgsql
AS $$
DECLARE
    v_policy_catalog_id UUID := p_policy_catalog_id;
BEGIN
    IF v_policy_catalog_id IS NULL OR NOT EXISTS (SELECT 1 FROM policy_catalog WHERE policy_catalog_id = v_policy_catalog_id) THEN
        -- Insert new record
        v_policy_catalog_id := gen_random_uuid();
        INSERT INTO policy_catalog (
            policy_catalog_id, agent_id, policy_name, company_id, 
            notes, category_id, type_id, is_active, created_date
        )
        VALUES (
            v_policy_catalog_id, p_agent_id, p_policy_name, p_company_id,
            p_notes, p_category_id, p_type_id, true, NOW() AT TIME ZONE 'UTC'
        );
    ELSE
        -- Update existing record
        UPDATE policy_catalog
        SET 
            policy_name = p_policy_name,
            company_id = p_company_id,
            notes = p_notes,
            category_id = p_category_id,
            type_id = p_type_id,
            modified_date = NOW() AT TIME ZONE 'UTC'
        WHERE policy_catalog_id = v_policy_catalog_id;
    END IF;
    
    RETURN QUERY SELECT v_policy_catalog_id;
END;
$;

-- ============================================
-- CLIENT POLICIES PROCEDURES
-- ============================================

-- Get Client Policies
CREATE OR REPLACE FUNCTION sp_get_client_policies(p_client_id UUID DEFAULT NULL,
    p_agent_id UUID DEFAULT NULL,
    p_status VARCHAR(20) DEFAULT NULL,
    p_is_active BOOLEAN DEFAULT true)
RETURNS TABLE(
    policy_id UUID,
    client_id UUID,
    policy_name VARCHAR(100),
    status VARCHAR(20),
    start_date DATE,
    end_date DATE,
    notes TEXT,
    created_date TIMESTAMP,
    modified_date TIMESTAMP,
    is_active BOOLEAN,
    policy_catalog_id UUID,
    catalog_policy_name VARCHAR(100),
    type_id UUID,
    type_name VARCHAR(100),
    company_id UUID,
    company_name VARCHAR(100),
    days_until_expiry INTEGER
)
LANGUAGE plpgsql
AS $$
BEGIN
    RETURN QUERY
    SELECT 
        cp.policy_id,
        cp.client_id,
        cp.policy_name,
        cp.status,
        cp.start_date,
        cp.end_date,
        cp.notes,
        cp.created_date,
        cp.modified_date,
        cp.is_active,
        cp.policy_catalog_id,
        pc.policy_name as catalog_policy_name,
        cp.type_id,
        pt.type_name,
        cp.company_id,
        ic.company_name,
        (cp.end_date - CURRENT_DATE) as days_until_expiry
    FROM client_policies cp
        LEFT JOIN policy_catalog pc ON cp.policy_catalog_id = pc.policy_catalog_id
        LEFT JOIN policy_type pt ON cp.type_id = pt.type_id
        LEFT JOIN insurance_company ic ON cp.company_id = ic.company_id
    WHERE (p_client_id IS NULL OR cp.client_id = p_client_id)
        AND (p_agent_id IS NULL OR pc.agent_id = p_agent_id)
        AND (p_status IS NULL OR cp.status = p_status)
        AND (p_is_active IS NULL OR cp.is_active = p_is_active)
    ORDER BY cp.end_date DESC;
END;
$;

-- Get Policy By ID
CREATE OR REPLACE FUNCTION sp_get_policy_by_id(p_policy_id UUID)
RETURNS TABLE(
    policy_id UUID,
    client_id UUID,
    policy_name VARCHAR(100),
    status VARCHAR(20),
    start_date DATE,
    end_date DATE,
    notes TEXT,
    created_date TIMESTAMP,
    modified_date TIMESTAMP,
    is_active BOOLEAN,
    policy_catalog_id UUID,
    catalog_policy_name VARCHAR(100),
    type_id UUID,
    type_name VARCHAR(100),
    company_id UUID,
    company_name VARCHAR(100),
    days_until_expiry INTEGER
)
LANGUAGE plpgsql
AS $
BEGIN
    RETURN QUERY
    SELECT 
        cp.policy_id,
        cp.client_id,
        cp.policy_name,
        cp.status,
        cp.start_date,
        cp.end_date,
        cp.notes,
        cp.created_date,
        cp.modified_date,
        cp.is_active,
        cp.policy_catalog_id,
        pc.policy_name as catalog_policy_name,
        cp.type_id,
        pt.type_name,
        cp.company_id,
        ic.company_name,
        (cp.end_date - CURRENT_DATE) as days_until_expiry
    FROM client_policies cp
        LEFT JOIN policy_catalog pc ON cp.policy_catalog_id = pc.policy_catalog_id
        LEFT JOIN policy_type pt ON cp.type_id = pt.type_id
        LEFT JOIN insurance_company ic ON cp.company_id = ic.company_id
    WHERE cp.policy_id = p_policy_id;
END;
$;

-- Create Client Policy
CREATE OR REPLACE FUNCTION sp_create_client_policy(p_client_id UUID,
    p_policy_name VARCHAR(100),
    p_start_date DATE,
    p_end_date DATE,
    p_status VARCHAR(20) DEFAULT 'Active',
    p_notes TEXT DEFAULT NULL,
    p_policy_catalog_id UUID DEFAULT NULL)
RETURNS TABLE(policy_id UUID)
LANGUAGE plpgsql
AS $$
DECLARE
    v_policy_id UUID := gen_random_uuid();
    v_company_id UUID;
    v_type_id UUID;
BEGIN
    -- Pull company_id and type_id from policy_catalog
    SELECT 
        company_id,
        type_id
    INTO v_company_id, v_type_id
    FROM policy_catalog
    WHERE policy_catalog_id = p_policy_catalog_id;

    INSERT INTO client_policies (
        policy_id, client_id, policy_name, status, start_date, end_date,
        notes, policy_catalog_id, type_id, company_id, is_active, created_date
    )
    VALUES (
        v_policy_id, p_client_id, p_policy_name, p_status, p_start_date, p_end_date,
        p_notes, p_policy_catalog_id, v_type_id, v_company_id, true, NOW() AT TIME ZONE 'UTC'
    );
    
    RETURN QUERY SELECT v_policy_id;
END;
$;

-- Update Client Policy
CREATE OR REPLACE FUNCTION sp_update_client_policy(p_policy_id UUID,
    p_policy_name VARCHAR(100) DEFAULT NULL,
    p_status VARCHAR(20) DEFAULT NULL,
    p_start_date DATE DEFAULT NULL,
    p_end_date DATE DEFAULT NULL,
    p_notes TEXT DEFAULT NULL,
    p_policy_catalog_id UUID DEFAULT NULL,
    p_type_id UUID DEFAULT NULL,
    p_company_id UUID DEFAULT NULL,
    p_is_active BOOLEAN DEFAULT NULL)
RETURNS TABLE(rows_affected INTEGER)
LANGUAGE plpgsql
AS $$
DECLARE
    v_rows_affected INTEGER;
BEGIN
    UPDATE client_policies
    SET 
        policy_name = COALESCE(p_policy_name, policy_name),
        status = COALESCE(p_status, status),
        start_date = COALESCE(p_start_date, start_date),
        end_date = COALESCE(p_end_date, end_date),
        notes = COALESCE(p_notes, notes),
        policy_catalog_id = COALESCE(p_policy_catalog_id, policy_catalog_id),
        type_id = COALESCE(p_type_id, type_id),
        company_id = COALESCE(p_company_id, company_id),
        is_active = COALESCE(p_is_active, is_active),
        modified_date = NOW() AT TIME ZONE 'UTC'
    WHERE policy_id = p_policy_id;
    
    GET DIAGNOSTICS v_rows_affected = ROW_COUNT;
    
    RETURN QUERY SELECT v_rows_affected;
END;
$;

-- Delete Client Policy
CREATE OR REPLACE FUNCTION sp_delete_client_policy(p_policy_id UUID,
    p_hard_delete BOOLEAN DEFAULT false)
RETURNS TABLE(rows_affected INTEGER)
LANGUAGE plpgsql
AS $
DECLARE
    v_rows_affected INTEGER;
BEGIN
    IF p_hard_delete = true THEN
        DELETE FROM client_policies WHERE policy_id = p_policy_id;
    ELSE
        UPDATE client_policies 
        SET is_active = false, status = 'Cancelled', modified_date = NOW() AT TIME ZONE 'UTC'
        WHERE policy_id = p_policy_id;
    END IF;
    
    GET DIAGNOSTICS v_rows_affected = ROW_COUNT;
    
    RETURN QUERY SELECT v_rows_affected;
END;
$;

-- Upsert Client Policy
CREATE OR REPLACE FUNCTION sp_upsert_client_policy(p_client_id UUID,
    p_policy_name VARCHAR(100),
    p_start_date DATE,
    p_end_date DATE,
    p_policy_id UUID DEFAULT NULL,
    p_status VARCHAR(20) DEFAULT 'Active',
    p_notes TEXT DEFAULT NULL,
    p_policy_catalog_id UUID DEFAULT NULL,
    p_type_id UUID DEFAULT NULL,
    p_company_id UUID DEFAULT NULL)
RETURNS TABLE(policy_id UUID)
LANGUAGE plpgsql
AS $$
DECLARE
    v_policy_id UUID := p_policy_id;
BEGIN
    IF v_policy_id IS NULL OR NOT EXISTS (SELECT 1 FROM client_policies WHERE policy_id = v_policy_id) THEN
        -- Insert new record
        v_policy_id := gen_random_uuid();
        INSERT INTO client_policies (
            policy_id, client_id, policy_name, status, start_date, end_date,
            notes, policy_catalog_id, type_id, company_id, is_active, created_date
        )
        VALUES (
            v_policy_id, p_client_id, p_policy_name, p_status, p_start_date, p_end_date,
            p_notes, p_policy_catalog_id, p_type_id, p_company_id, true, NOW() AT TIME ZONE 'UTC'
        );
    ELSE
        -- Update existing record
        UPDATE client_policies
        SET 
            policy_name = p_policy_name,
            status = p_status,
            start_date = p_start_date,
            end_date = p_end_date,
            notes = p_notes,
            policy_catalog_id = p_policy_catalog_id,
            type_id = p_type_id,
            company_id = p_company_id,
            modified_date = NOW() AT TIME ZONE 'UTC'
        WHERE policy_id = v_policy_id;
    END IF;
    
    RETURN QUERY SELECT v_policy_id;
END;
$;

-- Get Expiring Policies
CREATE OR REPLACE FUNCTION sp_get_expiring_policies(p_agent_id UUID DEFAULT NULL,
    p_days_ahead INTEGER DEFAULT 30,
    p_status VARCHAR(20) DEFAULT 'Active')
RETURNS TABLE(
    policy_id UUID,
    client_id UUID,
    policy_name VARCHAR(100),
    status VARCHAR(20),
    start_date DATE,
    end_date DATE,
    notes TEXT,
    company_id UUID,
    company_name VARCHAR(100),
    type_id UUID,
    type_name VARCHAR(100),
    days_until_expiry INTEGER
)
LANGUAGE plpgsql
AS $$
BEGIN
    RETURN QUERY
    SELECT 
        cp.policy_id,
        cp.client_id,
        cp.policy_name,
        cp.status,
        cp.start_date,
        cp.end_date,
        cp.notes,
        cp.company_id,
        ic.company_name,
        cp.type_id,
        pt.type_name,
        (cp.end_date - CURRENT_DATE) as days_until_expiry
    FROM client_policies cp
        LEFT JOIN policy_catalog pc ON cp.policy_catalog_id = pc.policy_catalog_id
        LEFT JOIN policy_type pt ON cp.type_id = pt.type_id
        LEFT JOIN insurance_company ic ON cp.company_id = ic.company_id
    WHERE cp.is_active = true
        AND cp.status = p_status
        AND cp.end_date BETWEEN CURRENT_DATE AND CURRENT_DATE + INTERVAL '1 day' * p_days_ahead
        AND (p_agent_id IS NULL OR pc.agent_id = p_agent_id)
    ORDER BY cp.end_date;
END;
$;

-- Get Policy Statistics
CREATE OR REPLACE FUNCTION sp_get_policy_statistics(p_agent_id UUID DEFAULT NULL,
    p_start_date DATE DEFAULT NULL,
    p_end_date DATE DEFAULT NULL)
RETURNS TABLE(
    total_policies BIGINT,
    active_policies BIGINT,
    expired_policies BIGINT,
    cancelled_policies BIGINT,
    expiring_in_30_days BIGINT,
    expiring_in_60_days BIGINT
)
LANGUAGE plpgsql
AS $
DECLARE
    v_start_date DATE := COALESCE(p_start_date, CURRENT_DATE - INTERVAL '1 year');
    v_end_date DATE := COALESCE(p_end_date, CURRENT_DATE);
BEGIN
    RETURN QUERY
    SELECT 
        COUNT(*) as total_policies,
        SUM(CASE WHEN cp.status = 'Active' THEN 1 ELSE 0 END) as active_policies,
        SUM(CASE WHEN cp.status = 'Expired' THEN 1 ELSE 0 END) as expired_policies,
        SUM(CASE WHEN cp.status = 'Cancelled' THEN 1 ELSE 0 END) as cancelled_policies,
        SUM(CASE WHEN cp.end_date BETWEEN CURRENT_DATE AND CURRENT_DATE + INTERVAL '30 days' THEN 1 ELSE 0 END) as expiring_in_30_days,
        SUM(CASE WHEN cp.end_date BETWEEN CURRENT_DATE AND CURRENT_DATE + INTERVAL '60 days' THEN 1 ELSE 0 END) as expiring_in_60_days
    FROM client_policies cp
        LEFT JOIN policy_catalog pc ON cp.policy_catalog_id = pc.policy_catalog_id
    WHERE cp.is_active = true
        AND cp.created_date BETWEEN v_start_date AND v_end_date
        AND (p_agent_id IS NULL OR pc.agent_id = p_agent_id);
END;
$;

-- Get Policy Statistics Detailed
CREATE OR REPLACE FUNCTION sp_get_policy_statistics_detailed(p_agent_id UUID DEFAULT NULL,
    p_start_date DATE DEFAULT NULL,
    p_end_date DATE DEFAULT NULL)
RETURNS TABLE(
    group_type VARCHAR(20),
    group_name VARCHAR(100),
    policy_count BIGINT,
    active_count BIGINT
)
LANGUAGE plpgsql
AS $
DECLARE
    v_start_date DATE := COALESCE(p_start_date, CURRENT_DATE - INTERVAL '1 year');
    v_end_date DATE := COALESCE(p_end_date, CURRENT_DATE);
BEGIN
    -- By Company
    RETURN QUERY
    SELECT 
        'By Company'::VARCHAR(20) as group_type,
        ic.company_name::VARCHAR(100) as group_name,
        COUNT(*) as policy_count,
        SUM(CASE WHEN cp.status = 'Active' THEN 1 ELSE 0 END) as active_count
    FROM client_policies cp
        LEFT JOIN insurance_company ic ON cp.company_id = ic.company_id
        LEFT JOIN policy_catalog pc ON cp.policy_catalog_id = pc.policy_catalog_id
    WHERE cp.is_active = true
        AND cp.created_date BETWEEN v_start_date AND v_end_date
        AND (p_agent_id IS NULL OR pc.agent_id = p_agent_id)
    GROUP BY ic.company_name
    
    UNION ALL
    
    -- By Type
    SELECT 
        'By Type'::VARCHAR(20) as group_type,
        pt.type_name::VARCHAR(100) as group_name,
        COUNT(*) as policy_count,
        SUM(CASE WHEN cp.status = 'Active' THEN 1 ELSE 0 END) as active_count
    FROM client_policies cp
        LEFT JOIN policy_type pt ON cp.type_id = pt.type_id
        LEFT JOIN policy_catalog pc ON cp.policy_catalog_id = pc.policy_catalog_id
    WHERE cp.is_active = true
        AND cp.created_date BETWEEN v_start_date AND v_end_date
        AND (p_agent_id IS NULL OR pc.agent_id = p_agent_id)
    GROUP BY pt.type_name
    
    ORDER BY group_type, policy_count DESC;
END;
$;

-- ============================================
-- POLICY SEARCH AND FILTERING PROCEDURES
-- ============================================

-- Search Policies
CREATE OR REPLACE FUNCTION sp_search_policies(p_search_term VARCHAR(100) DEFAULT NULL,
    p_agent_id UUID DEFAULT NULL,
    p_client_id UUID DEFAULT NULL,
    p_company_id UUID DEFAULT NULL,
    p_type_id UUID DEFAULT NULL,
    p_status VARCHAR(20) DEFAULT NULL,
    p_start_date DATE DEFAULT NULL,
    p_end_date DATE DEFAULT NULL,
    p_page_size INTEGER DEFAULT 50,
    p_page_number INTEGER DEFAULT 1)
RETURNS TABLE(
    policy_id UUID,
    client_id UUID,
    policy_name VARCHAR(100),
    status VARCHAR(20),
    start_date DATE,
    end_date DATE,
    notes TEXT,
    company_id UUID,
    company_name VARCHAR(100),
    type_id UUID,
    type_name VARCHAR(100),
    policy_catalog_id UUID,
    catalog_policy_name VARCHAR(100),
    days_until_expiry INTEGER
)
LANGUAGE plpgsql
AS $$
DECLARE
    v_offset INTEGER := (p_page_number - 1) * p_page_size;
BEGIN
    RETURN QUERY
    SELECT 
        cp.policy_id,
        cp.client_id,
        cp.policy_name,
        cp.status,
        cp.start_date,
        cp.end_date,
        cp.notes,
        cp.company_id,
        ic.company_name,
        cp.type_id,
        pt.type_name,
        cp.policy_catalog_id,
        pc.policy_name as catalog_policy_name,
        (cp.end_date - CURRENT_DATE) as days_until_expiry
    FROM client_policies cp
        LEFT JOIN policy_catalog pc ON cp.policy_catalog_id = pc.policy_catalog_id
        LEFT JOIN policy_type pt ON cp.type_id = pt.type_id
        LEFT JOIN insurance_company ic ON cp.company_id = ic.company_id
    WHERE cp.is_active = true
        AND (p_search_term IS NULL OR cp.policy_name ILIKE '%' || p_search_term || '%' OR cp.notes ILIKE '%' || p_search_term || '%')
        AND (p_agent_id IS NULL OR pc.agent_id = p_agent_id)
        AND (p_client_id IS NULL OR cp.client_id = p_client_id)
        AND (p_company_id IS NULL OR cp.company_id = p_company_id)
        AND (p_type_id IS NULL OR cp.type_id = p_type_id)
        AND (p_status IS NULL OR cp.status = p_status)
        AND (p_start_date IS NULL OR cp.start_date >= p_start_date)
        AND (p_end_date IS NULL OR cp.end_date <= p_end_date)
    ORDER BY cp.created_date DESC
    LIMIT p_page_size OFFSET v_offset;
END;
$;

-- ============================================
-- POLICY RETRIEVAL FUNCTIONS
-- ============================================

-- Get Policies by Status
DROP FUNCTION IF EXISTS get_policies_by_status(VARCHAR, UUID);

CREATE OR REPLACE FUNCTION get_policies_by_status(p_status VARCHAR(20),
    p_agent_id UUID DEFAULT NULL)
RETURNS TABLE (
    policy_id UUID,
    client_id UUID,
    policy_name VARCHAR(100),
    status VARCHAR(20),
    start_date DATE,
    end_date DATE,
    company_id UUID,
    company_name VARCHAR(100),
    type_id UUID,
    type_name VARCHAR(50),
    days_until_expiry INTEGER
) 
LANGUAGE plpgsql
AS $$
BEGIN
    RETURN QUERY
    SELECT 
        cp.policy_id,
        cp.client_id,
        cp.policy_name,
        cp.status,
        cp.start_date,
        cp.end_date,
        cp.company_id,
        ic.company_name,
        cp.type_id,
        pt.type_name,
        (cp.end_date - CURRENT_DATE)::INTEGER as days_until_expiry
    FROM client_policies cp
        LEFT JOIN policy_catalog pc ON cp.policy_catalog_id = pc.policy_catalog_id
        LEFT JOIN policy_types pt ON cp.type_id = pt.type_id
        LEFT JOIN insurance_companies ic ON cp.company_id = ic.company_id
    WHERE cp.is_active = true
        AND cp.status = p_status
        AND (p_agent_id IS NULL OR pc.agent_id = p_agent_id)
    ORDER BY cp.end_date;
END;
$;

-- ============================================
-- POLICY MANAGEMENT ACTIONS
-- ============================================

-- Renew Policy
DROP FUNCTION IF EXISTS renew_policy(UUID, DATE, DATE, VARCHAR, TEXT);

CREATE OR REPLACE FUNCTION renew_policy(p_policy_id UUID,
    p_new_start_date DATE,
    p_new_end_date DATE,
    p_new_policy_name VARCHAR(100) DEFAULT NULL,
    p_notes TEXT DEFAULT NULL)
RETURNS TABLE (
    new_policy_id UUID,
    rows_affected INTEGER
)
LANGUAGE plpgsql
AS $$
DECLARE
    v_client_id UUID;
    v_policy_name VARCHAR(100);
    v_policy_catalog_id UUID;
    v_type_id UUID;
    v_company_id UUID;
    v_new_policy_id UUID;
    v_rows_affected INTEGER;
BEGIN
    -- Generate new policy ID
    v_new_policy_id := gen_random_uuid();
    
    -- Start transaction (implicit in function)
    
    -- Update old policy status
    UPDATE client_policies 
    SET status = 'Renewed', modified_date = CURRENT_TIMESTAMP
    WHERE policy_id = p_policy_id;
    
    GET DIAGNOSTICS v_rows_affected = ROW_COUNT;
    
    IF v_rows_affected = 0 THEN
        RAISE EXCEPTION 'Policy with ID % not found', p_policy_id;
    END IF;
    
    -- Get policy details for renewal
    SELECT 
        client_id,
        COALESCE(p_new_policy_name, policy_name),
        policy_catalog_id,
        type_id,
        company_id
    INTO 
        v_client_id,
        v_policy_name,
        v_policy_catalog_id,
        v_type_id,
        v_company_id
    FROM client_policies 
    WHERE policy_id = p_policy_id;
    
    -- Create new policy
    INSERT INTO client_policies (
        policy_id, client_id, policy_name, status, start_date, end_date,
        notes, policy_catalog_id, type_id, company_id, is_active, created_date
    )
    VALUES (
        v_new_policy_id, v_client_id, v_policy_name, 'Active', p_new_start_date, p_new_end_date,
        p_notes, v_policy_catalog_id, v_type_id, v_company_id, true, CURRENT_TIMESTAMP
    );
    
    RETURN QUERY SELECT v_new_policy_id, 1;
END;
$;

-- Bulk Update Policy Status
DROP FUNCTION IF EXISTS bulk_update_policy_status(TEXT, VARCHAR);

CREATE OR REPLACE FUNCTION bulk_update_policy_status(p_policy_ids TEXT,
    -- Comma-separated list of UUIDs
    p_new_status VARCHAR(20))
RETURNS TABLE (
    rows_affected INTEGER
)
LANGUAGE plpgsql
AS $$
DECLARE
    v_rows_affected INTEGER;
    policy_id_array UUID[];
BEGIN
    -- Convert comma-separated string to UUID array
    SELECT ARRAY(
        SELECT CAST(TRIM(unnest(string_to_array(p_policy_ids, ','))) AS UUID)
    ) INTO policy_id_array;
    
    -- Update policies
    UPDATE client_policies
    SET status = p_new_status, modified_date = CURRENT_TIMESTAMP
    WHERE policy_id = ANY(policy_id_array);
    
    GET DIAGNOSTICS v_rows_affected = ROW_COUNT;
    
    RETURN QUERY SELECT v_rows_affected;
END;
$;

-- ============================================
-- POLICY TEMPLATES FUNCTIONS
-- ============================================

-- Get Policy Templates
DROP FUNCTION IF EXISTS get_policy_templates(UUID, UUID, UUID, BOOLEAN);

CREATE OR REPLACE FUNCTION get_policy_templates(p_agent_id UUID DEFAULT NULL,
    p_category_id UUID DEFAULT NULL,
    p_type_id UUID DEFAULT NULL,
    p_is_active BOOLEAN DEFAULT true)
RETURNS TABLE (
    template_id UUID,
    agent_id UUID,
    template_name VARCHAR(100),
    default_term_months INTEGER,
    default_premium DECIMAL(18, 2),
    coverage_description TEXT,
    terms TEXT,
    is_active BOOLEAN,
    created_date TIMESTAMP,
    category_id UUID,
    category_name VARCHAR(50),
    policy_catalog_id UUID,
    catalog_policy_name VARCHAR(100),
    type_id UUID,
    type_name VARCHAR(50)
)
LANGUAGE plpgsql
AS $
BEGIN
    RETURN QUERY
    SELECT 
        pt.template_id,
        pt.agent_id,
        pt.template_name,
        pt.default_term_months,
        pt.default_premium,
        pt.coverage_description,
        pt.terms,
        pt.is_active,
        pt.created_date,
        pt.category_id,
        pc.category_name,
        pt.policy_catalog_id,
        pol.policy_name as catalog_policy_name,
        pt.type_id,
        pty.type_name
    FROM policy_templates pt
        LEFT JOIN policy_categories pc ON pt.category_id = pc.category_id
        LEFT JOIN policy_catalog pol ON pt.policy_catalog_id = pol.policy_catalog_id
        LEFT JOIN policy_types pty ON pt.type_id = pty.type_id
    WHERE (p_agent_id IS NULL OR pt.agent_id = p_agent_id)
        AND (p_category_id IS NULL OR pt.category_id = p_category_id)
        AND (p_type_id IS NULL OR pt.type_id = p_type_id)
        AND (p_is_active IS NULL OR pt.is_active = p_is_active)
    ORDER BY pt.template_name;
END;
$;

-- Create Policy Template
DROP FUNCTION IF EXISTS create_policy_template(UUID, VARCHAR, INTEGER, DECIMAL, TEXT, TEXT, UUID, UUID, UUID);

CREATE OR REPLACE FUNCTION create_policy_template(p_agent_id UUID,
    p_template_name VARCHAR(100),
    p_default_term_months INTEGER DEFAULT NULL,
    p_default_premium DECIMAL(18, 2) DEFAULT NULL,
    p_coverage_description TEXT DEFAULT NULL,
    p_terms TEXT DEFAULT NULL,
    p_category_id UUID DEFAULT NULL,
    p_policy_catalog_id UUID DEFAULT NULL,
    p_type_id UUID DEFAULT NULL)
RETURNS TABLE (
    template_id UUID
)
LANGUAGE plpgsql
AS $$
DECLARE
    v_template_id UUID;
BEGIN
    v_template_id := gen_random_uuid();
    
    INSERT INTO policy_templates (
        template_id, agent_id, template_name, default_term_months, default_premium,
        coverage_description, terms, category_id, policy_catalog_id, type_id, is_active, created_date
    )
    VALUES (
        v_template_id, p_agent_id, p_template_name, p_default_term_months, p_default_premium,
        p_coverage_description, p_terms, p_category_id, p_policy_catalog_id, p_type_id, true, CURRENT_TIMESTAMP
    );
    
    RETURN QUERY SELECT v_template_id;
END;
$;

-- Update Policy Template
DROP FUNCTION IF EXISTS update_policy_template(UUID, VARCHAR, INTEGER, DECIMAL, TEXT, TEXT, UUID, UUID, UUID, BOOLEAN);

CREATE OR REPLACE FUNCTION update_policy_template(p_template_id UUID,
    p_template_name VARCHAR(100) DEFAULT NULL,
    p_default_term_months INTEGER DEFAULT NULL,
    p_default_premium DECIMAL(18, 2) DEFAULT NULL,
    p_coverage_description TEXT DEFAULT NULL,
    p_terms TEXT DEFAULT NULL,
    p_category_id UUID DEFAULT NULL,
    p_policy_catalog_id UUID DEFAULT NULL,
    p_type_id UUID DEFAULT NULL,
    p_is_active BOOLEAN DEFAULT NULL)
RETURNS TABLE (
    rows_affected INTEGER
)
LANGUAGE plpgsql
AS $$
DECLARE
    v_rows_affected INTEGER;
BEGIN
    UPDATE policy_templates
    SET 
        template_name = COALESCE(p_template_name, template_name),
        default_term_months = COALESCE(p_default_term_months, default_term_months),
        default_premium = COALESCE(p_default_premium, default_premium),
        coverage_description = COALESCE(p_coverage_description, coverage_description),
        terms = COALESCE(p_terms, terms),
        category_id = COALESCE(p_category_id, category_id),
        policy_catalog_id = COALESCE(p_policy_catalog_id, policy_catalog_id),
        type_id = COALESCE(p_type_id, type_id),
        is_active = COALESCE(p_is_active, is_active),
        modified_date = CURRENT_TIMESTAMP
    WHERE template_id = p_template_id;
    
    GET DIAGNOSTICS v_rows_affected = ROW_COUNT;
    
    RETURN QUERY SELECT v_rows_affected;
END;
$;

-- Delete Policy Template
DROP FUNCTION IF EXISTS delete_policy_template(UUID, BOOLEAN);

CREATE OR REPLACE FUNCTION delete_policy_template(p_template_id UUID,
    p_hard_delete BOOLEAN DEFAULT false)
RETURNS TABLE (
    rows_affected INTEGER
)
LANGUAGE plpgsql
AS $
DECLARE
    v_rows_affected INTEGER;
BEGIN
    IF p_hard_delete = true THEN
        DELETE FROM policy_templates WHERE template_id = p_template_id;
    ELSE
        UPDATE policy_templates 
        SET is_active = false, modified_date = CURRENT_TIMESTAMP
        WHERE template_id = p_template_id;
    END IF;
    
    GET DIAGNOSTICS v_rows_affected = ROW_COUNT;
    
    RETURN QUERY SELECT v_rows_affected;
END;
$;

-- ============================================
-- USAGE EXAMPLES
-- ============================================

/*
-- Example usage:

-- Get active policies for a specific agent
SELECT * FROM get_policies_by_status('Active', '550e8400-e29b-41d4-a716-446655440000');

-- Renew a policy
SELECT * FROM renew_policy(
    '550e8400-e29b-41d4-a716-446655440001',
    '2025-01-01',
    '2026-01-01',
    'Renewed Auto Policy',
    'Policy renewed for another year'
);

-- Bulk update policy status
SELECT * FROM bulk_update_policy_status(
    '550e8400-e29b-41d4-a716-446655440001,550e8400-e29b-41d4-a716-446655440002',
    'Expired'
);

-- Get policy templates
SELECT * FROM get_policy_templates();

-- Create a new policy template
SELECT * FROM create_policy_template(
    '550e8400-e29b-41d4-a716-446655440000',
    'Standard Auto Coverage',
    12,
    1200.00,
    'Comprehensive auto insurance coverage',
    'Standard terms and conditions apply'
);
*/

-- ============================================
-- REFERENCE DATA PROCEDURES
-- ============================================

-- Get Insurance Companies
DROP FUNCTION IF EXISTS get_insurance_companies(BOOLEAN);

CREATE OR REPLACE FUNCTION get_insurance_companies(is_active_param BOOLEAN DEFAULT TRUE)
RETURNS TABLE(
    company_id UUID,
    company_name VARCHAR(100),
    is_active BOOLEAN,
    created_date TIMESTAMP
) AS $
BEGIN
    RETURN QUERY
    SELECT 
        ic.company_id,
        ic.company_name,
        ic.is_active,
        ic.created_date
    FROM insurance_companies ic
    WHERE (is_active_param IS NULL OR ic.is_active = is_active_param)
    ORDER BY ic.company_name;
END;
$ LANGUAGE plpgsql;

-- Get Policy Types
DROP FUNCTION IF EXISTS get_policy_types(BOOLEAN);

CREATE OR REPLACE FUNCTION get_policy_types(is_active_param BOOLEAN DEFAULT TRUE)
RETURNS TABLE(
    type_id UUID,
    type_name VARCHAR(50),
    is_active BOOLEAN,
    created_date TIMESTAMP
) AS $
BEGIN
    RETURN QUERY
    SELECT 
        pt.type_id,
        pt.type_name,
        pt.is_active,
        pt.created_date
    FROM policy_types pt
    WHERE (is_active_param IS NULL OR pt.is_active = is_active_param)
    ORDER BY pt.type_name;
END;
$ LANGUAGE plpgsql;

-- Get Policy Categories
DROP FUNCTION IF EXISTS get_policy_categories(BOOLEAN);

CREATE OR REPLACE FUNCTION get_policy_categories(is_active_param BOOLEAN DEFAULT TRUE)
RETURNS TABLE(
    category_id UUID,
    category_name VARCHAR(50),
    description VARCHAR(200),
    is_active BOOLEAN,
    created_date TIMESTAMP
) AS $
BEGIN
    RETURN QUERY
    SELECT 
        pc.category_id,
        pc.category_name,
        pc.description,
        pc.is_active,
        pc.created_date
    FROM policy_categories pc
    WHERE (is_active_param IS NULL OR pc.is_active = is_active_param)
    ORDER BY pc.category_name;
END;
$ LANGUAGE plpgsql;

-- Create Policy Category
DROP FUNCTION IF EXISTS create_policy_category(VARCHAR, VARCHAR);

CREATE OR REPLACE FUNCTION create_policy_category(category_name_param VARCHAR(50),
    description_param VARCHAR(200) DEFAULT NULL)
RETURNS UUID AS $$
DECLARE
    new_category_id UUID;
BEGIN
    new_category_id := gen_random_uuid();
    
    INSERT INTO policy_categories (
        category_id, category_name, description, is_active, created_date
    )
    VALUES (
        new_category_id, category_name_param, description_param, TRUE, NOW()
    );
    
    RETURN new_category_id;
END;
$ LANGUAGE plpgsql;

-- Create Insurance Company
DROP FUNCTION IF EXISTS create_insurance_company(VARCHAR);

CREATE OR REPLACE FUNCTION create_insurance_company(company_name_param VARCHAR(100))
RETURNS UUID AS $$
DECLARE
    new_company_id UUID;
BEGIN
    new_company_id := gen_random_uuid();
    
    INSERT INTO insurance_companies (
        company_id, company_name, is_active, created_date
    )
    VALUES (
        new_company_id, company_name_param, TRUE, NOW()
    );
    
    RETURN new_company_id;
END;
$ LANGUAGE plpgsql;

-- Create Policy Type
DROP FUNCTION IF EXISTS create_policy_type(VARCHAR);

CREATE OR REPLACE FUNCTION create_policy_type(type_name_param VARCHAR(50))
RETURNS UUID AS $$
DECLARE
    new_type_id UUID;
BEGIN
    new_type_id := gen_random_uuid();
    
    INSERT INTO policy_types (
        type_id, type_name, is_active, created_date
    )
    VALUES (
        new_type_id, type_name_param, TRUE, NOW()
    );
    
    RETURN new_type_id;
END;
$ LANGUAGE plpgsql;

-- Get Policy Renewal Candidates
DROP FUNCTION IF EXISTS get_policy_renewal_candidates(UUID, INTEGER);

CREATE OR REPLACE FUNCTION get_policy_renewal_candidates(agent_id_param UUID DEFAULT NULL,
    days_ahead_param INTEGER DEFAULT 60)
RETURNS TABLE(
    policy_id UUID,
    client_id UUID,
    policy_name VARCHAR(100),
    status VARCHAR(20),
    start_date DATE,
    end_date DATE,
    company_id UUID,
    company_name VARCHAR(100),
    type_id UUID,
    type_name VARCHAR(50),
    days_until_expiry INTEGER,
    renewal_priority VARCHAR(10)
) AS $
BEGIN
    RETURN QUERY
    SELECT 
        cp.policy_id,
        cp.client_id,
        cp.policy_name,
        cp.status,
        cp.start_date,
        cp.end_date,
        cp.company_id,
        ic.company_name,
        cp.type_id,
        pt.type_name,
        (cp.end_date - CURRENT_DATE)::INTEGER as days_until_expiry,
        CASE 
            WHEN (cp.end_date - CURRENT_DATE) <= 30 THEN 'Urgent'::VARCHAR
            WHEN (cp.end_date - CURRENT_DATE) <= 45 THEN 'Soon'::VARCHAR
            ELSE 'Upcoming'::VARCHAR
        END as renewal_priority
    FROM client_policies cp
        LEFT JOIN policy_catalog pc ON cp.policy_catalog_id = pc.policy_catalog_id
        LEFT JOIN policy_types pt ON cp.type_id = pt.type_id
        LEFT JOIN insurance_companies ic ON cp.company_id = ic.company_id
    WHERE cp.is_active = TRUE
        AND cp.status = 'Active'
        AND cp.end_date BETWEEN CURRENT_DATE AND (CURRENT_DATE + INTERVAL '1 day' * days_ahead_param)
        AND (agent_id_param IS NULL OR pc.agent_id = agent_id_param)
    ORDER BY cp.end_date, renewal_priority;
END;
$ LANGUAGE plpgsql;

-- Get Agent Dashboard Summary
DROP FUNCTION IF EXISTS get_agent_dashboard_summary(UUID);

CREATE OR REPLACE FUNCTION get_agent_dashboard_summary(agent_id_param UUID)
RETURNS TABLE(
    total_policies INTEGER,
    active_policies INTEGER,
    expiring_in_30_days INTEGER,
    expiring_in_60_days INTEGER,
    total_companies INTEGER,
    total_clients INTEGER,
    inactive_policies INTEGER
) AS $
DECLARE
    total_pol INTEGER := 0;
    active_pol INTEGER := 0;
    expiring_30 INTEGER := 0;
    expiring_60 INTEGER := 0;
    total_comp INTEGER := 0;
    total_cli INTEGER := 0;
BEGIN
    -- Get policy counts
    SELECT 
        COUNT(*)::INTEGER,
        SUM(CASE WHEN cp.status = 'Active' AND cp.is_active = TRUE THEN 1 ELSE 0 END)::INTEGER,
        SUM(
            CASE 
                WHEN cp.status = 'Active' 
                     AND cp.is_active = TRUE
                     AND cp.end_date BETWEEN CURRENT_DATE AND (CURRENT_DATE + INTERVAL '30 days') 
                THEN 1 ELSE 0 END)::INTEGER,
        SUM(
            CASE 
                WHEN cp.status = 'Active' 
                     AND cp.is_active = TRUE
                     AND cp.end_date BETWEEN (CURRENT_DATE + INTERVAL '31 days') AND (CURRENT_DATE + INTERVAL '60 days') 
                THEN 1 ELSE 0 END)::INTEGER
    INTO total_pol, active_pol, expiring_30, expiring_60
    FROM client_policies cp
        INNER JOIN policy_catalog pc ON cp.policy_catalog_id = pc.policy_catalog_id
    WHERE pc.agent_id = agent_id_param;

    -- Get company count (companies actually used in policies for this agent)
    SELECT COUNT(DISTINCT cp.company_id)::INTEGER
    INTO total_comp
    FROM client_policies cp
        INNER JOIN policy_catalog pc ON cp.policy_catalog_id = pc.policy_catalog_id
    WHERE pc.agent_id = agent_id_param
      AND cp.is_active = TRUE
      AND cp.company_id IS NOT NULL;

    -- Get client count (all clients of the agent, regardless of policy)
    SELECT COUNT(*)::INTEGER
    INTO total_cli
    FROM clients c
    WHERE c.agent_id = agent_id_param
      AND c.is_active = TRUE;

    -- Return result
    RETURN QUERY
    SELECT 
        total_pol as total_policies,
        active_pol as active_policies,
        expiring_30 as expiring_in_30_days,
        expiring_60 as expiring_in_60_days,
        total_comp as total_companies,
        total_cli as total_clients,
        (total_pol - active_pol)::INTEGER as inactive_policies;
END;
$ LANGUAGE plpgsql;

-- Update Policy Category
DROP FUNCTION IF EXISTS update_policy_category(UUID, VARCHAR, VARCHAR, BOOLEAN);

CREATE OR REPLACE FUNCTION update_policy_category(category_id_param UUID,
    category_name_param VARCHAR(50) DEFAULT NULL,
    description_param VARCHAR(200) DEFAULT NULL,
    is_active_param BOOLEAN DEFAULT NULL)
RETURNS INTEGER AS $$
DECLARE
    rows_affected INTEGER;
BEGIN
    UPDATE policy_categories
    SET 
        category_name = COALESCE(category_name_param, category_name),
        description = COALESCE(description_param, description),
        is_active = COALESCE(is_active_param, is_active)
    WHERE category_id = category_id_param;
    
    GET DIAGNOSTICS rows_affected = ROW_COUNT;
    RETURN rows_affected;
END;
$ LANGUAGE plpgsql;

-- Update Insurance Company
DROP FUNCTION IF EXISTS update_insurance_company(UUID, VARCHAR, BOOLEAN);

CREATE OR REPLACE FUNCTION update_insurance_company(company_id_param UUID,
    company_name_param VARCHAR(100) DEFAULT NULL,
    is_active_param BOOLEAN DEFAULT NULL)
RETURNS INTEGER AS $$
DECLARE
    rows_affected INTEGER;
BEGIN
    UPDATE insurance_companies
    SET 
        company_name = COALESCE(company_name_param, company_name),
        is_active = COALESCE(is_active_param, is_active)
    WHERE company_id = company_id_param;
    
    GET DIAGNOSTICS rows_affected = ROW_COUNT;
    RETURN rows_affected;
END;
$ LANGUAGE plpgsql;

-- Update Policy Type
DROP FUNCTION IF EXISTS update_policy_type(UUID, VARCHAR, BOOLEAN);

CREATE OR REPLACE FUNCTION update_policy_type(type_id_param UUID,
    type_name_param VARCHAR(50) DEFAULT NULL,
    is_active_param BOOLEAN DEFAULT NULL)
RETURNS INTEGER AS $$
DECLARE
    rows_affected INTEGER;
BEGIN
    UPDATE policy_types
    SET 
        type_name = COALESCE(type_name_param, type_name),
        is_active = COALESCE(is_active_param, is_active)
    WHERE type_id = type_id_param;
    
    GET DIAGNOSTICS rows_affected = ROW_COUNT;
    RETURN rows_affected;
END;
$ LANGUAGE plpgsql;

-- Get Policy History for Client
DROP FUNCTION IF EXISTS get_policy_history_for_client(UUID, BOOLEAN);

CREATE OR REPLACE FUNCTION get_policy_history_for_client(client_id_param UUID,
    include_inactive_param BOOLEAN DEFAULT FALSE)
RETURNS TABLE(
    policy_id UUID,
    client_id UUID,
    policy_name VARCHAR(100),
    status VARCHAR(20),
    start_date DATE,
    end_date DATE,
    notes TEXT,
    created_date TIMESTAMP,
    modified_date TIMESTAMP,
    company_id UUID,
    company_name VARCHAR(100),
    type_id UUID,
    type_name VARCHAR(50),
    policy_duration_days INTEGER,
    policy_state VARCHAR(20)
) AS $
BEGIN
    RETURN QUERY
    SELECT 
        cp.policy_id,
        cp.client_id,
        cp.policy_name,
        cp.status,
        cp.start_date,
        cp.end_date,
        cp.notes,
        cp.created_date,
        cp.modified_date,
        cp.company_id,
        ic.company_name,
        cp.type_id,
        pt.type_name,
        (cp.end_date - cp.start_date)::INTEGER as policy_duration_days,
        CASE 
            WHEN cp.status = 'Active' AND cp.end_date > CURRENT_DATE THEN 'Current'::VARCHAR
            WHEN cp.status = 'Active' AND cp.end_date <= CURRENT_DATE THEN 'Expired'::VARCHAR
            ELSE cp.status
        END as policy_state
    FROM client_policies cp
        LEFT JOIN policy_types pt ON cp.type_id = pt.type_id
        LEFT JOIN insurance_companies ic ON cp.company_id = ic.company_id
    WHERE cp.client_id = client_id_param
        AND (include_inactive_param = TRUE OR cp.is_active = TRUE)
    ORDER BY cp.start_date DESC, cp.created_date DESC;
END;
$ LANGUAGE plpgsql;
-- Batch Expire Policies
-- Get Insurance Companies
DROP FUNCTION IF EXISTS get_insurance_companies(BOOLEAN);

CREATE OR REPLACE FUNCTION get_insurance_companies(is_active_param BOOLEAN DEFAULT TRUE)
RETURNS TABLE(
    company_id UUID,
    company_name VARCHAR(100),
    is_active BOOLEAN,
    created_date TIMESTAMP
) AS $
BEGIN
    RETURN QUERY
    SELECT 
        ic.company_id,
        ic.company_name,
        ic.is_active,
        ic.created_date
    FROM insurance_companies ic
    WHERE (is_active_param IS NULL OR ic.is_active = is_active_param)
    ORDER BY ic.company_name;
END;
$ LANGUAGE plpgsql;

-- Batch Expire Policies
DROP FUNCTION IF EXISTS batch_expire_policies(DATE);

CREATE OR REPLACE FUNCTION batch_expire_policies(as_of_date_param DATE DEFAULT NULL)
RETURNS INTEGER AS  $$
$
 $
DECLARE
    policies_expired INTEGER
$$ LANGUAGE plpgsql;
    cutoff_date DATE;
BEGIN
    cutoff_date := COALESCE(as_of_date_param, CURRENT_DATE);
    
    UPDATE client_policies
    SET status = 'Expired', modified_date = NOW()
    WHERE status = 'Active' 
        AND end_date < cutoff_date
        AND is_active = TRUE;
    
    GET DIAGNOSTICS policies_expired = ROW_COUNT;
    RETURN policies_expired;
END;
$ LANGUAGE plpgsql;

-- ============================================
-- UTILITY FUNCTIONS
-- ============================================

-- Cleanup Soft Deleted Records
DROP FUNCTION IF EXISTS cleanup_soft_deleted_records(INTEGER, BOOLEAN);

CREATE OR REPLACE FUNCTION cleanup_soft_deleted_records(days_old_param INTEGER DEFAULT 365,
    dry_run_param BOOLEAN DEFAULT TRUE)
RETURNS TABLE(
    table_name VARCHAR(50),
    records_count INTEGER
) AS  $$
$
 $
DECLARE
    cutoff_date TIMESTAMP
$$ LANGUAGE plpgsql;
    deleted_count INTEGER := 0;
    client_policies_count INTEGER := 0;
    policy_catalog_count INTEGER := 0;
    policy_templates_count INTEGER := 0;
BEGIN
    cutoff_date := NOW() - INTERVAL '1 day' * days_old_param;
    
    IF dry_run_param = TRUE THEN
        -- Show what would be deleted
        SELECT COUNT(*)::INTEGER INTO client_policies_count
        FROM client_policies 
        WHERE is_active = FALSE AND modified_date < cutoff_date;
        
        SELECT COUNT(*)::INTEGER INTO policy_catalog_count
        FROM policy_catalog 
        WHERE is_active = FALSE AND modified_date < cutoff_date;
        
        SELECT COUNT(*)::INTEGER INTO policy_templates_count
        FROM policy_templates 
        WHERE is_active = FALSE AND created_date < cutoff_date;
        
        RETURN QUERY VALUES 
            ('client_policies'::VARCHAR(50), client_policies_count),
            ('policy_catalog'::VARCHAR(50), policy_catalog_count),
            ('policy_templates'::VARCHAR(50), policy_templates_count);
    ELSE
        -- Actually delete the records
        DELETE FROM client_policies 
        WHERE is_active = FALSE AND modified_date < cutoff_date;
        GET DIAGNOSTICS client_policies_count = ROW_COUNT;
        
        DELETE FROM policy_catalog 
        WHERE is_active = FALSE AND modified_date < cutoff_date;
        GET DIAGNOSTICS policy_catalog_count = ROW_COUNT;
        
        DELETE FROM policy_templates 
        WHERE is_active = FALSE AND created_date < cutoff_date;
        GET DIAGNOSTICS policy_templates_count = ROW_COUNT;
        
        deleted_count := client_policies_count + policy_catalog_count + policy_templates_count;
        
        RETURN QUERY VALUES 
            ('total_deleted'::VARCHAR(50), deleted_count);
    END IF;
END;
$ LANGUAGE plpgsql;

-- ============================================
-- BASIC CRUD OPERATIONS - Simplified Versions
-- ============================================

-- Create Insurance Company (Simple Version)
DROP FUNCTION IF EXISTS sp_create_insurance_company(VARCHAR, BOOLEAN);

CREATE OR REPLACE FUNCTION sp_create_insurance_company(company_name_param VARCHAR(100),
    is_active_param BOOLEAN DEFAULT TRUE)
RETURNS UUID AS  $$
$
DECLARE
    new_company_id UUID
$$ LANGUAGE plpgsql;
BEGIN
    new_company_id := gen_random_uuid();
    
    INSERT INTO insurance_companies (company_id, company_name, is_active, created_date)
    VALUES (new_company_id, company_name_param, is_active_param, NOW());
    
    RETURN new_company_id;
END;
$ LANGUAGE plpgsql;

-- Get All Insurance Companies (Simple Version)
DROP FUNCTION IF EXISTS sp_get_insurance_companies();

CREATE OR REPLACE FUNCTION sp_get_insurance_companies()
RETURNS TABLE(
    company_id UUID,
    company_name VARCHAR(100),
    is_active BOOLEAN,
    created_date TIMESTAMP
) AS  $$
$
 $
BEGIN
    RETURN QUERY
    SELECT 
        ic.company_id,
        ic.company_name,
        ic.is_active,
        ic.created_date
    FROM insurance_companies ic
    ORDER BY ic.company_name
$$ LANGUAGE plpgsql;
END;
$ LANGUAGE plpgsql;

-- Get Insurance Company by ID
DROP FUNCTION IF EXISTS sp_get_insurance_company_by_id(UUID);

CREATE OR REPLACE FUNCTION sp_get_insurance_company_by_id(company_id_param UUID)
RETURNS TABLE(
    company_id UUID,
    company_name VARCHAR(100),
    is_active BOOLEAN,
    created_date TIMESTAMP
) AS  $$
$
 $
BEGIN
    RETURN QUERY
    SELECT 
        ic.company_id,
        ic.company_name,
        ic.is_active,
        ic.created_date
    FROM insurance_companies ic
    WHERE ic.company_id = company_id_param
$$ LANGUAGE plpgsql;
END;
$ LANGUAGE plpgsql;

-- Update Insurance Company (Simple Version)
DROP FUNCTION IF EXISTS sp_update_insurance_company(UUID, VARCHAR, BOOLEAN);

CREATE OR REPLACE FUNCTION sp_update_insurance_company(company_id_param UUID,
    company_name_param VARCHAR(100),
    is_active_param BOOLEAN)
RETURNS INTEGER AS  $$
$
DECLARE
    rows_affected INTEGER
$$ LANGUAGE plpgsql;
BEGIN
    UPDATE insurance_companies
    SET company_name = company_name_param,
        is_active = is_active_param
    WHERE company_id = company_id_param;
    
    GET DIAGNOSTICS rows_affected = ROW_COUNT;
    RETURN rows_affected;
END;
$ LANGUAGE plpgsql;

-- Get Policy Types
DROP FUNCTION IF EXISTS get_policy_types(BOOLEAN);

CREATE OR REPLACE FUNCTION get_policy_types(is_active_param BOOLEAN DEFAULT TRUE)
RETURNS TABLE(
    type_id UUID,
    type_name VARCHAR(50),
    is_active BOOLEAN,
    created_date TIMESTAMP
) AS $
BEGIN
    RETURN QUERY
    SELECT 
        pt.type_id,
        pt.type_name,
        pt.is_active,
        pt.created_date
    FROM policy_types pt
    WHERE (is_active_param IS NULL OR pt.is_active = is_active_param)
    ORDER BY pt.type_name;
END;
$ LANGUAGE plpgsql;

-- Get Policy Categories
DROP FUNCTION IF EXISTS get_policy_categories(BOOLEAN);

CREATE OR REPLACE FUNCTION get_policy_categories(is_active_param BOOLEAN DEFAULT TRUE)
RETURNS TABLE(
    category_id UUID,
    category_name VARCHAR(50),
    description VARCHAR(200),
    is_active BOOLEAN,
    created_date TIMESTAMP
) AS $
BEGIN
    RETURN QUERY
    SELECT 
        pc.category_id,
        pc.category_name,
        pc.description,
        pc.is_active,
        pc.created_date
    FROM policy_categories pc
    WHERE (is_active_param IS NULL OR pc.is_active = is_active_param)
    ORDER BY pc.category_name;
END;
$ LANGUAGE plpgsql;

-- Create Policy Category
DROP FUNCTION IF EXISTS create_policy_category(VARCHAR, VARCHAR);

CREATE OR REPLACE FUNCTION create_policy_category(category_name_param VARCHAR(50),
    description_param VARCHAR(200) DEFAULT NULL)
RETURNS UUID AS $$
DECLARE
    new_category_id UUID;
BEGIN
    new_category_id := gen_random_uuid();
    
    INSERT INTO policy_categories (
        category_id, category_name, description, is_active, created_date
    )
    VALUES (
        new_category_id, category_name_param, description_param, TRUE, NOW()
    );
    
    RETURN new_category_id;
END;
$ LANGUAGE plpgsql;

-- Create Insurance Company
DROP FUNCTION IF EXISTS create_insurance_company(VARCHAR);

CREATE OR REPLACE FUNCTION create_insurance_company(company_name_param VARCHAR(100))
RETURNS UUID AS $$
DECLARE
    new_company_id UUID;
BEGIN
    new_company_id := gen_random_uuid();
    
    INSERT INTO insurance_companies (
        company_id, company_name, is_active, created_date
    )
    VALUES (
        new_company_id, company_name_param, TRUE, NOW()
    );
    
    RETURN new_company_id;
END;
$ LANGUAGE plpgsql;

-- Create Policy Type
DROP FUNCTION IF EXISTS create_policy_type(VARCHAR);

CREATE OR REPLACE FUNCTION create_policy_type(type_name_param VARCHAR(50))
RETURNS UUID AS $$
DECLARE
    new_type_id UUID;
BEGIN
    new_type_id := gen_random_uuid();
    
    INSERT INTO policy_types (
        type_id, type_name, is_active, created_date
    )
    VALUES (
        new_type_id, type_name_param, TRUE, NOW()
    );
    
    RETURN new_type_id;
END;
$ LANGUAGE plpgsql;

-- Get Policy Renewal Candidates
DROP FUNCTION IF EXISTS get_policy_renewal_candidates(UUID, INTEGER);

CREATE OR REPLACE FUNCTION get_policy_renewal_candidates(agent_id_param UUID DEFAULT NULL,
    days_ahead_param INTEGER DEFAULT 60)
RETURNS TABLE(
    policy_id UUID,
    client_id UUID,
    policy_name VARCHAR(100),
    status VARCHAR(20),
    start_date DATE,
    end_date DATE,
    company_id UUID,
    company_name VARCHAR(100),
    type_id UUID,
    type_name VARCHAR(50),
    days_until_expiry INTEGER,
    renewal_priority VARCHAR(10)
) AS $
BEGIN
    RETURN QUERY
    SELECT 
        cp.policy_id,
        cp.client_id,
        cp.policy_name,
        cp.status,
        cp.start_date,
        cp.end_date,
        cp.company_id,
        ic.company_name,
        cp.type_id,
        pt.type_name,
        (cp.end_date - CURRENT_DATE)::INTEGER as days_until_expiry,
        CASE 
            WHEN (cp.end_date - CURRENT_DATE) <= 30 THEN 'Urgent'::VARCHAR
            WHEN (cp.end_date - CURRENT_DATE) <= 45 THEN 'Soon'::VARCHAR
            ELSE 'Upcoming'::VARCHAR
        END as renewal_priority
    FROM client_policies cp
        LEFT JOIN policy_catalog pc ON cp.policy_catalog_id = pc.policy_catalog_id
        LEFT JOIN policy_types pt ON cp.type_id = pt.type_id
        LEFT JOIN insurance_companies ic ON cp.company_id = ic.company_id
    WHERE cp.is_active = TRUE
        AND cp.status = 'Active'
        AND cp.end_date BETWEEN CURRENT_DATE AND (CURRENT_DATE + INTERVAL '1 day' * days_ahead_param)
        AND (agent_id_param IS NULL OR pc.agent_id = agent_id_param)
    ORDER BY cp.end_date, renewal_priority;
END;
$ LANGUAGE plpgsql;

-- Get Agent Dashboard Summary
DROP FUNCTION IF EXISTS get_agent_dashboard_summary(UUID);

CREATE OR REPLACE FUNCTION get_agent_dashboard_summary(agent_id_param UUID)
RETURNS TABLE(
    total_policies INTEGER,
    active_policies INTEGER,
    expiring_in_30_days INTEGER,
    expiring_in_60_days INTEGER,
    total_companies INTEGER,
    total_clients INTEGER,
    inactive_policies INTEGER
) AS $
DECLARE
    total_pol INTEGER := 0;
    active_pol INTEGER := 0;
    expiring_30 INTEGER := 0;
    expiring_60 INTEGER := 0;
    total_comp INTEGER := 0;
    total_cli INTEGER := 0;
BEGIN
    -- Get policy counts
    SELECT 
        COUNT(*)::INTEGER,
        SUM(CASE WHEN cp.status = 'Active' AND cp.is_active = TRUE THEN 1 ELSE 0 END)::INTEGER,
        SUM(
            CASE 
                WHEN cp.status = 'Active' 
                     AND cp.is_active = TRUE
                     AND cp.end_date BETWEEN CURRENT_DATE AND (CURRENT_DATE + INTERVAL '30 days') 
                THEN 1 ELSE 0 END)::INTEGER,
        SUM(
            CASE 
                WHEN cp.status = 'Active' 
                     AND cp.is_active = TRUE
                     AND cp.end_date BETWEEN (CURRENT_DATE + INTERVAL '31 days') AND (CURRENT_DATE + INTERVAL '60 days') 
                THEN 1 ELSE 0 END)::INTEGER
    INTO total_pol, active_pol, expiring_30, expiring_60
    FROM client_policies cp
        INNER JOIN policy_catalog pc ON cp.policy_catalog_id = pc.policy_catalog_id
    WHERE pc.agent_id = agent_id_param;

    -- Get company count (companies actually used in policies for this agent)
    SELECT COUNT(DISTINCT cp.company_id)::INTEGER
    INTO total_comp
    FROM client_policies cp
        INNER JOIN policy_catalog pc ON cp.policy_catalog_id = pc.policy_catalog_id
    WHERE pc.agent_id = agent_id_param
      AND cp.is_active = TRUE
      AND cp.company_id IS NOT NULL;

    -- Get client count (all clients of the agent, regardless of policy)
    SELECT COUNT(*)::INTEGER
    INTO total_cli
    FROM clients c
    WHERE c.agent_id = agent_id_param
      AND c.is_active = TRUE;

    -- Return result
    RETURN QUERY
    SELECT 
        total_pol as total_policies,
        active_pol as active_policies,
        expiring_30 as expiring_in_30_days,
        expiring_60 as expiring_in_60_days,
        total_comp as total_companies,
        total_cli as total_clients,
        (total_pol - active_pol)::INTEGER as inactive_policies;
END;
$ LANGUAGE plpgsql;

-- Update Policy Category
DROP FUNCTION IF EXISTS update_policy_category(UUID, VARCHAR, VARCHAR, BOOLEAN);

CREATE OR REPLACE FUNCTION update_policy_category(category_id_param UUID,
    category_name_param VARCHAR(50) DEFAULT NULL,
    description_param VARCHAR(200) DEFAULT NULL,
    is_active_param BOOLEAN DEFAULT NULL)
RETURNS INTEGER AS $$
DECLARE
    rows_affected INTEGER;
BEGIN
    UPDATE policy_categories
    SET 
        category_name = COALESCE(category_name_param, category_name),
        description = COALESCE(description_param, description),
        is_active = COALESCE(is_active_param, is_active)
    WHERE category_id = category_id_param;
    
    GET DIAGNOSTICS rows_affected = ROW_COUNT;
    RETURN rows_affected;
END;
$ LANGUAGE plpgsql;

-- Update Insurance Company
DROP FUNCTION IF EXISTS update_insurance_company(UUID, VARCHAR, BOOLEAN);

CREATE OR REPLACE FUNCTION update_insurance_company(company_id_param UUID,
    company_name_param VARCHAR(100) DEFAULT NULL,
    is_active_param BOOLEAN DEFAULT NULL)
RETURNS INTEGER AS $$
DECLARE
    rows_affected INTEGER;
BEGIN
    UPDATE insurance_companies
    SET 
        company_name = COALESCE(company_name_param, company_name),
        is_active = COALESCE(is_active_param, is_active)
    WHERE company_id = company_id_param;
    
    GET DIAGNOSTICS rows_affected = ROW_COUNT;
    RETURN rows_affected;
END;
$ LANGUAGE plpgsql;

-- Update Policy Type
DROP FUNCTION IF EXISTS update_policy_type(UUID, VARCHAR, BOOLEAN);

CREATE OR REPLACE FUNCTION update_policy_type(type_id_param UUID,
    type_name_param VARCHAR(50) DEFAULT NULL,
    is_active_param BOOLEAN DEFAULT NULL)
RETURNS INTEGER AS $$
DECLARE
    rows_affected INTEGER;
BEGIN
    UPDATE policy_types
    SET 
        type_name = COALESCE(type_name_param, type_name),
        is_active = COALESCE(is_active_param, is_active)
    WHERE type_id = type_id_param;
    
    GET DIAGNOSTICS rows_affected = ROW_COUNT;
    RETURN rows_affected;
END;
$ LANGUAGE plpgsql;

-- Get Policy History for Client
DROP FUNCTION IF EXISTS get_policy_history_for_client(UUID, BOOLEAN);

CREATE OR REPLACE FUNCTION get_policy_history_for_client(client_id_param UUID,
    include_inactive_param BOOLEAN DEFAULT FALSE)
RETURNS TABLE(
    policy_id UUID,
    client_id UUID,
    policy_name VARCHAR(100),
    status VARCHAR(20),
    start_date DATE,
    end_date DATE,
    notes TEXT,
    created_date TIMESTAMP,
    modified_date TIMESTAMP,
    company_id UUID,
    company_name VARCHAR(100),
    type_id UUID,
    type_name VARCHAR(50),
    policy_duration_days INTEGER,
    policy_state VARCHAR(20)
) AS $
BEGIN
    RETURN QUERY
    SELECT 
        cp.policy_id,
        cp.client_id,
        cp.policy_name,
        cp.status,
        cp.start_date,
        cp.end_date,
        cp.notes,
        cp.created_date,
        cp.modified_date,
        cp.company_id,
        ic.company_name,
        cp.type_id,
        pt.type_name,
        (cp.end_date - cp.start_date)::INTEGER as policy_duration_days,
        CASE 
            WHEN cp.status = 'Active' AND cp.end_date > CURRENT_DATE THEN 'Current'::VARCHAR
            WHEN cp.status = 'Active' AND cp.end_date <= CURRENT_DATE THEN 'Expired'::VARCHAR
            ELSE cp.status
        END as policy_state
    FROM client_policies cp
        LEFT JOIN policy_types pt ON cp.type_id = pt.type_id
        LEFT JOIN insurance_companies ic ON cp.company_id = ic.company_id
    WHERE cp.client_id = client_id_param
        AND (include_inactive_param = TRUE OR cp.is_active = TRUE)
    ORDER BY cp.start_date DESC, cp.created_date DESC;
END;
$ LANGUAGE plpgsql;
-- ============================================
-- 5. Delete Insurance Company (Soft Delete)
-- Get Insurance Companies
DROP FUNCTION IF EXISTS get_insurance_companies(BOOLEAN);

CREATE OR REPLACE FUNCTION get_insurance_companies(is_active_param BOOLEAN DEFAULT TRUE)
RETURNS TABLE(
    company_id UUID,
    company_name VARCHAR(100),
    is_active BOOLEAN,
    created_date TIMESTAMP
) AS $
BEGIN
    RETURN QUERY
    SELECT 
        ic.company_id,
        ic.company_name,
        ic.is_active,
        ic.created_date
    FROM insurance_companies ic
    WHERE (is_active_param IS NULL OR ic.is_active = is_active_param)
    ORDER BY ic.company_name;
END;
$ LANGUAGE plpgsql;

-- Batch Expire Policies
DROP FUNCTION IF EXISTS batch_expire_policies(DATE);

CREATE OR REPLACE FUNCTION batch_expire_policies(as_of_date_param DATE DEFAULT NULL)
RETURNS INTEGER AS  $$
$
 $
DECLARE
    policies_expired INTEGER
$$ LANGUAGE plpgsql;
    cutoff_date DATE;
BEGIN
    cutoff_date := COALESCE(as_of_date_param, CURRENT_DATE);
    
    UPDATE client_policies
    SET status = 'Expired', modified_date = NOW()
    WHERE status = 'Active' 
        AND end_date < cutoff_date
        AND is_active = TRUE;
    
    GET DIAGNOSTICS policies_expired = ROW_COUNT;
    RETURN policies_expired;
END;
$ LANGUAGE plpgsql;

-- ============================================
-- UTILITY FUNCTIONS
-- ============================================

-- Cleanup Soft Deleted Records
DROP FUNCTION IF EXISTS cleanup_soft_deleted_records(INTEGER, BOOLEAN);

CREATE OR REPLACE FUNCTION cleanup_soft_deleted_records(days_old_param INTEGER DEFAULT 365,
    dry_run_param BOOLEAN DEFAULT TRUE)
RETURNS TABLE(
    table_name VARCHAR(50),
    records_count INTEGER
) AS  $$
$
 $
DECLARE
    cutoff_date TIMESTAMP
$$ LANGUAGE plpgsql;
    deleted_count INTEGER := 0;
    client_policies_count INTEGER := 0;
    policy_catalog_count INTEGER := 0;
    policy_templates_count INTEGER := 0;
BEGIN
    cutoff_date := NOW() - INTERVAL '1 day' * days_old_param;
    
    IF dry_run_param = TRUE THEN
        -- Show what would be deleted
        SELECT COUNT(*)::INTEGER INTO client_policies_count
        FROM client_policies 
        WHERE is_active = FALSE AND modified_date < cutoff_date;
        
        SELECT COUNT(*)::INTEGER INTO policy_catalog_count
        FROM policy_catalog 
        WHERE is_active = FALSE AND modified_date < cutoff_date;
        
        SELECT COUNT(*)::INTEGER INTO policy_templates_count
        FROM policy_templates 
        WHERE is_active = FALSE AND created_date < cutoff_date;
        
        RETURN QUERY VALUES 
            ('client_policies'::VARCHAR(50), client_policies_count),
            ('policy_catalog'::VARCHAR(50), policy_catalog_count),
            ('policy_templates'::VARCHAR(50), policy_templates_count);
    ELSE
        -- Actually delete the records
        DELETE FROM client_policies 
        WHERE is_active = FALSE AND modified_date < cutoff_date;
        GET DIAGNOSTICS client_policies_count = ROW_COUNT;
        
        DELETE FROM policy_catalog 
        WHERE is_active = FALSE AND modified_date < cutoff_date;
        GET DIAGNOSTICS policy_catalog_count = ROW_COUNT;
        
        DELETE FROM policy_templates 
        WHERE is_active = FALSE AND created_date < cutoff_date;
        GET DIAGNOSTICS policy_templates_count = ROW_COUNT;
        
        deleted_count := client_policies_count + policy_catalog_count + policy_templates_count;
        
        RETURN QUERY VALUES 
            ('total_deleted'::VARCHAR(50), deleted_count);
    END IF;
END;
$ LANGUAGE plpgsql;

-- ============================================
-- BASIC CRUD OPERATIONS - Simplified Versions
-- ============================================

-- Create Insurance Company (Simple Version)
DROP FUNCTION IF EXISTS sp_create_insurance_company(VARCHAR, BOOLEAN);

CREATE OR REPLACE FUNCTION sp_create_insurance_company(company_name_param VARCHAR(100),
    is_active_param BOOLEAN DEFAULT TRUE)
RETURNS UUID AS  $$
$
DECLARE
    new_company_id UUID
$$ LANGUAGE plpgsql;
BEGIN
    new_company_id := gen_random_uuid();
    
    INSERT INTO insurance_companies (company_id, company_name, is_active, created_date)
    VALUES (new_company_id, company_name_param, is_active_param, NOW());
    
    RETURN new_company_id;
END;
$ LANGUAGE plpgsql;

-- Get All Insurance Companies (Simple Version)
DROP FUNCTION IF EXISTS sp_get_insurance_companies();

CREATE OR REPLACE FUNCTION sp_get_insurance_companies()
RETURNS TABLE(
    company_id UUID,
    company_name VARCHAR(100),
    is_active BOOLEAN,
    created_date TIMESTAMP
) AS  $$
$
 $
BEGIN
    RETURN QUERY
    SELECT 
        ic.company_id,
        ic.company_name,
        ic.is_active,
        ic.created_date
    FROM insurance_companies ic
    ORDER BY ic.company_name
$$ LANGUAGE plpgsql;
END;
$ LANGUAGE plpgsql;

-- Get Insurance Company by ID
DROP FUNCTION IF EXISTS sp_get_insurance_company_by_id(UUID);

CREATE OR REPLACE FUNCTION sp_get_insurance_company_by_id(company_id_param UUID)
RETURNS TABLE(
    company_id UUID,
    company_name VARCHAR(100),
    is_active BOOLEAN,
    created_date TIMESTAMP
) AS  $$
$
 $
BEGIN
    RETURN QUERY
    SELECT 
        ic.company_id,
        ic.company_name,
        ic.is_active,
        ic.created_date
    FROM insurance_companies ic
    WHERE ic.company_id = company_id_param
$$ LANGUAGE plpgsql;
END;
$ LANGUAGE plpgsql;

-- Update Insurance Company (Simple Version)
DROP FUNCTION IF EXISTS sp_update_insurance_company(UUID, VARCHAR, BOOLEAN);

CREATE OR REPLACE FUNCTION sp_update_insurance_company(company_id_param UUID,
    company_name_param VARCHAR(100),
    is_active_param BOOLEAN)
RETURNS INTEGER AS  $$
$
DECLARE
    rows_affected INTEGER
$$ LANGUAGE plpgsql;
BEGIN
    UPDATE insurance_companies
    SET company_name = company_name_param,
        is_active = is_active_param
    WHERE company_id = company_id_param;
    
    GET DIAGNOSTICS rows_affected = ROW_COUNT;
    RETURN rows_affected;
END;
$ LANGUAGE plpgsql;

-- Get Policy Types
DROP FUNCTION IF EXISTS get_policy_types(BOOLEAN);

CREATE OR REPLACE FUNCTION get_policy_types(is_active_param BOOLEAN DEFAULT TRUE)
RETURNS TABLE(
    type_id UUID,
    type_name VARCHAR(50),
    is_active BOOLEAN,
    created_date TIMESTAMP
) AS $
BEGIN
    RETURN QUERY
    SELECT 
        pt.type_id,
        pt.type_name,
        pt.is_active,
        pt.created_date
    FROM policy_types pt
    WHERE (is_active_param IS NULL OR pt.is_active = is_active_param)
    ORDER BY pt.type_name;
END;
$ LANGUAGE plpgsql;

-- ============================================
-- DELETE OPERATIONS
-- ============================================

-- Delete Insurance Company (Hard/Soft Delete)
DROP FUNCTION IF EXISTS sp_delete_insurance_company(UUID, BOOLEAN);

CREATE OR REPLACE FUNCTION sp_delete_insurance_company(company_id_param UUID,
    hard_delete_param BOOLEAN DEFAULT FALSE)
RETURNS INTEGER AS  $$
$
 $
DECLARE
    rows_affected INTEGER
$$ LANGUAGE plpgsql;
BEGIN
    IF hard_delete_param = TRUE THEN
        DELETE FROM insurance_companies
        WHERE company_id = company_id_param;
    ELSE
        UPDATE insurance_companies
        SET is_active = FALSE
        WHERE company_id = company_id_param;
    END IF;
    
    GET DIAGNOSTICS rows_affected = ROW_COUNT;
    RETURN rows_affected;
END;
$ LANGUAGE plpgsql;

-- ============================================
-- POLICY CATEGORY CRUD OPERATIONS
-- ============================================

-- Create Policy Category
DROP FUNCTION IF EXISTS sp_create_policy_category(VARCHAR, UUID, BOOLEAN);

CREATE OR REPLACE FUNCTION sp_create_policy_category(category_name_param VARCHAR(100),
    company_id_param UUID,
    is_active_param BOOLEAN DEFAULT TRUE)
RETURNS UUID AS  $$
$
DECLARE
    new_category_id UUID
$$ LANGUAGE plpgsql;
BEGIN
    new_category_id := gen_random_uuid();
    
    INSERT INTO policy_categories (category_id, category_name, company_id, is_active, created_date)
    VALUES (new_category_id, category_name_param, company_id_param, is_active_param, NOW());
    
    RETURN new_category_id;
END;
$ LANGUAGE plpgsql;

-- Get All Policy Categories
DROP FUNCTION IF EXISTS sp_get_policy_categories();

CREATE OR REPLACE FUNCTION sp_get_policy_categories()
RETURNS TABLE(
    category_id UUID,
    category_name VARCHAR(100),
    company_id UUID,
    company_name VARCHAR(100),
    is_active BOOLEAN,
    created_date TIMESTAMP
) AS  $$
$
 $
BEGIN
    RETURN QUERY
    SELECT 
        c.category_id,
        c.category_name,
        c.company_id,
        ic.company_name,
        c.is_active,
        c.created_date
    FROM policy_categories c
    INNER JOIN insurance_companies ic ON c.company_id = ic.company_id
    ORDER BY ic.company_name, c.category_name
$$ LANGUAGE plpgsql;
END;
$ LANGUAGE plpgsql;

-- Get Policy Category by ID
DROP FUNCTION IF EXISTS sp_get_policy_category_by_id(UUID);

CREATE OR REPLACE FUNCTION sp_get_policy_category_by_id(category_id_param UUID)
RETURNS TABLE(
    category_id UUID,
    category_name VARCHAR(100),
    company_id UUID,
    company_name VARCHAR(100),
    is_active BOOLEAN,
    created_date TIMESTAMP
) AS  $$
$
 $
BEGIN
    RETURN QUERY
    SELECT 
        c.category_id,
        c.category_name,
        c.company_id,
        ic.company_name,
        c.is_active,
        c.created_date
    FROM policy_categories c
    INNER JOIN insurance_companies ic ON c.company_id = ic.company_id
    WHERE c.category_id = category_id_param
$$ LANGUAGE plpgsql;
END;
$ LANGUAGE plpgsql;

-- Update Policy Category
DROP FUNCTION IF EXISTS sp_update_policy_category(UUID, VARCHAR, UUID, BOOLEAN);

CREATE OR REPLACE FUNCTION sp_update_policy_category(category_id_param UUID,
    category_name_param VARCHAR(100),
    company_id_param UUID,
    is_active_param BOOLEAN)
RETURNS INTEGER AS  $$
$
DECLARE
    rows_affected INTEGER
$$ LANGUAGE plpgsql;
BEGIN
    UPDATE policy_categories
    SET category_name = category_name_param,
        company_id = company_id_param,
        is_active = is_active_param
    WHERE category_id = category_id_param;
    
    GET DIAGNOSTICS rows_affected = ROW_COUNT;
    RETURN rows_affected;
END;
$ LANGUAGE plpgsql;

-- Delete Policy Category (Hard/Soft Delete)
DROP FUNCTION IF EXISTS sp_delete_policy_category(UUID, BOOLEAN);

CREATE OR REPLACE FUNCTION sp_delete_policy_category(category_id_param UUID,
    hard_delete_param BOOLEAN DEFAULT FALSE)
RETURNS INTEGER AS  $$
$
 $
DECLARE
    rows_affected INTEGER
$$ LANGUAGE plpgsql;
BEGIN
    IF hard_delete_param = TRUE THEN
        DELETE FROM policy_categories
        WHERE category_id = category_id_param;
    ELSE
        UPDATE policy_categories
        SET is_active = FALSE
        WHERE category_id = category_id_param;
    END IF;
    
    GET DIAGNOSTICS rows_affected = ROW_COUNT;
    RETURN rows_affected;
END;
$ LANGUAGE plpgsql;

-- ============================================
-- POLICY TYPE CRUD OPERATIONS
-- ============================================

-- Create Policy Type (Returns the created record)
DROP FUNCTION IF EXISTS sp_create_policy_type(VARCHAR, BOOLEAN);

CREATE OR REPLACE FUNCTION sp_create_policy_type(type_name_param VARCHAR(50),
    is_active_param BOOLEAN DEFAULT TRUE)
RETURNS TABLE(
    type_id UUID,
    type_name VARCHAR(50),
    is_active BOOLEAN,
    created_date TIMESTAMP
) AS  $$
$
DECLARE
    new_id UUID
$$ LANGUAGE plpgsql;
BEGIN
    new_id := gen_random_uuid();

    INSERT INTO policy_types (type_id, type_name, is_active, created_date)
    VALUES (new_id, type_name_param, is_active_param, NOW());

    RETURN QUERY
    SELECT pt.type_id, pt.type_name, pt.is_active, pt.created_date
    FROM policy_types pt
    WHERE pt.type_id = new_id;
END;
$ LANGUAGE plpgsql;

-- Get All Policy Types
DROP FUNCTION IF EXISTS sp_get_policy_types();

CREATE OR REPLACE FUNCTION sp_get_policy_types()
RETURNS TABLE(
    type_id UUID,
    type_name VARCHAR(50),
    is_active BOOLEAN,
    created_date TIMESTAMP
) AS  $$
$
 $
BEGIN
    RETURN QUERY
    SELECT 
        pt.type_id,
        pt.type_name,
        pt.is_active,
        pt.created_date
    FROM policy_types pt
    ORDER BY pt.created_date DESC
$$ LANGUAGE plpgsql;
END;
$ LANGUAGE plpgsql;

-- Get Policy Type By ID
DROP FUNCTION IF EXISTS sp_get_policy_type_by_id(UUID);

CREATE OR REPLACE FUNCTION sp_get_policy_type_by_id(type_id_param UUID)
RETURNS TABLE(
    type_id UUID,
    type_name VARCHAR(50),
    is_active BOOLEAN,
    created_date TIMESTAMP
) AS  $$
$
 $
BEGIN
    RETURN QUERY
    SELECT 
        pt.type_id,
        pt.type_name,
        pt.is_active,
        pt.created_date
    FROM policy_types pt
    WHERE pt.type_id = type_id_param
$$ LANGUAGE plpgsql;
END;
$ LANGUAGE plpgsql;

-- Update Policy Type
DROP FUNCTION IF EXISTS sp_update_policy_type(UUID, VARCHAR, BOOLEAN);

CREATE OR REPLACE FUNCTION sp_update_policy_type(type_id_param UUID,
    type_name_param VARCHAR(50),
    is_active_param BOOLEAN)
RETURNS INTEGER AS  $$
$
DECLARE
    rows_affected INTEGER
$$ LANGUAGE plpgsql;
BEGIN
    UPDATE policy_types
    SET type_name = type_name_param,
        is_active = is_active_param
    WHERE type_id = type_id_param;
    
    GET DIAGNOSTICS rows_affected = ROW_COUNT;
    RETURN rows_affected;
END;
$ LANGUAGE plpgsql;

-- Delete Policy Type (Hard Delete)
DROP FUNCTION IF EXISTS sp_delete_policy_type(UUID);

CREATE OR REPLACE FUNCTION sp_delete_policy_type(type_id_param UUID)
RETURNS INTEGER AS  $$
$
 $
DECLARE
    rows_affected INTEGER
$$ LANGUAGE plpgsql;
BEGIN
    DELETE FROM policy_types
    WHERE type_id = type_id_param;
    
    GET DIAGNOSTICS rows_affected = ROW_COUNT;
    RETURN rows_affected;
END;
$ LANGUAGE plpgsql;

-- ============================================
-- SOFT DELETE OPERATIONS
-- ============================================

-- Soft Delete Policy Template
DROP FUNCTION IF EXISTS sp_soft_delete_policy_template(UUID);

CREATE OR REPLACE FUNCTION sp_soft_delete_policy_template(template_id_param UUID)
RETURNS INTEGER AS  $$
$
 $
DECLARE
    rows_affected INTEGER
$$ LANGUAGE plpgsql;
BEGIN
    UPDATE policy_templates
    SET is_active = FALSE
    WHERE template_id = template_id_param;
    
    GET DIAGNOSTICS rows_affected = ROW_COUNT;
    RETURN rows_affected;
END;
$ LANGUAGE plpgsql;

-- Soft Delete Policy Catalog
DROP FUNCTION IF EXISTS sp_soft_delete_policy_catalog(UUID);

CREATE OR REPLACE FUNCTION sp_soft_delete_policy_catalog(policy_catalog_id_param UUID)
RETURNS INTEGER AS  $$
$
 $
DECLARE
    rows_affected INTEGER
$$ LANGUAGE plpgsql;
BEGIN
    UPDATE policy_catalog
    SET is_active = FALSE,
        modified_date = NOW()
    WHERE policy_catalog_id = policy_catalog_id_param;
    
    GET DIAGNOSTICS rows_affected = ROW_COUNT;
    RETURN rows_affected;
END;
$ LANGUAGE plpgsql;

-- Soft Delete Policy Category
DROP FUNCTION IF EXISTS sp_soft_delete_policy_category(UUID);

CREATE OR REPLACE FUNCTION sp_soft_delete_policy_category(category_id_param UUID)
RETURNS INTEGER AS  $$
$
 $
DECLARE
    rows_affected INTEGER
$$ LANGUAGE plpgsql;
BEGIN
    UPDATE policy_categories
    SET is_active = FALSE
    WHERE category_id = category_id_param;
    
    GET DIAGNOSTICS rows_affected = ROW_COUNT;
    RETURN rows_affected;
END;
$ LANGUAGE plpgsql;

-- Soft Delete Insurance Company
DROP FUNCTION IF EXISTS sp_soft_delete_insurance_company(UUID);

CREATE OR REPLACE FUNCTION sp_soft_delete_insurance_company(company_id_param UUID)
RETURNS INTEGER AS  $$
$
 $
DECLARE
    rows_affected INTEGER
$$ LANGUAGE plpgsql;
BEGIN
    UPDATE insurance_companies
    SET is_active = FALSE
    WHERE company_id = company_id_param;
    
    GET DIAGNOSTICS rows_affected = ROW_COUNT;
    RETURN rows_affected;
END;
$ LANGUAGE plpgsql;

-- Soft Delete Client Policy
DROP FUNCTION IF EXISTS sp_soft_delete_client_policy(UUID);

CREATE OR REPLACE FUNCTION sp_soft_delete_client_policy(policy_id_param UUID)
RETURNS INTEGER AS  $$
$
 $
DECLARE
    rows_affected INTEGER
$$ LANGUAGE plpgsql;
BEGIN
    UPDATE client_policies
    SET is_active = FALSE,
        modified_date = NOW()
    WHERE policy_id = policy_id_param;
    
    GET DIAGNOSTICS rows_affected = ROW_COUNT;
    RETURN rows_affected;
END;
$ LANGUAGE plpgsql;

-- ============================================
-- SAFE SOFT DELETE OPERATIONS (Only if Active)
-- ============================================

-- Client Policies Safe Soft Delete
DROP FUNCTION IF EXISTS client_policies_soft_delete(UUID);

CREATE OR REPLACE FUNCTION client_policies_soft_delete(policy_id_param UUID)
RETURNS INTEGER AS  $$
$
 $
DECLARE
    rows_affected INTEGER
$$ LANGUAGE plpgsql;
BEGIN
    UPDATE client_policies
    SET is_active = FALSE,
        modified_date = NOW()
    WHERE policy_id = policy_id_param AND is_active = TRUE;
    
    GET DIAGNOSTICS rows_affected = ROW_COUNT;
    RETURN rows_affected;
END;
$ LANGUAGE plpgsql;

-- Insurance Companies Safe Soft Delete
DROP FUNCTION IF EXISTS insurance_companies_soft_delete(UUID);

CREATE OR REPLACE FUNCTION insurance_companies_soft_delete(company_id_param UUID)
RETURNS INTEGER AS  $$
$
 $
DECLARE
    rows_affected INTEGER
$$ LANGUAGE plpgsql;
BEGIN
    UPDATE insurance_companies
    SET is_active = FALSE
    WHERE company_id = company_id_param AND is_active = TRUE;
    
    GET DIAGNOSTICS rows_affected = ROW_COUNT;
    RETURN rows_affected;
END;
$ LANGUAGE plpgsql;

-- Policy Catalog Safe Soft Delete
DROP FUNCTION IF EXISTS policy_catalog_soft_delete(UUID);

CREATE OR REPLACE FUNCTION policy_catalog_soft_delete(policy_catalog_id_param UUID)
RETURNS INTEGER AS  $$
$
 $
DECLARE
    rows_affected INTEGER
$$ LANGUAGE plpgsql;
BEGIN
    UPDATE policy_catalog
    SET is_active = FALSE,
        modified_date = NOW()
    WHERE policy_catalog_id = policy_catalog_id_param AND is_active = TRUE;
    
    GET DIAGNOSTICS rows_affected = ROW_COUNT;
    RETURN rows_affected;
END;
$ LANGUAGE plpgsql;

-- Policy Categories Safe Soft Delete
DROP FUNCTION IF EXISTS policy_categories_soft_delete(UUID);

CREATE OR REPLACE FUNCTION policy_categories_soft_delete(category_id_param UUID)
RETURNS INTEGER AS  $$
$
 $
DECLARE
    rows_affected INTEGER
$$ LANGUAGE plpgsql;
BEGIN
    UPDATE policy_categories
    SET is_active = FALSE
    WHERE category_id = category_id_param AND is_active = TRUE;
    
    GET DIAGNOSTICS rows_affected = ROW_COUNT;
    RETURN rows_affected;
END;
$ LANGUAGE plpgsql;

-- Policy Templates Safe Soft Delete
DROP FUNCTION IF EXISTS policy_templates_soft_delete(UUID);

CREATE OR REPLACE FUNCTION policy_templates_soft_delete(template_id_param UUID)
RETURNS INTEGER AS  $$
$
 $
DECLARE
    rows_affected INTEGER
$$ LANGUAGE plpgsql;
BEGIN
    UPDATE policy_templates
    SET is_active = FALSE
    WHERE template_id = template_id_param AND is_active = TRUE;
    
    GET DIAGNOSTICS rows_affected = ROW_COUNT;
    RETURN rows_affected;
END;
$ LANGUAGE plpgsql;

-- Policy Types Safe Soft Delete
DROP FUNCTION IF EXISTS policy_types_soft_delete(UUID);

CREATE OR REPLACE FUNCTION policy_types_soft_delete(type_id_param UUID)
RETURNS INTEGER AS  $$
$
 $
DECLARE
    rows_affected INTEGER
$$ LANGUAGE plpgsql;
BEGIN
    UPDATE policy_types
    SET is_active = FALSE
    WHERE type_id = type_id_param AND is_active = TRUE;
    
    GET DIAGNOSTICS rows_affected = ROW_COUNT;
    RETURN rows_affected;
END;
$ LANGUAGE plpgsql;

-- ============================================
-- COMPLEX QUERY FUNCTIONS
-- ============================================

-- Get Clients With Policies
DROP FUNCTION IF EXISTS get_clients_with_policies(UUID, UUID, BOOLEAN);

CREATE OR REPLACE FUNCTION get_clients_with_policies(agent_id_param UUID DEFAULT NULL,
    client_id_param UUID DEFAULT NULL,
    include_inactive_param BOOLEAN DEFAULT FALSE)
RETURNS TABLE(
    client_id UUID,
    agent_id UUID,
    first_name VARCHAR(50),
    surname VARCHAR(50),
    last_name VARCHAR(50),
    full_name VARCHAR(152),
    phone_number VARCHAR(20),
    email VARCHAR(100),
    address TEXT,
    national_id VARCHAR(50),
    date_of_birth DATE,
    is_client BOOLEAN,
    insurance_type VARCHAR(50),
    client_notes TEXT,
    client_created_date TIMESTAMP,
    client_modified_date TIMESTAMP,
    client_is_active BOOLEAN,
    policy_id UUID,
    policy_name VARCHAR(100),
    status VARCHAR(20),
    start_date DATE,
    end_date DATE,
    policy_notes TEXT,
    policy_created_date TIMESTAMP,
    policy_modified_date TIMESTAMP,
    policy_is_active BOOLEAN,
    policy_catalog_id UUID,
    catalog_policy_name VARCHAR(100),
    type_id UUID,
    type_name VARCHAR(50),
    company_id UUID,
    company_name VARCHAR(100),
    days_until_expiry INTEGER
) AS $
BEGIN
    RETURN QUERY
    SELECT 
        c.client_id,
        c.agent_id,
        c.first_name,
        c.surname,
        c.last_name,
        (COALESCE(c.first_name, '') || ' ' || COALESCE(c.surname, '') || ' ' || COALESCE(c.last_name, ''))::VARCHAR(152) AS full_name,
        c.phone_number,
        c.email,
        c.address,
        c.national_id,
        c.date_of_birth,
        c.is_client,
        c.insurance_type,
        c.notes AS client_notes,
        c.created_date AS client_created_date,
        c.modified_date AS client_modified_date,
        c.is_active AS client_is_active,

        cp.policy_id,
        cp.policy_name,
        cp.status,
        cp.start_date,
        cp.end_date,
        cp.notes AS policy_notes,
        cp.created_date AS policy_created_date,
        cp.modified_date AS policy_modified_date,
        cp.is_active AS policy_is_active,
        cp.policy_catalog_id,
        pc.policy_name AS catalog_policy_name,
        cp.type_id,
        pt.type_name,
        cp.company_id,
        ic.company_name,
        (cp.end_date - CURRENT_DATE)::INTEGER AS  $$
days_until_expiry
    FROM clients c
        INNER JOIN client_policies cp 
            ON c.client_id = cp.client_id
           AND cp.policy_id IS NOT NULL
           AND cp.company_id IS NOT NULL
           AND cp.type_id IS NOT NULL
        LEFT JOIN policy_catalog pc ON cp.policy_catalog_id = pc.policy_catalog_id
        LEFT JOIN policy_types pt ON cp.type_id = pt.type_id
        LEFT JOIN insurance_companies ic ON cp.company_id = ic.company_id
    WHERE 
        (agent_id_param IS NULL OR c.agent_id = agent_id_param)
        AND (client_id_param IS NULL OR c.client_id = client_id_param)
        AND (
            include_inactive_param = TRUE 
            OR (c.is_active = TRUE AND cp.is_active = TRUE)
        )
    ORDER BY c.created_date DESC, cp.end_date DESC
$$ LANGUAGE plpgsql;
END;
$ LANGUAGE plpgsql;

-- Get Agent Dashboard Summary (Enhanced)
DROP FUNCTION IF EXISTS get_agent_dashboard_summary(UUID);

CREATE OR REPLACE FUNCTION get_agent_dashboard_summary(agent_id_param UUID)
RETURNS TABLE(
    total_policies INTEGER,
    active_policies INTEGER,
    expiring_in_30_days INTEGER,
    expiring_in_60_days INTEGER,
    total_companies INTEGER,
    total_clients INTEGER,
    inactive_policies INTEGER
) AS  $$
$
 $
DECLARE
    total_pol INTEGER := 0
$$ LANGUAGE plpgsql;
    active_pol INTEGER := 0;
    expiring_30 INTEGER := 0;
    expiring_60 INTEGER := 0;
    total_comp INTEGER := 0;
    total_cli INTEGER := 0;
BEGIN
    -- Get policy counts using CTE equivalent logic
    WITH agent_policies AS (
        SELECT
            cp.policy_id,
            cp.client_id,
            cp.company_id,
            cp.start_date,
            cp.end_date,
            -- normalize status once
            UPPER(TRIM(cp.status)) AS norm_status,
            -- treat NULL as active
            CASE WHEN COALESCE(cp.is_active, TRUE) = TRUE THEN 1 ELSE 0 END AS is_active_flag
        FROM client_policies cp
        INNER JOIN clients c ON c.client_id = cp.client_id
        WHERE c.agent_id = agent_id_param
          AND COALESCE(cp.is_active, TRUE) = TRUE
    )
    SELECT
        COUNT(*)::INTEGER,
        SUM(CASE
                WHEN norm_status = 'ACTIVE'
                     AND end_date >= CURRENT_DATE
                THEN 1 ELSE 0
            END)::INTEGER,
        SUM(CASE
                WHEN norm_status = 'ACTIVE'
                     AND end_date BETWEEN CURRENT_DATE
                                     AND (CURRENT_DATE + INTERVAL '30 days')
                THEN 1 ELSE 0
            END)::INTEGER,
        SUM(CASE
                WHEN norm_status = 'ACTIVE'
                     AND end_date BETWEEN (CURRENT_DATE + INTERVAL '31 days')
                                     AND (CURRENT_DATE + INTERVAL '60 days')
                THEN 1 ELSE 0
            END)::INTEGER,
        COUNT(DISTINCT CASE WHEN company_id IS NOT NULL THEN company_id END)::INTEGER
    INTO total_pol, active_pol, expiring_30, expiring_60, total_comp
    FROM agent_policies;

    -- Count all active clients for this agent (not only those with policies)
    SELECT COUNT(*)::INTEGER
    INTO total_cli
    FROM clients c
    WHERE c.agent_id = agent_id_param
      AND COALESCE(c.is_active, TRUE) = TRUE;

    RETURN QUERY
    SELECT
        total_pol AS total_policies,
        active_pol AS active_policies,
        expiring_30 AS expiring_in_30_days,
        expiring_60 AS expiring_in_60_days,
        total_comp AS total_companies,
        total_cli AS total_clients,
        (total_pol - active_pol)::INTEGER AS inactive_policies;
END;
$ LANGUAGE plpgsql;

-- Get Policy Categories
DROP FUNCTION IF EXISTS get_policy_categories(BOOLEAN);

CREATE OR REPLACE FUNCTION get_policy_categories(is_active_param BOOLEAN DEFAULT TRUE)
RETURNS TABLE(
    category_id UUID,
    category_name VARCHAR(50),
    description VARCHAR(200),
    is_active BOOLEAN,
    created_date TIMESTAMP
) AS $
BEGIN
    RETURN QUERY
    SELECT 
        pc.category_id,
        pc.category_name,
        pc.description,
        pc.is_active,
        pc.created_date
    FROM policy_categories pc
    WHERE (is_active_param IS NULL OR pc.is_active = is_active_param)
    ORDER BY pc.category_name;
END;
$ LANGUAGE plpgsql;

-- Create Policy Category
DROP FUNCTION IF EXISTS create_policy_category(VARCHAR, VARCHAR);

CREATE OR REPLACE FUNCTION create_policy_category(category_name_param VARCHAR(50),
    description_param VARCHAR(200) DEFAULT NULL)
RETURNS UUID AS $$
DECLARE
    new_category_id UUID;
BEGIN
    new_category_id := gen_random_uuid();
    
    INSERT INTO policy_categories (
        category_id, category_name, description, is_active, created_date
    )
    VALUES (
        new_category_id, category_name_param, description_param, TRUE, NOW()
    );
    
    RETURN new_category_id;
END;
$ LANGUAGE plpgsql;

-- Create Insurance Company
DROP FUNCTION IF EXISTS create_insurance_company(VARCHAR);

CREATE OR REPLACE FUNCTION create_insurance_company(company_name_param VARCHAR(100))
RETURNS UUID AS $$
DECLARE
    new_company_id UUID;
BEGIN
    new_company_id := gen_random_uuid();
    
    INSERT INTO insurance_companies (
        company_id, company_name, is_active, created_date
    )
    VALUES (
        new_company_id, company_name_param, TRUE, NOW()
    );
    
    RETURN new_company_id;
END;
$ LANGUAGE plpgsql;

-- Create Policy Type
DROP FUNCTION IF EXISTS create_policy_type(VARCHAR);

CREATE OR REPLACE FUNCTION create_policy_type(type_name_param VARCHAR(50))
RETURNS UUID AS $$
DECLARE
    new_type_id UUID;
BEGIN
    new_type_id := gen_random_uuid();
    
    INSERT INTO policy_types (
        type_id, type_name, is_active, created_date
    )
    VALUES (
        new_type_id, type_name_param, TRUE, NOW()
    );
    
    RETURN new_type_id;
END;
$ LANGUAGE plpgsql;

-- Get Policy Renewal Candidates
DROP FUNCTION IF EXISTS get_policy_renewal_candidates(UUID, INTEGER);

CREATE OR REPLACE FUNCTION get_policy_renewal_candidates(agent_id_param UUID DEFAULT NULL,
    days_ahead_param INTEGER DEFAULT 60)
RETURNS TABLE(
    policy_id UUID,
    client_id UUID,
    policy_name VARCHAR(100),
    status VARCHAR(20),
    start_date DATE,
    end_date DATE,
    company_id UUID,
    company_name VARCHAR(100),
    type_id UUID,
    type_name VARCHAR(50),
    days_until_expiry INTEGER,
    renewal_priority VARCHAR(10)
) AS $
BEGIN
    RETURN QUERY
    SELECT 
        cp.policy_id,
        cp.client_id,
        cp.policy_name,
        cp.status,
        cp.start_date,
        cp.end_date,
        cp.company_id,
        ic.company_name,
        cp.type_id,
        pt.type_name,
        (cp.end_date - CURRENT_DATE)::INTEGER as days_until_expiry,
        CASE 
            WHEN (cp.end_date - CURRENT_DATE) <= 30 THEN 'Urgent'::VARCHAR
            WHEN (cp.end_date - CURRENT_DATE) <= 45 THEN 'Soon'::VARCHAR
            ELSE 'Upcoming'::VARCHAR
        END as renewal_priority
    FROM client_policies cp
        LEFT JOIN policy_catalog pc ON cp.policy_catalog_id = pc.policy_catalog_id
        LEFT JOIN policy_types pt ON cp.type_id = pt.type_id
        LEFT JOIN insurance_companies ic ON cp.company_id = ic.company_id
    WHERE cp.is_active = TRUE
        AND cp.status = 'Active'
        AND cp.end_date BETWEEN CURRENT_DATE AND (CURRENT_DATE + INTERVAL '1 day' * days_ahead_param)
        AND (agent_id_param IS NULL OR pc.agent_id = agent_id_param)
    ORDER BY cp.end_date, renewal_priority;
END;
$ LANGUAGE plpgsql;

-- Get Agent Dashboard Summary
DROP FUNCTION IF EXISTS get_agent_dashboard_summary(UUID);

CREATE OR REPLACE FUNCTION get_agent_dashboard_summary(agent_id_param UUID)
RETURNS TABLE(
    total_policies INTEGER,
    active_policies INTEGER,
    expiring_in_30_days INTEGER,
    expiring_in_60_days INTEGER,
    total_companies INTEGER,
    total_clients INTEGER,
    inactive_policies INTEGER
) AS $
DECLARE
    total_pol INTEGER := 0;
    active_pol INTEGER := 0;
    expiring_30 INTEGER := 0;
    expiring_60 INTEGER := 0;
    total_comp INTEGER := 0;
    total_cli INTEGER := 0;
BEGIN
    -- Get policy counts
    SELECT 
        COUNT(*)::INTEGER,
        SUM(CASE WHEN cp.status = 'Active' AND cp.is_active = TRUE THEN 1 ELSE 0 END)::INTEGER,
        SUM(
            CASE 
                WHEN cp.status = 'Active' 
                     AND cp.is_active = TRUE
                     AND cp.end_date BETWEEN CURRENT_DATE AND (CURRENT_DATE + INTERVAL '30 days') 
                THEN 1 ELSE 0 END)::INTEGER,
        SUM(
            CASE 
                WHEN cp.status = 'Active' 
                     AND cp.is_active = TRUE
                     AND cp.end_date BETWEEN (CURRENT_DATE + INTERVAL '31 days') AND (CURRENT_DATE + INTERVAL '60 days') 
                THEN 1 ELSE 0 END)::INTEGER
    INTO total_pol, active_pol, expiring_30, expiring_60
    FROM client_policies cp
        INNER JOIN policy_catalog pc ON cp.policy_catalog_id = pc.policy_catalog_id
    WHERE pc.agent_id = agent_id_param;

    -- Get company count (companies actually used in policies for this agent)
    SELECT COUNT(DISTINCT cp.company_id)::INTEGER
    INTO total_comp
    FROM client_policies cp
        INNER JOIN policy_catalog pc ON cp.policy_catalog_id = pc.policy_catalog_id
    WHERE pc.agent_id = agent_id_param
      AND cp.is_active = TRUE
      AND cp.company_id IS NOT NULL;

    -- Get client count (all clients of the agent, regardless of policy)
    SELECT COUNT(*)::INTEGER
    INTO total_cli
    FROM clients c
    WHERE c.agent_id = agent_id_param
      AND c.is_active = TRUE;

    -- Return result
    RETURN QUERY
    SELECT 
        total_pol as total_policies,
        active_pol as active_policies,
        expiring_30 as expiring_in_30_days,
        expiring_60 as expiring_in_60_days,
        total_comp as total_companies,
        total_cli as total_clients,
        (total_pol - active_pol)::INTEGER as inactive_policies;
END;
$ LANGUAGE plpgsql;

-- Update Policy Category
DROP FUNCTION IF EXISTS update_policy_category(UUID, VARCHAR, VARCHAR, BOOLEAN);

CREATE OR REPLACE FUNCTION update_policy_category(category_id_param UUID,
    category_name_param VARCHAR(50) DEFAULT NULL,
    description_param VARCHAR(200) DEFAULT NULL,
    is_active_param BOOLEAN DEFAULT NULL)
RETURNS INTEGER AS $$
DECLARE
    rows_affected INTEGER;
BEGIN
    UPDATE policy_categories
    SET 
        category_name = COALESCE(category_name_param, category_name),
        description = COALESCE(description_param, description),
        is_active = COALESCE(is_active_param, is_active)
    WHERE category_id = category_id_param;
    
    GET DIAGNOSTICS rows_affected = ROW_COUNT;
    RETURN rows_affected;
END;
$ LANGUAGE plpgsql;

-- Update Insurance Company
DROP FUNCTION IF EXISTS update_insurance_company(UUID, VARCHAR, BOOLEAN);

CREATE OR REPLACE FUNCTION update_insurance_company(company_id_param UUID,
    company_name_param VARCHAR(100) DEFAULT NULL,
    is_active_param BOOLEAN DEFAULT NULL)
RETURNS INTEGER AS $$
DECLARE
    rows_affected INTEGER;
BEGIN
    UPDATE insurance_companies
    SET 
        company_name = COALESCE(company_name_param, company_name),
        is_active = COALESCE(is_active_param, is_active)
    WHERE company_id = company_id_param;
    
    GET DIAGNOSTICS rows_affected = ROW_COUNT;
    RETURN rows_affected;
END;
$ LANGUAGE plpgsql;

-- Update Policy Type
DROP FUNCTION IF EXISTS update_policy_type(UUID, VARCHAR, BOOLEAN);

CREATE OR REPLACE FUNCTION update_policy_type(type_id_param UUID,
    type_name_param VARCHAR(50) DEFAULT NULL,
    is_active_param BOOLEAN DEFAULT NULL)
RETURNS INTEGER AS $$
DECLARE
    rows_affected INTEGER;
BEGIN
    UPDATE policy_types
    SET 
        type_name = COALESCE(type_name_param, type_name),
        is_active = COALESCE(is_active_param, is_active)
    WHERE type_id = type_id_param;
    
    GET DIAGNOSTICS rows_affected = ROW_COUNT;
    RETURN rows_affected;
END;
$ LANGUAGE plpgsql;

-- Get Policy History for Client
DROP FUNCTION IF EXISTS get_policy_history_for_client(UUID, BOOLEAN);

CREATE OR REPLACE FUNCTION get_policy_history_for_client(client_id_param UUID,
    include_inactive_param BOOLEAN DEFAULT FALSE)
RETURNS TABLE(
    policy_id UUID,
    client_id UUID,
    policy_name VARCHAR(100),
    status VARCHAR(20),
    start_date DATE,
    end_date DATE,
    notes TEXT,
    created_date TIMESTAMP,
    modified_date TIMESTAMP,
    company_id UUID,
    company_name VARCHAR(100),
    type_id UUID,
    type_name VARCHAR(50),
    policy_duration_days INTEGER,
    policy_state VARCHAR(20)
) AS $
BEGIN
    RETURN QUERY
    SELECT 
        cp.policy_id,
        cp.client_id,
        cp.policy_name,
        cp.status,
        cp.start_date,
        cp.end_date,
        cp.notes,
        cp.created_date,
        cp.modified_date,
        cp.company_id,
        ic.company_name,
        cp.type_id,
        pt.type_name,
        (cp.end_date - cp.start_date)::INTEGER as policy_duration_days,
        CASE 
            WHEN cp.status = 'Active' AND cp.end_date > CURRENT_DATE THEN 'Current'::VARCHAR
            WHEN cp.status = 'Active' AND cp.end_date <= CURRENT_DATE THEN 'Expired'::VARCHAR
            ELSE cp.status
        END as policy_state
    FROM client_policies cp
        LEFT JOIN policy_types pt ON cp.type_id = pt.type_id
        LEFT JOIN insurance_companies ic ON cp.company_id = ic.company_id
    WHERE cp.client_id = client_id_param
        AND (include_inactive_param = TRUE OR cp.is_active = TRUE)
    ORDER BY cp.start_date DESC, cp.created_date DESC;
END;
$ LANGUAGE plpgsql;
-- ============================================
-- Reminders and Messaging Stored Procedures
-- ============================================
-- ============================================
-- PostgreSQL Insurance Agent Management System
-- Converted from SQL Server Stored Procedures
-- ============================================

-- Enable UUID extension if not already enabled
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- ============================================
-- REMINDER MANAGEMENT FUNCTIONS
-- ============================================

-- Create or Update Reminder
CREATE OR REPLACE FUNCTION sp_upsert_reminder(p_agent_id UUID,
    p_reminder_type VARCHAR(50),
    p_title VARCHAR(200),
    p_reminder_date DATE,
    p_reminder_id UUID DEFAULT NULL,
    p_client_id UUID DEFAULT NULL,
    p_appointment_id UUID DEFAULT NULL,
    p_description TEXT DEFAULT NULL,
    p_reminder_time TIME DEFAULT NULL,
    p_client_name VARCHAR(150) DEFAULT NULL,
    p_priority VARCHAR(10) DEFAULT 'Medium',
    p_enable_sms BOOLEAN DEFAULT false,
    p_enable_whatsapp BOOLEAN DEFAULT false,
    p_enable_push_notification BOOLEAN DEFAULT true,
    p_advance_notice VARCHAR(20) DEFAULT '1 day',
    p_custom_message TEXT DEFAULT NULL,
    p_auto_send BOOLEAN DEFAULT false,
    p_notes TEXT DEFAULT NULL)
RETURNS TABLE(reminder_id UUID) AS $$
DECLARE
    v_reminder_id UUID;
BEGIN
    IF p_reminder_id IS NULL THEN
        -- Create new reminder
        v_reminder_id := uuid_generate_v4();
        
        INSERT INTO reminders (
            reminder_id, client_id, appointment_id, agent_id, reminder_type, title, description,
            reminder_date, reminder_time, client_name, priority, enable_sms, enable_whatsapp,
            enable_push_notification, advance_notice, custom_message, auto_send, notes
        )
        VALUES (
            v_reminder_id, p_client_id, p_appointment_id, p_agent_id, p_reminder_type, p_title, p_description,
            p_reminder_date, p_reminder_time, p_client_name, p_priority, p_enable_sms, p_enable_whatsapp,
            p_enable_push_notification, p_advance_notice, p_custom_message, p_auto_send, p_notes
        );
        
        -- Log activity
        INSERT INTO activity_log (agent_id, activity_type, entity_type, entity_id, description)
        VALUES (p_agent_id, 'reminder_created', 'reminder', v_reminder_id, 
                'Reminder "' || p_title || '" created');
    ELSE
        -- Update existing reminder
        v_reminder_id := p_reminder_id;
        
        UPDATE reminders 
        SET 
            reminder_type = p_reminder_type,
            title = p_title,
            description = p_description,
            reminder_date = p_reminder_date,
            reminder_time = p_reminder_time,
            client_name = p_client_name,
            priority = p_priority,
            enable_sms = p_enable_sms,
            enable_whatsapp = p_enable_whatsapp,
            enable_push_notification = p_enable_push_notification,
            advance_notice = p_advance_notice,
            custom_message = p_custom_message,
            auto_send = p_auto_send,
            notes = p_notes,
            modified_date = NOW()
        WHERE reminder_id = p_reminder_id;
        
        -- Log activity
        INSERT INTO activity_log (agent_id, activity_type, entity_type, entity_id, description)
        VALUES (p_agent_id, 'reminder_updated', 'reminder', v_reminder_id, 
                'Reminder "' || p_title || '" updated');
    END IF;
    
    RETURN QUERY SELECT v_reminder_id;
END;
$ LANGUAGE plpgsql;

-- Get All Reminders with comprehensive data
CREATE OR REPLACE FUNCTION sp_get_all_reminders(p_agent_id UUID,
    p_start_date DATE DEFAULT NULL,
    p_end_date DATE DEFAULT NULL,
    p_page_number INTEGER DEFAULT 1,
    p_page_size INTEGER DEFAULT 20)
RETURNS TABLE(
    reminder_id UUID,
    client_id UUID,
    appointment_id UUID,
    agent_id UUID,
    reminder_type VARCHAR(50),
    title VARCHAR(200),
    description TEXT,
    reminder_date DATE,
    reminder_time TIME,
    client_name VARCHAR(150),
    priority VARCHAR(10),
    status VARCHAR(20),
    enable_sms BOOLEAN,
    enable_whatsapp BOOLEAN,
    enable_push_notification BOOLEAN,
    advance_notice VARCHAR(20),
    custom_message TEXT,
    auto_send BOOLEAN,
    notes TEXT,
    created_date TIMESTAMP,
    modified_date TIMESTAMP,
    completed_date TIMESTAMP
) AS $
DECLARE
    v_offset INTEGER;
BEGIN
    v_offset := (p_page_number - 1) * p_page_size;
    
    RETURN QUERY
    WITH all_reminders AS (
        -- 1. Manual Reminders from reminders table
        SELECT 
            r.reminder_id,
            r.client_id,
            r.appointment_id,
            r.agent_id,
            CASE WHEN r.reminder_type = 'Policy Expiry' THEN 'Maturing Policy' ELSE r.reminder_type END AS reminder_type,
            r.title,
            r.description,
            r.reminder_date,
            r.reminder_time,
            r.client_name,
            r.priority,
            r.status,
            r.enable_sms,
            r.enable_whatsapp,
            r.enable_push_notification,
            r.advance_notice,
            r.custom_message,
            r.auto_send,
            r.notes,
            r.created_date,
            r.modified_date,
            r.completed_date
        FROM reminders r
        WHERE r.agent_id = p_agent_id

        UNION ALL

        -- 2. Maturing Policies
        SELECT 
            uuid_generate_v4() AS reminder_id,
            cp.client_id,
            NULL::UUID AS appointment_id,
            c.agent_id,
            'Maturing Policy'::VARCHAR(50) AS reminder_type,
            cp.policy_name AS title,
            CONCAT('Policy for ', cp.policy_name, ' is maturing soon') AS description,
            cp.end_date AS reminder_date,
            NULL::TIME AS reminder_time,
            CONCAT(c.first_name, ' ', c.surname) AS client_name,
            'High'::VARCHAR(10) AS priority,
            'Active'::VARCHAR(20) AS status,
            false, false, true, '7 days'::VARCHAR(20), NULL::TEXT, false, NULL::TEXT,
            NOW(), NOW(), NULL::TIMESTAMP
        FROM client_policies cp
        INNER JOIN clients c ON c.client_id = cp.client_id
        WHERE c.agent_id = p_agent_id
          AND cp.is_active = true
          AND (p_start_date IS NULL OR cp.end_date >= p_start_date)
          AND (p_end_date IS NULL OR cp.end_date <= p_end_date)

        UNION ALL

        -- 3. Birthdays (next 7 days)
        SELECT 
            uuid_generate_v4() AS reminder_id,
            c.client_id,
            NULL::UUID AS appointment_id,
            c.agent_id,
            'Birthday'::VARCHAR(50) AS reminder_type,
            'Birthday Reminder'::VARCHAR(200) AS title,
            CONCAT('Wish ', c.first_name, ' ', c.surname, ' a Happy Birthday!') AS description,
            MAKE_DATE(EXTRACT(YEAR FROM NOW())::INTEGER, EXTRACT(MONTH FROM c.date_of_birth)::INTEGER, EXTRACT(DAY FROM c.date_of_birth)::INTEGER) AS reminder_date,
            NULL::TIME AS reminder_time,
            CONCAT(c.first_name, ' ', c.surname) AS client_name,
            'Low'::VARCHAR(10) AS priority,
            'Active'::VARCHAR(20) AS status,
            false, false, true, '1 day'::VARCHAR(20), NULL::TEXT, false, NULL::TEXT,
            NOW(), NOW(), NULL::TIMESTAMP
        FROM clients c
        WHERE c.agent_id = p_agent_id
          AND c.is_active = true
          AND MAKE_DATE(EXTRACT(YEAR FROM NOW())::INTEGER, EXTRACT(MONTH FROM c.date_of_birth)::INTEGER, EXTRACT(DAY FROM c.date_of_birth)::INTEGER)
              BETWEEN NOW()::DATE AND (NOW() + INTERVAL '7 days')::DATE

        UNION ALL

        -- 4. Appointments
        SELECT 
            uuid_generate_v4() AS reminder_id,
            a.client_id,
            a.appointment_id,
            a.agent_id,
            'Appointment'::VARCHAR(50) AS reminder_type,
            a.title,
            a.description,
            a.appointment_date AS reminder_date,
            a.start_time AS reminder_time,
            a.client_name,
            a.priority,
            a.status,
            false, false, true, '1 day'::VARCHAR(20), NULL::TEXT, false, a.notes,
            a.created_date,
            a.modified_date,
            NULL::TIMESTAMP
        FROM appointments a
        WHERE a.agent_id = p_agent_id
          AND a.is_active = true
          AND (p_start_date IS NULL OR a.appointment_date >= p_start_date)
          AND (p_end_date IS NULL OR a.appointment_date <= p_end_date)
    )
    SELECT *
    FROM all_reminders
    ORDER BY reminder_date ASC, reminder_time ASC
    LIMIT p_page_size OFFSET v_offset;
END;
$ LANGUAGE plpgsql;

-- Get Today's Reminders
CREATE OR REPLACE FUNCTION sp_get_today_reminders(p_agent_id UUID)
RETURNS TABLE(
    reminder_id UUID,
    reminder_type VARCHAR(50),
    title VARCHAR(200),
    description TEXT,
    reminder_time TIME,
    client_name VARCHAR(150),
    priority VARCHAR(10),
    enable_sms BOOLEAN,
    enable_whatsapp BOOLEAN,
    enable_push_notification BOOLEAN,
    custom_message TEXT,
    notes TEXT
) AS $
BEGIN
    RETURN QUERY
    SELECT 
        r.reminder_id,
        r.reminder_type,
        r.title,
        r.description,
        r.reminder_time,
        r.client_name,
        r.priority,
        r.enable_sms,
        r.enable_whatsapp,
        r.enable_push_notification,
        r.custom_message,
        r.notes
    FROM reminders r
    WHERE 
        r.agent_id = p_agent_id 
        AND r.status = 'Active'
        AND r.reminder_date = CURRENT_DATE
    ORDER BY r.reminder_time ASC;
END;
$ LANGUAGE plpgsql;

-- Complete Reminder
CREATE OR REPLACE FUNCTION sp_complete_reminder(p_reminder_id UUID,
    p_agent_id UUID)
RETURNS TABLE(rows_affected INTEGER) AS $
DECLARE
    v_title VARCHAR(200);
    v_affected_rows INTEGER;
BEGIN
    -- Get reminder title for logging
    SELECT title INTO v_title FROM reminders WHERE reminder_id = p_reminder_id;
    
    UPDATE reminders 
    SET 
        status = 'Completed',
        completed_date = NOW(),
        modified_date = NOW()
    WHERE reminder_id = p_reminder_id AND agent_id = p_agent_id;
    
    GET DIAGNOSTICS v_affected_rows = ROW_COUNT;
    
    -- Log activity
    INSERT INTO activity_log (agent_id, activity_type, entity_type, entity_id, description)
    VALUES (p_agent_id, 'reminder_completed', 'reminder', p_reminder_id, 
            'Reminder "' || v_title || '" marked as completed');
    
    RETURN QUERY SELECT v_affected_rows;
END;
$ LANGUAGE plpgsql;

-- Delete Reminder
CREATE OR REPLACE FUNCTION sp_delete_reminder(p_reminder_id UUID,
    p_agent_id UUID)
RETURNS TABLE(rows_affected INTEGER) AS $
DECLARE
    v_title VARCHAR(200);
    v_affected_rows INTEGER;
BEGIN
    -- Get reminder title for logging
    SELECT title INTO v_title FROM reminders WHERE reminder_id = p_reminder_id;
    
    DELETE FROM reminders 
    WHERE reminder_id = p_reminder_id AND agent_id = p_agent_id;
    
    GET DIAGNOSTICS v_affected_rows = ROW_COUNT;
    
    -- Log activity
    INSERT INTO activity_log (agent_id, activity_type, entity_type, entity_id, description)
    VALUES (p_agent_id, 'reminder_deleted', 'reminder', p_reminder_id, 
            'Reminder "' || v_title || '" deleted');
    
    RETURN QUERY SELECT v_affected_rows;
END;
$ LANGUAGE plpgsql;

-- Get Reminder Statistics
CREATE OR REPLACE FUNCTION sp_get_reminder_statistics(p_agent_id UUID)
RETURNS TABLE(
    total_active INTEGER,
    total_completed INTEGER,
    today_reminders INTEGER,
    upcoming_reminders INTEGER,
    high_priority INTEGER,
    overdue INTEGER
) AS $
BEGIN
    RETURN QUERY
    SELECT 
        (SELECT COUNT(*)::INTEGER FROM reminders WHERE agent_id = p_agent_id AND status = 'Active') AS total_active,
        (SELECT COUNT(*)::INTEGER FROM reminders WHERE agent_id = p_agent_id AND status = 'Completed') AS total_completed,
        (SELECT COUNT(*)::INTEGER FROM reminders WHERE agent_id = p_agent_id AND status = 'Active' AND reminder_date = CURRENT_DATE) AS today_reminders,
        (SELECT COUNT(*)::INTEGER FROM reminders WHERE agent_id = p_agent_id AND status = 'Active' AND reminder_date BETWEEN CURRENT_DATE AND (CURRENT_DATE + INTERVAL '7 days')) AS upcoming_reminders,
        (SELECT COUNT(*)::INTEGER FROM reminders WHERE agent_id = p_agent_id AND status = 'Active' AND priority = 'High') AS high_priority,
        (SELECT COUNT(*)::INTEGER FROM reminders WHERE agent_id = p_agent_id AND status = 'Active' AND reminder_date < CURRENT_DATE) AS overdue;
END;
$ LANGUAGE plpgsql;

-- ============================================
-- REMINDER SETTINGS MANAGEMENT
-- ============================================

-- Update Reminder Settings
CREATE OR REPLACE FUNCTION sp_update_reminder_settings(p_agent_id UUID,
    p_reminder_type VARCHAR(50),
    p_is_enabled BOOLEAN,
    p_days_before INTEGER,
    p_time_of_day TIME,
    p_repeat_daily BOOLEAN DEFAULT false)
RETURNS VOID AS $$
BEGIN
    -- Check if setting exists, create or update
    IF EXISTS (SELECT 1 FROM reminder_settings WHERE agent_id = p_agent_id AND reminder_type = p_reminder_type) THEN
        UPDATE reminder_settings 
        SET 
            is_enabled = p_is_enabled,
            days_before = p_days_before,
            time_of_day = p_time_of_day,
            repeat_daily = p_repeat_daily,
            modified_date = NOW()
        WHERE agent_id = p_agent_id AND reminder_type = p_reminder_type;
    ELSE
        INSERT INTO reminder_settings (agent_id, reminder_type, is_enabled, days_before, time_of_day, repeat_daily)
        VALUES (p_agent_id, p_reminder_type, p_is_enabled, p_days_before, p_time_of_day, p_repeat_daily);
    END IF;
END;
$ LANGUAGE plpgsql;

-- Get Reminder Settings
CREATE OR REPLACE FUNCTION sp_get_reminder_settings(p_agent_id UUID)
RETURNS TABLE(
    reminder_setting_id UUID,
    reminder_type VARCHAR(50),
    is_enabled BOOLEAN,
    days_before INTEGER,
    time_of_day TIME,
    repeat_daily BOOLEAN,
    created_date TIMESTAMP,
    modified_date TIMESTAMP
) AS $
BEGIN
    RETURN QUERY
    SELECT 
        rs.reminder_setting_id,
        rs.reminder_type,
        rs.is_enabled,
        rs.days_before,
        rs.time_of_day,
        rs.repeat_daily,
        rs.created_date,
        rs.modified_date
    FROM reminder_settings rs
    WHERE rs.agent_id = p_agent_id
    ORDER BY rs.reminder_type;
END;
$ LANGUAGE plpgsql;

-- ============================================
-- AUTOMATED MESSAGING
-- ============================================

-- Create Automated Message
CREATE OR REPLACE FUNCTION sp_create_automated_message(p_agent_id UUID,
    p_message_type VARCHAR(50),
    p_title VARCHAR(200),
    p_template TEXT,
    p_scheduled_date TIMESTAMP,
    p_delivery_method VARCHAR(20),
    p_recipients TEXT DEFAULT NULL)
RETURNS TABLE(message_id UUID) AS $$
DECLARE
    v_message_id UUID;
    v_phone VARCHAR(20);
    v_pos INTEGER := 1;
    v_next_pos INTEGER;
BEGIN
    v_message_id := uuid_generate_v4();
    
    INSERT INTO automated_messages (
        message_id, agent_id, message_type, title, template,
        scheduled_date, delivery_method, recipients
    )
    VALUES (
        v_message_id, p_agent_id, p_message_type, p_title, p_template,
        p_scheduled_date, p_delivery_method, p_recipients
    );
    
    -- If recipients are provided, create individual recipient records
    IF p_recipients IS NOT NULL AND p_recipients != '' THEN
        -- Simple comma-separated parsing
        p_recipients := REPLACE(p_recipients, ' ', '');
        WHILE v_pos <= LENGTH(p_recipients) LOOP
            v_next_pos := POSITION(',' IN SUBSTRING(p_recipients FROM v_pos));
            IF v_next_pos = 0 THEN
                v_next_pos := LENGTH(p_recipients) - v_pos + 2;
            END IF;
            
            v_phone := SUBSTRING(p_recipients FROM v_pos FOR v_next_pos - 1);
            
            IF LENGTH(v_phone) > 0 THEN
                INSERT INTO message_recipients (message_id, phone_number)
                VALUES (v_message_id, v_phone);
            END IF;
            
            v_pos := v_pos + v_next_pos;
        END LOOP;
    END IF;
    
    -- Log activity
    INSERT INTO activity_log (agent_id, activity_type, entity_type, entity_id, description)
    VALUES (p_agent_id, 'automated_message_created', 'automated_message', v_message_id, 
            'Automated message "' || p_title || '" scheduled');
    
    RETURN QUERY SELECT v_message_id;
END;
$ LANGUAGE plpgsql;

-- Get Automated Messages
CREATE OR REPLACE FUNCTION sp_get_automated_messages(p_agent_id UUID,
    p_status VARCHAR(20) DEFAULT 'All')
RETURNS TABLE(
    message_id UUID,
    agent_id UUID,
    message_type VARCHAR(50),
    title VARCHAR(200),
    template TEXT,
    scheduled_date TIMESTAMP,
    delivery_method VARCHAR(20),
    status VARCHAR(20),
    recipients TEXT,
    created_date TIMESTAMP,
    modified_date TIMESTAMP,
    sent_date TIMESTAMP,
    recipient_count BIGINT,
    delivered_count BIGINT,
    failed_count BIGINT
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        am.message_id,
        am.agent_id,
        am.message_type,
        am.title,
        am.template,
        am.scheduled_date,
        am.delivery_method,
        am.status,
        am.recipients,
        am.created_date,
        am.modified_date,
        am.sent_date,
        COUNT(mr.recipient_id) AS recipient_count,
        COUNT(CASE WHEN mr.delivery_status = 'Delivered' THEN 1 END) AS delivered_count,
        COUNT(CASE WHEN mr.delivery_status = 'Failed' THEN 1 END) AS failed_count
    FROM automated_messages am
    LEFT JOIN message_recipients mr ON am.message_id = mr.message_id
    WHERE 
        am.agent_id = p_agent_id
        AND (p_status = 'All' OR am.status = p_status)
    GROUP BY 
        am.message_id, am.agent_id, am.message_type, am.title, am.template,
        am.scheduled_date, am.delivery_method, am.status, am.recipients,
        am.created_date, am.modified_date, am.sent_date
    ORDER BY am.scheduled_date DESC;
END;
$ LANGUAGE plpgsql;

-- Delete Automated Message
CREATE OR REPLACE FUNCTION sp_delete_automated_message(p_message_id UUID,
    p_agent_id UUID)
RETURNS TABLE(rows_affected INTEGER) AS $
DECLARE
    v_title VARCHAR(200);
    v_affected_rows INTEGER;
BEGIN
    -- Get message title for logging
    SELECT title INTO v_title FROM automated_messages WHERE message_id = p_message_id;
    
    -- Delete recipients first (cascade should handle this, but being explicit)
    DELETE FROM message_recipients WHERE message_id = p_message_id;
    
    -- Delete message
    DELETE FROM automated_messages 
    WHERE message_id = p_message_id AND agent_id = p_agent_id;
    
    GET DIAGNOSTICS v_affected_rows = ROW_COUNT;
    
    -- Log activity
    INSERT INTO activity_log (agent_id, activity_type, entity_type, entity_id, description)
    VALUES (p_agent_id, 'automated_message_deleted', 'automated_message', p_message_id, 
            'Automated message "' || v_title || '" deleted');
    
    RETURN QUERY SELECT v_affected_rows;
END;
$ LANGUAGE plpgsql;

-- ============================================
-- DAILY NOTES MANAGEMENT
-- ============================================

-- Save Daily Notes
CREATE OR REPLACE FUNCTION sp_save_daily_notes(p_agent_id UUID,
    p_note_date DATE,
    p_notes TEXT)
RETURNS VOID AS $
BEGIN
    -- Check if notes exist for this date
    IF EXISTS (SELECT 1 FROM daily_notes WHERE agent_id = p_agent_id AND note_date = p_note_date) THEN
        UPDATE daily_notes 
        SET notes = p_notes, modified_date = NOW()
        WHERE agent_id = p_agent_id AND note_date = p_note_date;
    ELSE
        INSERT INTO daily_notes (agent_id, note_date, notes)
        VALUES (p_agent_id, p_note_date, p_notes);
    END IF;
    
    -- Log activity
    INSERT INTO activity_log (agent_id, activity_type, entity_type, entity_id, description)
    VALUES (p_agent_id, 'daily_notes_updated', 'daily_notes', NULL, 
            'Daily notes updated for ' || TO_CHAR(p_note_date, 'Month DD, YYYY'));
END;
$ LANGUAGE plpgsql;

-- Get Daily Notes
CREATE OR REPLACE FUNCTION sp_get_daily_notes(p_agent_id UUID,
    p_note_date DATE)
RETURNS TABLE(
    note_id UUID,
    note_date DATE,
    notes TEXT,
    created_date TIMESTAMP,
    modified_date TIMESTAMP
) AS $
BEGIN
    RETURN QUERY
    SELECT 
        dn.note_id,
        dn.note_date,
        dn.notes,
        dn.created_date,
        dn.modified_date
    FROM daily_notes dn
    WHERE dn.agent_id = p_agent_id AND dn.note_date = p_note_date;
END;
$ LANGUAGE plpgsql;

-- Get All Notes
CREATE OR REPLACE FUNCTION sp_get_all_notes(p_agent_id UUID,
    p_start_date DATE DEFAULT NULL,
    p_end_date DATE DEFAULT NULL)
RETURNS TABLE(
    note_id UUID,
    agent_id UUID,
    note_date DATE,
    notes TEXT,
    created_date TIMESTAMP,
    modified_date TIMESTAMP
) AS $
BEGIN
    IF p_start_date IS NULL THEN
        p_start_date := CURRENT_DATE - INTERVAL '3 months';
    END IF;
    
    IF p_end_date IS NULL THEN
        p_end_date := CURRENT_DATE;
    END IF;
    
    RETURN QUERY
    SELECT 
        dn.note_id,
        dn.agent_id,
        dn.note_date,
        dn.notes,
        dn.created_date,
        dn.modified_date
    FROM daily_notes dn
    WHERE 
        dn.agent_id = p_agent_id 
        AND dn.note_date BETWEEN p_start_date AND p_end_date
    ORDER BY dn.note_date DESC;
END;
$ LANGUAGE plpgsql;

-- Search Notes
CREATE OR REPLACE FUNCTION sp_search_notes(p_agent_id UUID,
    p_search_term VARCHAR(500))
RETURNS TABLE(
    note_id UUID,
    agent_id UUID,
    note_date DATE,
    notes TEXT,
    created_date TIMESTAMP,
    modified_date TIMESTAMP
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        dn.note_id,
        dn.agent_id,
        dn.note_date,
        dn.notes,
        dn.created_date,
        dn.modified_date
    FROM daily_notes dn
    WHERE 
        dn.agent_id = p_agent_id 
        AND dn.notes ILIKE '%' || p_search_term || '%'
    ORDER BY dn.note_date DESC;
END;
$ LANGUAGE plpgsql;

-- Delete Notes
CREATE OR REPLACE FUNCTION sp_delete_notes(p_agent_id UUID,
    p_note_date DATE)
RETURNS TABLE(rows_affected INTEGER) AS $
DECLARE
    v_affected_rows INTEGER;
BEGIN
    DELETE FROM daily_notes 
    WHERE agent_id = p_agent_id AND note_date = p_note_date;
    
    GET DIAGNOSTICS v_affected_rows = ROW_COUNT;
    
    RETURN QUERY SELECT v_affected_rows;
END;
$ LANGUAGE plpgsql;

-- ============================================
-- NAVBAR BADGE COUNTS
-- ============================================

-- Get Navbar Badge Counts
CREATE OR REPLACE FUNCTION get_navbar_badge_counts(p_agent_id UUID)
RETURNS TABLE(
    clients_count BIGINT,
    policies_count BIGINT,
    reminders_count BIGINT,
    appointments_count BIGINT
) AS $
BEGIN
    RETURN QUERY
    SELECT 
        -- Clients (only active ones)
        COUNT(DISTINCT CASE WHEN c.is_active = true THEN c.client_id END) AS clients_count,

        -- Policies (only active)
        COUNT(DISTINCT CASE WHEN p.is_active = true THEN p.policy_id END) AS policies_count,

        -- Reminders (pending/active)
        COUNT(DISTINCT CASE WHEN r.status = 'Active' THEN r.reminder_id END) AS reminders_count,

        -- Appointments (upcoming or active)
        COUNT(DISTINCT CASE 
                    WHEN a.is_active = true 
                         AND a.status NOT IN ('Completed', 'Cancelled') 
                    THEN a.appointment_id END) AS appointments_count
    FROM (SELECT 1 AS dummy) d
    LEFT JOIN clients c 
        ON c.agent_id = p_agent_id
    LEFT JOIN client_policies p 
        ON p.client_id = c.client_id
    LEFT JOIN reminders r 
        ON r.agent_id = p_agent_id
    LEFT JOIN appointments a 
        ON a.agent_id = p_agent_id;
END;
$ LANGUAGE plpgsql;

-- ============================================
-- BIRTHDAY AND POLICY EXPIRY REMINDERS
-- ============================================

-- Get Today's Birthday Reminders
CREATE OR REPLACE FUNCTION sp_get_today_birthday_reminders(p_agent_id UUID)
RETURNS TABLE(
    client_id UUID,
    first_name VARCHAR(50),
    surname VARCHAR(50),
    last_name VARCHAR(50),
    phone_number VARCHAR(20),
    email VARCHAR(100),
    date_of_birth DATE,
    age INTEGER
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        c.client_id,
        c.first_name,
        c.surname,
        c.last_name,
        c.phone_number,
        c.email,
        c.date_of_birth,
        EXTRACT(YEAR FROM AGE(NOW(), c.date_of_birth))::INTEGER AS age
    FROM clients c
    WHERE 
        c.agent_id = p_agent_id 
        AND c.is_active = true
        AND EXTRACT(DAY FROM c.date_of_birth) = EXTRACT(DAY FROM CURRENT_DATE)
        AND EXTRACT(MONTH FROM c.date_of_birth) = EXTRACT(MONTH FROM CURRENT_DATE);
END;
$ LANGUAGE plpgsql;

-- Get Policy Expiry Reminders

-- Get Policy Expiry Reminders
CREATE OR REPLACE FUNCTION sp_get_policy_expiry_reminders(p_agent_id UUID,
    p_days_ahead INTEGER DEFAULT 30)
RETURNS TABLE(
    policy_id UUID,
    client_id UUID,
    policy_name VARCHAR(100),
    policy_type VARCHAR(50),
    company_name VARCHAR(100),
    end_date DATE,
    first_name VARCHAR(50),
    surname VARCHAR(50),
    phone_number VARCHAR(20),
    email VARCHAR(100),
    days_until_expiry INTEGER
) AS $
BEGIN
    RETURN QUERY
    SELECT 
        cp.policy_id,
        cp.client_id,
        cp.policy_name,
        cp.policy_type,
        cp.company_name,
        cp.end_date,
        c.first_name,
        c.surname,
        c.phone_number,
        c.email,
        (cp.end_date - CURRENT_DATE)::INTEGER AS days_until_expiry
    FROM client_policies cp
    INNER JOIN clients c ON cp.client_id = c.client_id
    WHERE 
        c.agent_id = p_agent_id 
        AND cp.status = 'Active'
        AND cp.is_active = true
        AND c.is_active = true
        AND cp.end_date BETWEEN CURRENT_DATE AND (CURRENT_DATE + INTERVAL '1 day' * p_days_ahead)
    ORDER BY cp.end_date ASC;
END;
$ LANGUAGE plpgsql;

-- ============================================
-- PHONE NUMBER VALIDATION
-- ============================================

-- Validate Phone Number
CREATE OR REPLACE FUNCTION sp_validate_phone_number(p_phone_number VARCHAR(20),
    p_country_code VARCHAR(5) DEFAULT '+254')
RETURNS TABLE(
    is_valid BOOLEAN,
    formatted_number VARCHAR(20),
    validation_message VARCHAR(200)
) AS  $$
$
DECLARE
    v_is_valid BOOLEAN := false
$$ LANGUAGE plpgsql;
    v_formatted_number VARCHAR(20) := '';
    v_validation_message VARCHAR(200) := '';
    v_cleaned_number VARCHAR(20);
BEGIN
    -- Remove spaces, dashes, and other formatting
    v_cleaned_number := REGEXP_REPLACE(p_phone_number, '[^0-9]', '', 'g');
    
    -- Basic validation for Kenyan numbers
    IF LENGTH(v_cleaned_number) = 10 AND LEFT(v_cleaned_number, 1) = '0' THEN
        v_formatted_number := p_country_code || RIGHT(v_cleaned_number, 9);
        v_is_valid := true;
        v_validation_message := 'Valid phone number';
    ELSIF LENGTH(v_cleaned_number) = 9 THEN
        v_formatted_number := p_country_code || v_cleaned_number;
        v_is_valid := true;
        v_validation_message := 'Valid phone number';
    ELSIF LENGTH(v_cleaned_number) = 13 AND LEFT(v_cleaned_number, 3) = '254' THEN
        v_formatted_number := '+' || v_cleaned_number;
        v_is_valid := true;
        v_validation_message := 'Valid phone number';
    ELSE
        v_validation_message := 'Invalid phone number format';
    END IF;
    
    RETURN QUERY SELECT v_is_valid, v_formatted_number, v_validation_message;
END;
$ LANGUAGE plpgsql;

-- ============================================
-- REMINDER FILTERING FUNCTIONS
-- ============================================

-- Get Reminders by Type
CREATE OR REPLACE FUNCTION sp_get_reminders_by_type(p_agent_id UUID,
    p_reminder_type VARCHAR(50))
RETURNS TABLE(
    reminder_id UUID,
    client_id UUID,
    appointment_id UUID,
    agent_id UUID,
    reminder_type VARCHAR(50),
    title VARCHAR(200),
    description TEXT,
    reminder_date DATE,
    reminder_time TIME,
    client_name VARCHAR(150),
    priority VARCHAR(10),
    status VARCHAR(20),
    enable_sms BOOLEAN,
    enable_whatsapp BOOLEAN,
    enable_push_notification BOOLEAN,
    advance_notice VARCHAR(20),
    custom_message TEXT,
    auto_send BOOLEAN,
    notes TEXT,
    created_date TIMESTAMP,
    modified_date TIMESTAMP,
    completed_date TIMESTAMP
) AS  $$
$
BEGIN
    RETURN QUERY
    SELECT 
        r.reminder_id,
        r.client_id,
        r.appointment_id,
        r.agent_id,
        r.reminder_type,
        r.title,
        r.description,
        r.reminder_date,
        r.reminder_time,
        r.client_name,
        r.priority,
        r.status,
        r.enable_sms,
        r.enable_whatsapp,
        r.enable_push_notification,
        r.advance_notice,
        r.custom_message,
        r.auto_send,
        r.notes,
        r.created_date,
        r.modified_date,
        r.completed_date
    FROM reminders r
    WHERE r.agent_id = p_agent_id
      AND r.reminder_type = p_reminder_type
    ORDER BY r.reminder_date, r.reminder_time
$$ LANGUAGE plpgsql;
END;
$ LANGUAGE plpgsql;

-- Get Reminders by Status
CREATE OR REPLACE FUNCTION sp_get_reminders_by_status(p_agent_id UUID,
    p_status VARCHAR(20))
RETURNS TABLE(
    reminder_id UUID,
    client_id UUID,
    appointment_id UUID,
    agent_id UUID,
    reminder_type VARCHAR(50),
    title VARCHAR(200),
    description TEXT,
    reminder_date DATE,
    reminder_time TIME,
    client_name VARCHAR(150),
    priority VARCHAR(10),
    status VARCHAR(20),
    enable_sms BOOLEAN,
    enable_whatsapp BOOLEAN,
    enable_push_notification BOOLEAN,
    advance_notice VARCHAR(20),
    custom_message TEXT,
    auto_send BOOLEAN,
    notes TEXT,
    created_date TIMESTAMP,
    modified_date TIMESTAMP,
    completed_date TIMESTAMP
) AS  $$
$
BEGIN
    RETURN QUERY
    SELECT 
        r.reminder_id,
        r.client_id,
        r.appointment_id,
        r.agent_id,
        r.reminder_type,
        r.title,
        r.description,
        r.reminder_date,
        r.reminder_time,
        r.client_name,
        r.priority,
        r.status,
        r.enable_sms,
        r.enable_whatsapp,
        r.enable_push_notification,
        r.advance_notice,
        r.custom_message,
        r.auto_send,
        r.notes,
        r.created_date,
        r.modified_date,
        r.completed_date
    FROM reminders r
    WHERE r.agent_id = p_agent_id
      AND r.status = p_status
    ORDER BY r.reminder_date, r.reminder_time
$$ LANGUAGE plpgsql;
END;
$ LANGUAGE plpgsql;

-- ============================================
-- COMPREHENSIVE REMINDER FUNCTIONS
-- ============================================

-- Get All Reminders with Filters
CREATE OR REPLACE FUNCTION sp_get_all_reminders_filtered(p_agent_id UUID,
    p_reminder_type VARCHAR(50) DEFAULT NULL,
    p_status VARCHAR(20) DEFAULT NULL,
    p_priority VARCHAR(10) DEFAULT NULL,
    p_start_date DATE DEFAULT NULL,
    p_end_date DATE DEFAULT NULL,
    p_client_id UUID DEFAULT NULL,
    p_page_size INTEGER DEFAULT 50,
    p_page_number INTEGER DEFAULT 1)
RETURNS TABLE(
    reminder_id UUID,
    client_id UUID,
    appointment_id UUID,
    agent_id UUID,
    reminder_type VARCHAR(50),
    title VARCHAR(200),
    description TEXT,
    reminder_date DATE,
    reminder_time TIME,
    client_name VARCHAR(150),
    priority VARCHAR(10),
    status VARCHAR(20),
    enable_sms BOOLEAN,
    enable_whatsapp BOOLEAN,
    enable_push_notification BOOLEAN,
    advance_notice VARCHAR(20),
    custom_message TEXT,
    auto_send BOOLEAN,
    notes TEXT,
    created_date TIMESTAMP,
    modified_date TIMESTAMP,
    completed_date TIMESTAMP,
    client_phone VARCHAR(20),
    client_email VARCHAR(100)
) AS  $$
$
DECLARE
    v_offset INTEGER
$$ LANGUAGE plpgsql;
BEGIN
    v_offset := (p_page_number - 1) * p_page_size;
    
    RETURN QUERY
    SELECT 
        r.reminder_id,
        r.client_id,
        r.appointment_id,
        r.agent_id,
        r.reminder_type,
        r.title,
        r.description,
        r.reminder_date,
        r.reminder_time,
        r.client_name,
        r.priority,
        r.status,
        r.enable_sms,
        r.enable_whatsapp,
        r.enable_push_notification,
        r.advance_notice,
        r.custom_message,
        r.auto_send,
        r.notes,
        r.created_date,
        r.modified_date,
        r.completed_date,
        c.phone_number AS client_phone,
        c.email AS client_email
    FROM reminders r
    LEFT JOIN clients c ON r.client_id = c.client_id
    WHERE 
        r.agent_id = p_agent_id
        AND (p_reminder_type IS NULL OR r.reminder_type = p_reminder_type)
        AND (p_status IS NULL OR r.status = p_status)
        AND (p_priority IS NULL OR r.priority = p_priority)
        AND (p_start_date IS NULL OR r.reminder_date >= p_start_date)
        AND (p_end_date IS NULL OR r.reminder_date <= p_end_date)
        AND (p_client_id IS NULL OR r.client_id = p_client_id)
    ORDER BY r.reminder_date ASC, r.reminder_time ASC
    LIMIT p_page_size OFFSET v_offset;
END;
$ LANGUAGE plpgsql;

-- Get Reminder by ID
CREATE OR REPLACE FUNCTION sp_get_reminder_by_id(p_reminder_id UUID,
    p_agent_id UUID)
RETURNS TABLE(
    reminder_id UUID,
    client_id UUID,
    appointment_id UUID,
    agent_id UUID,
    reminder_type VARCHAR(50),
    title VARCHAR(200),
    description TEXT,
    reminder_date DATE,
    reminder_time TIME,
    client_name VARCHAR(150),
    priority VARCHAR(10),
    status VARCHAR(20),
    enable_sms BOOLEAN,
    enable_whatsapp BOOLEAN,
    enable_push_notification BOOLEAN,
    advance_notice VARCHAR(20),
    custom_message TEXT,
    auto_send BOOLEAN,
    notes TEXT,
    created_date TIMESTAMP,
    modified_date TIMESTAMP,
    completed_date TIMESTAMP,
    client_phone VARCHAR(20),
    client_email VARCHAR(100),
    full_client_name VARCHAR(152)
) AS $
 $
BEGIN
    RETURN QUERY
    SELECT 
        r.reminder_id,
        r.client_id,
        r.appointment_id,
        r.agent_id,
        r.reminder_type,
        r.title,
        r.description,
        r.reminder_date,
        r.reminder_time,
        r.client_name,
        r.priority,
        r.status,
        r.enable_sms,
        r.enable_whatsapp,
        r.enable_push_notification,
        r.advance_notice,
        r.custom_message,
        r.auto_send,
        r.notes,
        r.created_date,
        r.modified_date,
        r.completed_date,
        c.phone_number AS client_phone,
        c.email AS client_email,
        (c.first_name || ' ' || c.surname)::VARCHAR(152) AS  $$
full_client_name
    FROM reminders r
    LEFT JOIN clients c ON r.client_id = c.client_id
    WHERE r.reminder_id = p_reminder_id AND r.agent_id = p_agent_id
$$ LANGUAGE plpgsql;
END;
$ LANGUAGE plpgsql;

-- Create Reminder
CREATE OR REPLACE FUNCTION sp_create_reminder(p_agent_id UUID,
    p_reminder_type VARCHAR(50),
    p_title VARCHAR(200),
    p_reminder_date DATE,
    p_client_id UUID DEFAULT NULL,
    p_appointment_id UUID DEFAULT NULL,
    p_description TEXT DEFAULT NULL,
    p_reminder_time TIME DEFAULT NULL,
    p_client_name VARCHAR(150) DEFAULT NULL,
    p_priority VARCHAR(10) DEFAULT 'Medium',
    p_enable_sms BOOLEAN DEFAULT false,
    p_enable_whatsapp BOOLEAN DEFAULT false,
    p_enable_push_notification BOOLEAN DEFAULT true,
    p_advance_notice VARCHAR(20) DEFAULT '1 day',
    p_custom_message TEXT DEFAULT NULL,
    p_auto_send BOOLEAN DEFAULT false,
    p_notes TEXT DEFAULT NULL)
RETURNS TABLE(reminder_id UUID) AS  $$
$
DECLARE
    v_reminder_id UUID
$$ LANGUAGE plpgsql;
BEGIN
    v_reminder_id := uuid_generate_v4();
    
    -- Get client name if not provided but client_id is provided
    IF p_client_name IS NULL AND p_client_id IS NOT NULL THEN
        SELECT (first_name || ' ' || surname) INTO p_client_name 
        FROM clients 
        WHERE client_id = p_client_id AND agent_id = p_agent_id;
    END IF;
    
    INSERT INTO reminders (
        reminder_id, client_id, appointment_id, agent_id, reminder_type, title, description,
        reminder_date, reminder_time, client_name, priority, status, enable_sms, enable_whatsapp,
        enable_push_notification, advance_notice, custom_message, auto_send, notes
    )
    VALUES (
        v_reminder_id, p_client_id, p_appointment_id, p_agent_id, p_reminder_type, p_title, p_description,
        p_reminder_date, p_reminder_time, p_client_name, p_priority, 'Active', p_enable_sms, p_enable_whatsapp,
        p_enable_push_notification, p_advance_notice, p_custom_message, p_auto_send, p_notes
    );
    
    RETURN QUERY SELECT v_reminder_id;
END;
$ LANGUAGE plpgsql;

-- Update Reminder
CREATE OR REPLACE FUNCTION sp_update_reminder(p_reminder_id UUID,
    p_agent_id UUID,
    p_title VARCHAR(200) DEFAULT NULL,
    p_description TEXT DEFAULT NULL,
    p_reminder_date DATE DEFAULT NULL,
    p_reminder_time TIME DEFAULT NULL,
    p_priority VARCHAR(10) DEFAULT NULL,
    p_status VARCHAR(20) DEFAULT NULL,
    p_enable_sms BOOLEAN DEFAULT NULL,
    p_enable_whatsapp BOOLEAN DEFAULT NULL,
    p_enable_push_notification BOOLEAN DEFAULT NULL,
    p_advance_notice VARCHAR(20) DEFAULT NULL,
    p_custom_message TEXT DEFAULT NULL,
    p_auto_send BOOLEAN DEFAULT NULL,
    p_notes TEXT DEFAULT NULL)
RETURNS TABLE(rows_affected INTEGER) AS  $$
$
DECLARE
    v_affected_rows INTEGER
$$ LANGUAGE plpgsql;
BEGIN
    UPDATE reminders 
    SET 
        title = COALESCE(p_title, title),
        description = COALESCE(p_description, description),
        reminder_date = COALESCE(p_reminder_date, reminder_date),
        reminder_time = COALESCE(p_reminder_time, reminder_time),
        priority = COALESCE(p_priority, priority),
        status = COALESCE(p_status, status),
        enable_sms = COALESCE(p_enable_sms, enable_sms),
        enable_whatsapp = COALESCE(p_enable_whatsapp, enable_whatsapp),
        enable_push_notification = COALESCE(p_enable_push_notification, enable_push_notification),
        advance_notice = COALESCE(p_advance_notice, advance_notice),
        custom_message = COALESCE(p_custom_message, custom_message),
        auto_send = COALESCE(p_auto_send, auto_send),
        notes = COALESCE(p_notes, notes),
        modified_date = NOW(),
        completed_date = CASE WHEN p_status = 'Completed' THEN NOW() ELSE completed_date END
    WHERE reminder_id = p_reminder_id AND agent_id = p_agent_id;
    
    GET DIAGNOSTICS v_affected_rows = ROW_COUNT;
    
    RETURN QUERY SELECT v_affected_rows;
END;
$ LANGUAGE plpgsql;

-- Get Upcoming Reminders
CREATE OR REPLACE FUNCTION sp_get_upcoming_reminders(p_agent_id UUID,
    p_days_ahead INTEGER DEFAULT 7)
RETURNS TABLE(
    reminder_id UUID,
    client_id UUID,
    reminder_type VARCHAR(50),
    title VARCHAR(200),
    description TEXT,
    reminder_date DATE,
    reminder_time TIME,
    client_name VARCHAR(150),
    priority VARCHAR(10),
    status VARCHAR(20),
    notes TEXT,
    client_phone VARCHAR(20)
) AS $
 $
BEGIN
    RETURN QUERY
    SELECT 
        r.reminder_id,
        r.client_id,
        r.reminder_type,
        r.title,
        r.description,
        r.reminder_date,
        r.reminder_time,
        r.client_name,
        r.priority,
        r.status,
        r.notes,
        c.phone_number AS  $$
client_phone
    FROM reminders r
    LEFT JOIN clients c ON r.client_id = c.client_id
    WHERE 
        r.agent_id = p_agent_id 
        AND r.status = 'Active'
        AND r.reminder_date BETWEEN CURRENT_DATE AND (CURRENT_DATE + INTERVAL '1 day' * p_days_ahead)
    ORDER BY r.reminder_date ASC, r.reminder_time ASC
$$ LANGUAGE plpgsql;
END;
$ LANGUAGE plpgsql;

-- Get Completed Reminders
CREATE OR REPLACE FUNCTION sp_get_completed_reminders(p_agent_id UUID,
    p_start_date DATE DEFAULT NULL,
    p_end_date DATE DEFAULT NULL,
    p_page_size INTEGER DEFAULT 50,
    p_page_number INTEGER DEFAULT 1)
RETURNS TABLE(
    reminder_id UUID,
    client_id UUID,
    reminder_type VARCHAR(50),
    title VARCHAR(200),
    description TEXT,
    reminder_date DATE,
    reminder_time TIME,
    client_name VARCHAR(150),
    priority VARCHAR(10),
    status VARCHAR(20),
    completed_date TIMESTAMP,
    notes TEXT,
    client_phone VARCHAR(20)
) AS  $$
$
 $
DECLARE
    v_offset INTEGER
$$ LANGUAGE plpgsql;
BEGIN
    IF p_start_date IS NULL THEN
        p_start_date := CURRENT_DATE - INTERVAL '30 days';
    END IF;
    
    IF p_end_date IS NULL THEN
        p_end_date := CURRENT_DATE;
    END IF;
    
    v_offset := (p_page_number - 1) * p_page_size;
    
    RETURN QUERY
    SELECT 
        r.reminder_id,
        r.client_id,
        r.reminder_type,
        r.title,
        r.description,
        r.reminder_date,
        r.reminder_time,
        r.client_name,
        r.priority,
        r.status,
        r.completed_date,
        r.notes,
        c.phone_number AS client_phone
    FROM reminders r
    LEFT JOIN clients c ON r.client_id = c.client_id
    WHERE 
        r.agent_id = p_agent_id 
        AND r.status = 'Completed'
        AND r.completed_date BETWEEN p_start_date AND (p_end_date + INTERVAL '1 day')
    ORDER BY r.completed_date DESC
    LIMIT p_page_size OFFSET v_offset;
END;
$ LANGUAGE plpgsql;

-- ============================================
-- SEARCH FUNCTIONS
-- ============================================

-- Global Search
CREATE OR REPLACE FUNCTION sp_global_search(p_agent_id UUID,
    p_search_term VARCHAR(500))
RETURNS TABLE(
    entity_type VARCHAR(20),
    entity_id UUID,
    title VARCHAR(200),
    subtitle VARCHAR(200),
    detail1 VARCHAR(200),
    detail2 VARCHAR(200),
    status VARCHAR(50)
) AS $
BEGIN
    RETURN QUERY
    -- Search Clients
    SELECT 
        'Client'::VARCHAR(20) AS entity_type,
        c.client_id AS entity_id,
        (c.first_name || ' ' || c.surname)::VARCHAR(200) AS title,
        c.email::VARCHAR(200) AS subtitle,
        c.phone_number::VARCHAR(200) AS detail1,
        c.address::VARCHAR(200) AS detail2,
        CASE WHEN c.is_client = true THEN 'Client' ELSE 'Prospect' END::VARCHAR(50) AS status
    FROM clients c
    WHERE c.agent_id = p_agent_id 
        AND c.is_active = true
        AND (
            c.first_name ILIKE '%' || p_search_term || '%' OR
            c.surname ILIKE '%' || p_search_term || '%' OR
            c.last_name ILIKE '%' || p_search_term || '%' OR
            c.email ILIKE '%' || p_search_term || '%' OR
            c.phone_number ILIKE '%' || p_search_term || '%' OR
            c.national_id ILIKE '%' || p_search_term || '%'
        )
    
    UNION ALL
    
    -- Search Appointments
    SELECT 
        'Appointment'::VARCHAR(20) AS entity_type,
        a.appointment_id AS entity_id,
        a.title::VARCHAR(200),
        a.client_name::VARCHAR(200) AS subtitle,
        a.appointment_date::VARCHAR(200) AS detail1,
        a.location::VARCHAR(200) AS detail2,
        a.status::VARCHAR(50)
    FROM appointments a
    INNER JOIN clients c ON a.client_id = c.client_id
    WHERE c.agent_id = p_agent_id 
        AND a.is_active = true
        AND (
            a.title ILIKE '%' || p_search_term || '%' OR
            a.client_name ILIKE '%' || p_search_term || '%' OR
            a.description ILIKE '%' || p_search_term || '%' OR
            a.location ILIKE '%' || p_search_term || '%'
        )
    
    UNION ALL
    
    -- Search Policies
    SELECT 
        'Policy'::VARCHAR(20) AS entity_type,
        pc.policy_catalog_id AS entity_id,
        pc.policy_name::VARCHAR(200) AS title,
        pc.policy_type::VARCHAR(200) AS subtitle,
        pc.company_name::VARCHAR(200) AS detail1,
        ''::VARCHAR(200) AS detail2,
        CASE WHEN pc.is_active = true THEN 'Active' ELSE 'Inactive' END::VARCHAR(50) AS status
    FROM policy_catalog pc
    WHERE pc.agent_id = p_agent_id
        AND (
            pc.policy_name ILIKE '%' || p_search_term || '%' OR
            pc.policy_type ILIKE '%' || p_search_term || '%' OR
            pc.company_name ILIKE '%' || p_search_term || '%' OR
            pc.notes ILIKE '%' || p_search_term || '%'
        )
    
    UNION ALL
    
    -- Search Reminders
    SELECT 
        'Reminder'::VARCHAR(20) AS entity_type,
        r.reminder_id AS entity_id,
        r.title::VARCHAR(200),
        r.client_name::VARCHAR(200) AS subtitle,
        r.reminder_date::VARCHAR(200) AS detail1,
        r.reminder_type::VARCHAR(200) AS  $$
detail2,
        r.status::VARCHAR(50)
    FROM reminders r
    WHERE r.agent_id = p_agent_id
        AND (
            r.title ILIKE '%' || p_search_term || '%' OR
            r.client_name ILIKE '%' || p_search_term || '%' OR
            r.description ILIKE '%' || p_search_term || '%' OR
            r.reminder_type ILIKE '%' || p_search_term || '%'
        )
    ORDER BY entity_type, title
$$ LANGUAGE plpgsql;
END;
$ LANGUAGE plpgsql;

-- Search Clients
CREATE OR REPLACE FUNCTION sp_search_clients(p_agent_id UUID,
    p_search_term VARCHAR(500))
RETURNS TABLE(
    client_id UUID,
    first_name VARCHAR(50),
    surname VARCHAR(50),
    last_name VARCHAR(50),
    phone_number VARCHAR(20),
    email VARCHAR(100),
    address TEXT,
    national_id VARCHAR(20),
    date_of_birth DATE,
    is_client BOOLEAN,
    insurance_type VARCHAR(50),
    notes TEXT,
    created_date TIMESTAMP,
    modified_date TIMESTAMP,
    client_type VARCHAR(20)
) AS $
BEGIN
    RETURN QUERY
    SELECT 
        c.client_id,
        c.first_name,
        c.surname,
        c.last_name,
        c.phone_number,
        c.email,
        c.address,
        c.national_id,
        c.date_of_birth,
        c.is_client,
        c.insurance_type,
        c.notes,
        c.created_date,
        c.modified_date,
        CASE WHEN c.is_client = true THEN 'Client' ELSE 'Prospect' END::VARCHAR(20) AS  $$
client_type
    FROM clients c
    WHERE c.agent_id = p_agent_id 
        AND c.is_active = true
        AND (
            c.first_name ILIKE '%' || p_search_term || '%' OR
            c.surname ILIKE '%' || p_search_term || '%' OR
            c.last_name ILIKE '%' || p_search_term || '%' OR
            c.email ILIKE '%' || p_search_term || '%' OR
            c.phone_number ILIKE '%' || p_search_term || '%' OR
            c.national_id ILIKE '%' || p_search_term || '%' OR
            c.address ILIKE '%' || p_search_term || '%' OR
            c.insurance_type ILIKE '%' || p_search_term || '%'
        )
    ORDER BY c.is_client DESC, c.first_name, c.surname
$$ LANGUAGE plpgsql;
END;
$ LANGUAGE plpgsql;

-- Search Appointments
CREATE OR REPLACE FUNCTION sp_search_appointments(p_agent_id UUID,
    p_search_term VARCHAR(500))
RETURNS TABLE(
    appointment_id UUID,
    client_id UUID,
    client_name VARCHAR(150),
    client_phone VARCHAR(20),
    title VARCHAR(200),
    description TEXT,
    appointment_date DATE,
    start_time TIME,
    end_time TIME,
    location VARCHAR(200),
    type VARCHAR(50),
    status VARCHAR(20),
    priority VARCHAR(10),
    notes TEXT,
    created_date TIMESTAMP
) AS  $$
$
BEGIN
    RETURN QUERY
    SELECT 
        a.appointment_id,
        a.client_id,
        a.client_name,
        a.client_phone,
        a.title,
        a.description,
        a.appointment_date,
        a.start_time,
        a.end_time,
        a.location,
        a.type,
        a.status,
        a.priority,
        a.notes,
        a.created_date
    FROM appointments a
    INNER JOIN clients c ON a.client_id = c.client_id
    WHERE c.agent_id = p_agent_id 
        AND a.is_active = true
        AND (
            a.title ILIKE '%' || p_search_term || '%' OR
            a.client_name ILIKE '%' || p_search_term || '%' OR
            a.description ILIKE '%' || p_search_term || '%' OR
            a.location ILIKE '%' || p_search_term || '%' OR
            a.type ILIKE '%' || p_search_term || '%'
        )
    ORDER BY a.appointment_date DESC, a.start_time
$$ LANGUAGE plpgsql;
END;
$ LANGUAGE plpgsql;


























































-- ============================================
-- Search Functions
-- ============================================

-- Search Policies
CREATE OR REPLACE FUNCTION sp_search_policies(p_agent_id UUID,
    p_search_term VARCHAR(500))
RETURNS TABLE(
    policy_catalog_id UUID,
    policy_name VARCHAR(200),
    policy_type VARCHAR(50),
    company_id UUID,
    company_name VARCHAR(200),
    notes TEXT,
    is_active BOOLEAN,
    created_date TIMESTAMP,
    modified_date TIMESTAMP
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        pc.policy_catalog_id,
        pc.policy_name,
        pc.policy_type,
        pc.company_id,
        pc.company_name,
        pc.notes,
        pc.is_active,
        pc.created_date,
        pc.modified_date
    FROM policy_catalog pc
    WHERE pc.agent_id = p_agent_id
        AND (
            pc.policy_name ILIKE '%' || p_search_term || '%' OR
            pc.policy_type ILIKE '%' || p_search_term || '%' OR
            pc.company_name ILIKE '%' || p_search_term || '%' OR
            pc.notes ILIKE '%' || p_search_term || '%'
        )
    ORDER BY pc.policy_name;
END;
$ LANGUAGE plpgsql;

-- Search Reminders
CREATE OR REPLACE FUNCTION sp_search_reminders(p_agent_id UUID,
    p_search_term VARCHAR(500))
RETURNS TABLE(
    reminder_id UUID,
    client_id UUID,
    appointment_id UUID,
    reminder_type VARCHAR(50),
    title VARCHAR(200),
    description TEXT,
    reminder_date DATE,
    reminder_time TIME,
    client_name VARCHAR(200),
    priority VARCHAR(20),
    status VARCHAR(20),
    notes TEXT,
    created_date TIMESTAMP
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        r.reminder_id,
        r.client_id,
        r.appointment_id,
        r.reminder_type,
        r.title,
        r.description,
        r.reminder_date,
        r.reminder_time,
        r.client_name,
        r.priority,
        r.status,
        r.notes,
        r.created_date
    FROM reminders r
    WHERE r.agent_id = p_agent_id
        AND (
            r.title ILIKE '%' || p_search_term || '%' OR
            r.client_name ILIKE '%' || p_search_term || '%' OR
            r.description ILIKE '%' || p_search_term || '%' OR
            r.reminder_type ILIKE '%' || p_search_term || '%' OR
            r.notes ILIKE '%' || p_search_term || '%'
        )
    ORDER BY r.reminder_date DESC;
END;
$ LANGUAGE plpgsql;

-- Save Search History
CREATE OR REPLACE FUNCTION sp_save_search_history(p_agent_id UUID,
    p_search_term VARCHAR(500))
RETURNS VOID AS $$
BEGIN
    -- Create search history table if it doesn't exist
    CREATE TABLE IF NOT EXISTS search_history (
        history_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
        agent_id UUID NOT NULL,
        search_term VARCHAR(500) NOT NULL,
        search_count INTEGER DEFAULT 1,
        last_searched TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (agent_id) REFERENCES agent(agent_id) ON DELETE CASCADE
    );
    
    -- Insert or update search history
    INSERT INTO search_history (agent_id, search_term, search_count, last_searched)
    VALUES (p_agent_id, p_search_term, 1, CURRENT_TIMESTAMP)
    ON CONFLICT (agent_id, search_term) 
    DO UPDATE SET 
        search_count = search_history.search_count + 1,
        last_searched = CURRENT_TIMESTAMP;
END;
$ LANGUAGE plpgsql;

-- Get Search History
CREATE OR REPLACE FUNCTION sp_get_search_history(p_agent_id UUID,
    p_max_results INTEGER DEFAULT 20)
RETURNS TABLE(
    search_term VARCHAR(500),
    search_count INTEGER,
    last_searched TIMESTAMP
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        sh.search_term,
        sh.search_count,
        sh.last_searched
    FROM search_history sh
    WHERE sh.agent_id = p_agent_id
    ORDER BY sh.last_searched DESC
    LIMIT p_max_results;
END;
$ LANGUAGE plpgsql;

-- ============================================
-- Settings Management Functions
-- ============================================

-- Get Application Settings
CREATE OR REPLACE FUNCTION sp_get_application_settings()
RETURNS TABLE(
    setting_key VARCHAR(100),
    setting_value TEXT,
    description VARCHAR(200),
    data_type VARCHAR(50),
    modified_date TIMESTAMP
) AS $
BEGIN
    RETURN QUERY
    SELECT 
        app_s.setting_key,
        app_s.setting_value,
        app_s.description,
        app_s.data_type,
        app_s.modified_date
    FROM application_settings app_s
    WHERE app_s.is_active = true
    ORDER BY app_s.setting_key;
END;
$ LANGUAGE plpgsql;

-- Update Application Setting
CREATE OR REPLACE FUNCTION sp_update_application_setting(p_setting_key VARCHAR(100),
    p_setting_value TEXT,
    p_description VARCHAR(200) DEFAULT NULL)
RETURNS VOID AS $$
BEGIN
    INSERT INTO application_settings (setting_key, setting_value, description, modified_date)
    VALUES (p_setting_key, p_setting_value, p_description, CURRENT_TIMESTAMP)
    ON CONFLICT (setting_key)
    DO UPDATE SET 
        setting_value = p_setting_value,
        description = COALESCE(p_description, application_settings.description),
        modified_date = CURRENT_TIMESTAMP;
END;
$ LANGUAGE plpgsql;

-- Get Agent Notification Preferences
CREATE OR REPLACE FUNCTION sp_get_notification_preferences(p_agent_id UUID)
RETURNS TABLE(
    preference_id UUID,
    notification_type VARCHAR(50),
    email_enabled BOOLEAN,
    sms_enabled BOOLEAN,
    whatsapp_enabled BOOLEAN,
    push_enabled BOOLEAN,
    sound_enabled BOOLEAN,
    advance_notice_minutes INTEGER,
    modified_date TIMESTAMP
) AS $
BEGIN
    RETURN QUERY
    SELECT 
        anp.preference_id,
        anp.notification_type,
        anp.email_enabled,
        anp.sms_enabled,
        anp.whatsapp_enabled,
        anp.push_enabled,
        anp.sound_enabled,
        anp.advance_notice_minutes,
        anp.modified_date
    FROM agent_notification_preferences anp
    WHERE anp.agent_id = p_agent_id
    ORDER BY anp.notification_type;
END;
$ LANGUAGE plpgsql;

-- Update Notification Preferences
CREATE OR REPLACE FUNCTION sp_update_notification_preferences(p_agent_id UUID,
    p_notification_type VARCHAR(50),
    p_email_enabled BOOLEAN DEFAULT NULL,
    p_sms_enabled BOOLEAN DEFAULT NULL,
    p_whatsapp_enabled BOOLEAN DEFAULT NULL,
    p_push_enabled BOOLEAN DEFAULT NULL,
    p_sound_enabled BOOLEAN DEFAULT NULL,
    p_advance_notice_minutes INTEGER DEFAULT NULL)
RETURNS VOID AS $$
BEGIN
    INSERT INTO agent_notification_preferences (
        agent_id, notification_type, email_enabled, sms_enabled, whatsapp_enabled,
        push_enabled, sound_enabled, advance_notice_minutes, modified_date
    )
    VALUES (
        p_agent_id, p_notification_type, COALESCE(p_email_enabled, true), 
        COALESCE(p_sms_enabled, true), COALESCE(p_whatsapp_enabled, true),
        COALESCE(p_push_enabled, true), COALESCE(p_sound_enabled, true), 
        COALESCE(p_advance_notice_minutes, 60), CURRENT_TIMESTAMP
    )
    ON CONFLICT (agent_id, notification_type)
    DO UPDATE SET 
        email_enabled = COALESCE(p_email_enabled, agent_notification_preferences.email_enabled),
        sms_enabled = COALESCE(p_sms_enabled, agent_notification_preferences.sms_enabled),
        whatsapp_enabled = COALESCE(p_whatsapp_enabled, agent_notification_preferences.whatsapp_enabled),
        push_enabled = COALESCE(p_push_enabled, agent_notification_preferences.push_enabled),
        sound_enabled = COALESCE(p_sound_enabled, agent_notification_preferences.sound_enabled),
        advance_notice_minutes = COALESCE(p_advance_notice_minutes, agent_notification_preferences.advance_notice_minutes),
        modified_date = CURRENT_TIMESTAMP;
END;
$ LANGUAGE plpgsql;

-- Get System Preferences
CREATE OR REPLACE FUNCTION sp_get_system_preferences(p_agent_id UUID,
    p_preference_key VARCHAR(100) DEFAULT NULL)
RETURNS TABLE(
    preference_key VARCHAR(100),
    preference_value TEXT,
    modified_date TIMESTAMP
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        sp.preference_key,
        sp.preference_value,
        sp.modified_date
    FROM system_preferences sp
    WHERE 
        sp.agent_id = p_agent_id
        AND (p_preference_key IS NULL OR sp.preference_key = p_preference_key)
    ORDER BY sp.preference_key;
END;
$ LANGUAGE plpgsql;

-- Update System Preference
CREATE OR REPLACE FUNCTION sp_update_system_preference(p_agent_id UUID,
    p_preference_key VARCHAR(100),
    p_preference_value TEXT)
RETURNS VOID AS $$
BEGIN
    INSERT INTO system_preferences (agent_id, preference_key, preference_value, modified_date)
    VALUES (p_agent_id, p_preference_key, p_preference_value, CURRENT_TIMESTAMP)
    ON CONFLICT (agent_id, preference_key)
    DO UPDATE SET 
        preference_value = p_preference_value,
        modified_date = CURRENT_TIMESTAMP;
END;
$ LANGUAGE plpgsql;

-- Get Backup Settings
CREATE OR REPLACE FUNCTION sp_get_backup_settings(p_agent_id UUID)
RETURNS TABLE(
    backup_frequency VARCHAR(20),
    last_backup_date TIMESTAMP,
    backup_location VARCHAR(500),
    auto_backup_enabled BOOLEAN,
    include_client_data BOOLEAN,
    include_appointments BOOLEAN,
    include_reminders BOOLEAN,
    include_settings BOOLEAN,
    modified_date TIMESTAMP
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        bs.backup_frequency,
        bs.last_backup_date,
        bs.backup_location,
        bs.auto_backup_enabled,
        bs.include_client_data,
        bs.include_appointments,
        bs.include_reminders,
        bs.include_settings,
        bs.modified_date
    FROM backup_settings bs
    WHERE bs.agent_id = p_agent_id;
END;
$ LANGUAGE plpgsql;

-- Update Backup Settings
CREATE OR REPLACE FUNCTION sp_update_backup_settings(p_agent_id UUID,
    p_backup_frequency VARCHAR(20) DEFAULT NULL,
    p_backup_location VARCHAR(500) DEFAULT NULL,
    p_auto_backup_enabled BOOLEAN DEFAULT NULL,
    p_include_client_data BOOLEAN DEFAULT NULL,
    p_include_appointments BOOLEAN DEFAULT NULL,
    p_include_reminders BOOLEAN DEFAULT NULL,
    p_include_settings BOOLEAN DEFAULT NULL,
    p_last_backup_date TIMESTAMP DEFAULT NULL)
RETURNS VOID AS $$
BEGIN
    INSERT INTO backup_settings (
        agent_id, backup_frequency, backup_location, auto_backup_enabled,
        include_client_data, include_appointments, include_reminders, include_settings,
        last_backup_date, modified_date
    )
    VALUES (
        p_agent_id, COALESCE(p_backup_frequency, 'Weekly'), p_backup_location, 
        COALESCE(p_auto_backup_enabled, true), COALESCE(p_include_client_data, true), 
        COALESCE(p_include_appointments, true), COALESCE(p_include_reminders, true), 
        COALESCE(p_include_settings, true), p_last_backup_date, CURRENT_TIMESTAMP
    )
    ON CONFLICT (agent_id)
    DO UPDATE SET 
        backup_frequency = COALESCE(p_backup_frequency, backup_settings.backup_frequency),
        backup_location = COALESCE(p_backup_location, backup_settings.backup_location),
        auto_backup_enabled = COALESCE(p_auto_backup_enabled, backup_settings.auto_backup_enabled),
        include_client_data = COALESCE(p_include_client_data, backup_settings.include_client_data),
        include_appointments = COALESCE(p_include_appointments, backup_settings.include_appointments),
        include_reminders = COALESCE(p_include_reminders, backup_settings.include_reminders),
        include_settings = COALESCE(p_include_settings, backup_settings.include_settings),
        last_backup_date = COALESCE(p_last_backup_date, backup_settings.last_backup_date),
        modified_date = CURRENT_TIMESTAMP;
END;
$ LANGUAGE plpgsql;

-- Create Message Template
CREATE OR REPLACE FUNCTION sp_create_message_template(p_agent_id UUID,
    p_template_name VARCHAR(100),
    p_message_type VARCHAR(50),
    p_template TEXT,
    p_is_default BOOLEAN DEFAULT false)
RETURNS UUID AS $$
DECLARE
    v_template_id UUID;
BEGIN
    v_template_id := gen_random_uuid();
    
    INSERT INTO message_templates (
        template_id, agent_id, template_name, message_type, template, is_default, created_date
    )
    VALUES (
        v_template_id, p_agent_id, p_template_name, p_message_type, p_template, p_is_default, CURRENT_TIMESTAMP
    );
    
    RETURN v_template_id;
END;
$ LANGUAGE plpgsql;

-- Get Message Templates
CREATE OR REPLACE FUNCTION sp_get_message_templates(p_agent_id UUID,
    p_message_type VARCHAR(50) DEFAULT NULL)
RETURNS TABLE(
    template_id UUID,
    template_name VARCHAR(100),
    message_type VARCHAR(50),
    template TEXT,
    is_default BOOLEAN,
    usage_count INTEGER,
    created_date TIMESTAMP,
    modified_date TIMESTAMP
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        mt.template_id,
        mt.template_name,
        mt.message_type,
        mt.template,
        mt.is_default,
        mt.usage_count,
        mt.created_date,
        mt.modified_date
    FROM message_templates mt
    WHERE 
        mt.agent_id = p_agent_id
        AND (p_message_type IS NULL OR mt.message_type = p_message_type)
    ORDER BY mt.message_type, mt.is_default DESC, mt.template_name;
END;
$ LANGUAGE plpgsql;

-- Update Message Template
CREATE OR REPLACE FUNCTION sp_update_message_template(p_template_id UUID,
    p_agent_id UUID,
    p_template_name VARCHAR(100),
    p_template TEXT,
    p_is_default BOOLEAN DEFAULT NULL)
RETURNS INTEGER AS $$
DECLARE
    rows_affected INTEGER;
BEGIN
    UPDATE message_templates 
    SET 
        template_name = p_template_name,
        template = p_template,
        is_default = COALESCE(p_is_default, is_default),
        modified_date = CURRENT_TIMESTAMP
    WHERE template_id = p_template_id AND agent_id = p_agent_id;
    
    GET DIAGNOSTICS rows_affected = ROW_COUNT;
    RETURN rows_affected;
END;
$ LANGUAGE plpgsql;

-- Delete Message Template
CREATE OR REPLACE FUNCTION sp_delete_message_template(p_template_id UUID,
    p_agent_id UUID)
RETURNS INTEGER AS $
DECLARE
    rows_affected INTEGER;
BEGIN
    DELETE FROM message_templates 
    WHERE template_id = p_template_id AND agent_id = p_agent_id;
    
    GET DIAGNOSTICS rows_affected = ROW_COUNT;
    RETURN rows_affected;
END;
$ LANGUAGE plpgsql;

-- Increment Template Usage
CREATE OR REPLACE FUNCTION sp_increment_template_usage(p_template_id UUID)
RETURNS VOID AS $
BEGIN
    UPDATE message_templates 
    SET usage_count = usage_count + 1
    WHERE template_id = p_template_id;
END;
$ LANGUAGE plpgsql;

-- Export Agent Data
CREATE OR REPLACE FUNCTION sp_export_agent_data(p_agent_id UUID,
    p_include_clients BOOLEAN DEFAULT true,
    p_include_appointments BOOLEAN DEFAULT true,
    p_include_reminders BOOLEAN DEFAULT true,
    p_include_policies BOOLEAN DEFAULT true,
    p_include_settings BOOLEAN DEFAULT true)
RETURNS TABLE(
    data_type VARCHAR(50),
    data_json JSONB
) AS $
BEGIN
    -- Agent Profile
    RETURN QUERY
    SELECT 'Agent'::VARCHAR(50), to_jsonb(a.*) 
    FROM agent a 
    WHERE a.agent_id = p_agent_id;
    
    -- Agent Settings
    IF p_include_settings THEN
        RETURN QUERY
        SELECT 'AgentSettings'::VARCHAR(50), to_jsonb(ags.*) 
        FROM agent_settings ags 
        WHERE ags.agent_id = p_agent_id;
        
        RETURN QUERY
        SELECT 'ReminderSettings'::VARCHAR(50), to_jsonb(rs.*) 
        FROM reminder_settings rs 
        WHERE rs.agent_id = p_agent_id;
        
        RETURN QUERY
        SELECT 'NotificationPreferences'::VARCHAR(50), to_jsonb(anp.*) 
        FROM agent_notification_preferences anp 
        WHERE anp.agent_id = p_agent_id;
        
        RETURN QUERY
        SELECT 'SystemPreferences'::VARCHAR(50), to_jsonb(sp.*) 
        FROM system_preferences sp 
        WHERE sp.agent_id = p_agent_id;
        
        RETURN QUERY
        SELECT 'BackupSettings'::VARCHAR(50), to_jsonb(bs.*) 
        FROM backup_settings bs 
        WHERE bs.agent_id = p_agent_id;
        
        RETURN QUERY
        SELECT 'MessageTemplates'::VARCHAR(50), to_jsonb(mt.*) 
        FROM message_templates mt 
        WHERE mt.agent_id = p_agent_id;
    END IF;
    
    -- Clients
    IF p_include_clients THEN
        RETURN QUERY
        SELECT 'Clients'::VARCHAR(50), to_jsonb(c.*) 
        FROM clients c 
        WHERE c.agent_id = p_agent_id AND c.is_active = true;
    END IF;
    
    -- Appointments
    IF p_include_appointments THEN
        RETURN QUERY
        SELECT 'Appointments'::VARCHAR(50), to_jsonb(a.*) 
        FROM appointments a 
        INNER JOIN clients c ON a.client_id = c.client_id
        WHERE c.agent_id = p_agent_id AND a.is_active = true;
    END IF;
    
    -- Reminders
    IF p_include_reminders THEN
        RETURN QUERY
        SELECT 'Reminders'::VARCHAR(50), to_jsonb(r.*) 
        FROM reminders r 
        WHERE r.agent_id = p_agent_id;
        
        RETURN QUERY
        SELECT 'AutomatedMessages'::VARCHAR(50), to_jsonb(am.*) 
        FROM automated_messages am 
        WHERE am.agent_id = p_agent_id;
    END IF;
    
    -- Policies
    IF p_include_policies THEN
        RETURN QUERY
        SELECT 'PolicyCatalog'::VARCHAR(50), to_jsonb(pc.*) 
        FROM policy_catalog pc 
        WHERE pc.agent_id = p_agent_id AND pc.is_active = true;
        
        RETURN QUERY
        SELECT 'ClientPolicies'::VARCHAR(50), to_jsonb(cp.*) 
        FROM client_policies cp
        INNER JOIN clients c ON cp.client_id = c.client_id
        WHERE c.agent_id = p_agent_id AND cp.is_active = true;
    END IF;
END;
$ LANGUAGE plpgsql;

-- Validate Import Data
CREATE OR REPLACE FUNCTION sp_validate_import_data(p_agent_id UUID,
    p_data_type VARCHAR(50),
    p_json_data JSONB)
RETURNS TABLE(
    is_valid BOOLEAN,
    validation_message VARCHAR(500)
) AS $$
DECLARE
    v_is_valid BOOLEAN := true;
    v_validation_message VARCHAR(500) := 'Data validation passed';
BEGIN
    -- Basic validation logic
    IF p_json_data IS NULL THEN
        v_is_valid := false;
        v_validation_message := 'No data provided for import';
    END IF;
    
    RETURN QUERY SELECT v_is_valid, v_validation_message;
END;
$ LANGUAGE plpgsql;

-- Get Agent Settings
CREATE OR REPLACE FUNCTION sp_get_agent_settings(p_agent_id UUID)
RETURNS TABLE(
    agent_id UUID,
    dark_mode BOOLEAN,
    email_notifications BOOLEAN,
    sms_notifications BOOLEAN,
    whatsapp_notifications BOOLEAN,
    push_notifications BOOLEAN,
    sound_enabled BOOLEAN,
    created_date TIMESTAMP,
    modified_date TIMESTAMP
) AS $
DECLARE
    settings_exist INTEGER;
BEGIN
    SELECT COUNT(*) INTO settings_exist 
    FROM agent_settings 
    WHERE agent_settings.agent_id = p_agent_id;
    
    -- If no settings exist, create default ones
    IF settings_exist = 0 THEN
        INSERT INTO agent_settings (agent_id, created_date)
        VALUES (p_agent_id, CURRENT_TIMESTAMP);
    END IF;
    
    RETURN QUERY
    SELECT 
        ags.agent_id,
        ags.dark_mode,
        ags.email_notifications,
        ags.sms_notifications,
        ags.whatsapp_notifications,
        ags.push_notifications,
        ags.sound_enabled,
        ags.created_date,
        ags.modified_date
    FROM agent_settings ags
    WHERE ags.agent_id = p_agent_id;
END;
$ LANGUAGE plpgsql;

-- Update Agent Settings
CREATE OR REPLACE FUNCTION sp_update_agent_settings(p_agent_id UUID,
    p_dark_mode BOOLEAN DEFAULT NULL,
    p_email_notifications BOOLEAN DEFAULT NULL,
    p_sms_notifications BOOLEAN DEFAULT NULL,
    p_whatsapp_notifications BOOLEAN DEFAULT NULL,
    p_push_notifications BOOLEAN DEFAULT NULL,
    p_sound_enabled BOOLEAN DEFAULT NULL)
RETURNS INTEGER AS $
DECLARE
    rows_affected INTEGER;
BEGIN
    INSERT INTO agent_settings (
        agent_id, dark_mode, email_notifications, sms_notifications, 
        whatsapp_notifications, push_notifications, sound_enabled, created_date
    )
    VALUES (
        p_agent_id, COALESCE(p_dark_mode, false), COALESCE(p_email_notifications, true), 
        COALESCE(p_sms_notifications, true), COALESCE(p_whatsapp_notifications, true), 
        COALESCE(p_push_notifications, true), COALESCE(p_sound_enabled, true), CURRENT_TIMESTAMP
    )
    ON CONFLICT (agent_id)
    DO UPDATE SET 
        dark_mode = COALESCE(p_dark_mode, agent_settings.dark_mode),
        email_notifications = COALESCE(p_email_notifications, agent_settings.email_notifications),
        sms_notifications = COALESCE(p_sms_notifications, agent_settings.sms_notifications),
        whatsapp_notifications = COALESCE(p_whatsapp_notifications, agent_settings.whatsapp_notifications),
        push_notifications = COALESCE(p_push_notifications, agent_settings.push_notifications),
        sound_enabled = COALESCE(p_sound_enabled, agent_settings.sound_enabled),
        modified_date = CURRENT_TIMESTAMP;
    
    GET DIAGNOSTICS rows_affected = ROW_COUNT;
    RETURN rows_affected;
END;
$ LANGUAGE plpgsql;

-- Toggle Dark Mode
CREATE OR REPLACE FUNCTION sp_toggle_dark_mode(p_agent_id UUID)
RETURNS BOOLEAN AS $
DECLARE
    current_mode BOOLEAN;
    new_mode BOOLEAN;
BEGIN
    SELECT dark_mode INTO current_mode 
    FROM agent_settings 
    WHERE agent_id = p_agent_id;
    
    IF current_mode IS NULL THEN
        -- Create settings if they don't exist
        INSERT INTO agent_settings (agent_id, dark_mode, created_date) 
        VALUES (p_agent_id, true, CURRENT_TIMESTAMP);
        RETURN true;
    ELSE
        new_mode := NOT current_mode;
        UPDATE agent_settings 
        SET 
            dark_mode = new_mode,
            modified_date = CURRENT_TIMESTAMP
        WHERE agent_id = p_agent_id;
        
        RETURN new_mode;
    END IF;
END;
$ LANGUAGE plpgsql;

-- ============================================
-- Validation Service Functions
-- ============================================

-- Validate Email
CREATE OR REPLACE FUNCTION sp_validate_email(p_email VARCHAR(100))
RETURNS TABLE(
    is_valid BOOLEAN,
    validation_message VARCHAR(200)
) AS $$
DECLARE
    v_is_valid BOOLEAN := false;
    v_validation_message VARCHAR(200) := '';
BEGIN
    IF p_email IS NULL OR p_email = '' THEN
        v_validation_message := 'Email cannot be empty';
    ELSIF p_email !~ '^[A-Za-z0-9._%-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,4}$' THEN
        v_validation_message := 'Invalid email format';
    ELSIF LENGTH(p_email) > 100 THEN
        v_validation_message := 'Email too long (max 100 characters)';
    ELSE
        v_is_valid := true;
        v_validation_message := 'Valid email';
    END IF;
    
    RETURN QUERY SELECT v_is_valid, v_validation_message;
END;
$ LANGUAGE plpgsql;























































-- ============================================
-- Validation Service Functions (PostgreSQL)
-- ============================================

-- Validate National ID (Kenya format)
CREATE OR REPLACE FUNCTION sp_validate_national_id(p_national_id VARCHAR(20))
RETURNS TABLE(
    is_valid BOOLEAN,
    validation_message TEXT,
    formatted_national_id VARCHAR(20)
) 
LANGUAGE plpgsql
AS $$
DECLARE
    v_national_id VARCHAR(20);
    v_is_valid BOOLEAN := FALSE;
    v_validation_message TEXT := '';
BEGIN
    -- Remove spaces and convert to upper case
    v_national_id := UPPER(REPLACE(COALESCE(p_national_id, ''), ' ', ''));
    
    IF v_national_id IS NULL OR v_national_id = '' THEN
        v_validation_message := 'National ID cannot be empty';
    ELSIF LENGTH(v_national_id) < 7 OR LENGTH(v_national_id) > 8 THEN
        v_validation_message := 'National ID must be 7-8 characters long';
    ELSIF v_national_id !~ '^[0-9]{7,8}$' THEN
        v_validation_message := 'National ID must contain only numbers';
    ELSE
        v_is_valid := TRUE;
        v_validation_message := 'Valid National ID';
    END IF;
    
    RETURN QUERY SELECT v_is_valid, v_validation_message, v_national_id;
END;
$;

-- Validate Date
CREATE OR REPLACE FUNCTION sp_validate_date(p_date_value DATE,
    p_min_date DATE DEFAULT '1900-01-01',
    p_max_date DATE DEFAULT '2100-12-31')
RETURNS TABLE(
    is_valid BOOLEAN,
    validation_message TEXT
) 
LANGUAGE plpgsql
AS $
DECLARE
    v_is_valid BOOLEAN := FALSE;
    v_validation_message TEXT := '';
BEGIN
    IF p_date_value IS NULL THEN
        v_validation_message := 'Date cannot be null';
    ELSIF p_date_value < p_min_date THEN
        v_validation_message := 'Date is too early (minimum: ' || p_min_date::TEXT || ')';
    ELSIF p_date_value > p_max_date THEN
        v_validation_message := 'Date is too late (maximum: ' || p_max_date::TEXT || ')';
    ELSE
        v_is_valid := TRUE;
        v_validation_message := 'Valid date';
    END IF;
    
    RETURN QUERY SELECT v_is_valid, v_validation_message;
END;
$;

-- Validate Time Range
CREATE OR REPLACE FUNCTION sp_validate_time_range(p_start_time TIME,
    p_end_time TIME)
RETURNS TABLE(
    is_valid BOOLEAN,
    validation_message TEXT
) 
LANGUAGE plpgsql
AS $
DECLARE
    v_is_valid BOOLEAN := FALSE;
    v_validation_message TEXT := '';
    v_duration INTERVAL;
BEGIN
    IF p_start_time IS NULL OR p_end_time IS NULL THEN
        v_validation_message := 'Start time and end time cannot be null';
    ELSIF p_start_time >= p_end_time THEN
        v_validation_message := 'Start time must be before end time';
    ELSE
        v_duration := p_end_time - p_start_time;
        
        IF v_duration < INTERVAL '15 minutes' THEN
            v_validation_message := 'Time range must be at least 15 minutes';
        ELSIF v_duration > INTERVAL '12 hours' THEN
            v_validation_message := 'Time range cannot exceed 12 hours';
        ELSE
            v_is_valid := TRUE;
            v_validation_message := 'Valid time range';
        END IF;
    END IF;
    
    RETURN QUERY SELECT v_is_valid, v_validation_message;
END;
$;

-- Check Data Integrity
CREATE OR REPLACE FUNCTION sp_check_data_integrity(p_agent_id UUID)
RETURNS TABLE(
    issue_type TEXT,
    issue_count BIGINT,
    description TEXT
) 
LANGUAGE plpgsql
AS $
BEGIN
    RETURN QUERY
    SELECT 
        'OrphanedAppointments'::TEXT,
        COUNT(*)::BIGINT,
        'Appointments without valid clients'::TEXT
    FROM appointments a
    LEFT JOIN clients c ON a.client_id = c.client_id
    WHERE c.client_id IS NULL
    
    UNION ALL
    
    SELECT 
        'OrphanedPolicies'::TEXT,
        COUNT(*)::BIGINT,
        'Client policies without valid clients'::TEXT
    FROM client_policies cp
    LEFT JOIN clients c ON cp.client_id = c.client_id
    WHERE c.client_id IS NULL
    
    UNION ALL
    
    SELECT 
        'OrphanedReminders'::TEXT,
        COUNT(*)::BIGINT,
        'Reminders without valid clients'::TEXT
    FROM reminders r
    LEFT JOIN clients c ON r.client_id = c.client_id
    WHERE r.client_id IS NOT NULL AND c.client_id IS NULL
    
    UNION ALL
    
    SELECT 
        'DuplicateEmails'::TEXT,
        (COUNT(*) - COUNT(DISTINCT email))::BIGINT,
        'Clients with duplicate email addresses'::TEXT
    FROM clients
    WHERE agent_id = p_agent_id AND is_active = TRUE
    
    UNION ALL
    
    SELECT 
        'DuplicatePhones'::TEXT,
        (COUNT(*) - COUNT(DISTINCT phone_number))::BIGINT,
        'Clients with duplicate phone numbers'::TEXT
    FROM clients
    WHERE agent_id = p_agent_id AND is_active = TRUE
    
    UNION ALL
    
    SELECT 
        'DuplicateNationalIds'::TEXT,
        (COUNT(*) - COUNT(DISTINCT national_id))::BIGINT,
        'Clients with duplicate national IDs'::TEXT
    FROM clients
    WHERE agent_id = p_agent_id AND is_active = TRUE
    
    UNION ALL
    
    SELECT 
        'FutureAppointments'::TEXT,
        COUNT(*)::BIGINT,
        'Appointments scheduled more than 1 year in future'::TEXT
    FROM appointments a
    INNER JOIN clients c ON a.client_id = c.client_id
    WHERE c.agent_id = p_agent_id 
        AND a.appointment_date > (CURRENT_DATE + INTERVAL '1 year')
    
    UNION ALL
    
    SELECT 
        'ExpiredActiveReminders'::TEXT,
        COUNT(*)::BIGINT,
        'Active reminders with past dates'::TEXT
    FROM reminders r
    WHERE r.agent_id = p_agent_id 
        AND r.status = 'Active'
        AND r.reminder_date < CURRENT_DATE;
END;
$;

-- ============================================
-- Utility Service Functions
-- ============================================

-- Calculate Age Function
CREATE OR REPLACE FUNCTION fn_calculate_age(p_date_of_birth DATE)
RETURNS INTEGER
LANGUAGE plpgsql
AS $
BEGIN
    RETURN DATE_PART('year', AGE(CURRENT_DATE, p_date_of_birth))::INTEGER;
END;
$;

-- Calculate Days Until Expiry Function
CREATE OR REPLACE FUNCTION fn_days_until_expiry(p_expiry_date DATE)
RETURNS INTEGER
LANGUAGE plpgsql
AS $
BEGIN
    RETURN (p_expiry_date - CURRENT_DATE)::INTEGER;
END;
$;

-- Format Client Name Function
CREATE OR REPLACE FUNCTION fn_format_client_name(p_first_name VARCHAR(50),
    p_surname VARCHAR(50),
    p_last_name VARCHAR(50) DEFAULT NULL)
RETURNS VARCHAR(152)
LANGUAGE plpgsql
AS $$
BEGIN
    RETURN TRIM(COALESCE(p_first_name, '')) || ' ' || 
           TRIM(COALESCE(p_surname, '')) || 
           CASE 
               WHEN p_last_name IS NOT NULL AND TRIM(p_last_name) != '' 
               THEN ' ' || TRIM(p_last_name)
               ELSE ''
           END;
END;
$;

-- Format Phone Number
CREATE OR REPLACE FUNCTION sp_format_phone_number(p_phone_number VARCHAR(20),
    p_country_code VARCHAR(5) DEFAULT '+254')
RETURNS TABLE(formatted_phone_number VARCHAR(20))
LANGUAGE plpgsql
AS $$
DECLARE
    v_phone VARCHAR(20);
    v_formatted VARCHAR(20) := '';
BEGIN
    -- Remove spaces, dashes, and other formatting
    v_phone := REGEXP_REPLACE(p_phone_number, '[^0-9]', '', 'g');
    
    -- Format for Kenya
    IF LENGTH(v_phone) = 10 AND LEFT(v_phone, 1) = '0' THEN
        v_formatted := p_country_code || SUBSTRING(v_phone FROM 2);
    ELSIF LENGTH(v_phone) = 9 THEN
        v_formatted := p_country_code || v_phone;
    ELSIF LENGTH(v_phone) = 12 AND LEFT(v_phone, 3) = '254' THEN
        v_formatted := '+' || v_phone;
    ELSE
        v_formatted := p_phone_number;
    END IF;
    
    RETURN QUERY SELECT v_formatted;
END;
$;

-- Format Currency
CREATE OR REPLACE FUNCTION fn_format_currency(p_amount DECIMAL(10,2))
RETURNS VARCHAR(20)
LANGUAGE plpgsql
AS $$
BEGIN
    RETURN 'KSH ' || TO_CHAR(p_amount, 'FM999,999,999.00');
END;
$;

-- Generate ID (UUID)
CREATE OR REPLACE FUNCTION fn_generate_id()
RETURNS UUID
LANGUAGE plpgsql
AS $
BEGIN
    RETURN gen_random_uuid();
END;
$;

-- Get Greeting
CREATE OR REPLACE FUNCTION sp_get_greeting()
RETURNS TABLE(greeting VARCHAR(20))
LANGUAGE plpgsql
AS $
DECLARE
    v_current_hour INTEGER;
    v_greeting VARCHAR(20);
BEGIN
    v_current_hour := EXTRACT(HOUR FROM CURRENT_TIME);
    
    v_greeting := CASE 
        WHEN v_current_hour < 12 THEN 'Good Morning'
        WHEN v_current_hour < 17 THEN 'Good Afternoon'
        ELSE 'Good Evening'
    END;
    
    RETURN QUERY SELECT v_greeting;
END;
$;

-- Get Status Color
CREATE OR REPLACE FUNCTION fn_get_status_color(p_status VARCHAR(20))
RETURNS VARCHAR(20)
LANGUAGE plpgsql
AS $$
BEGIN
    RETURN CASE p_status
        WHEN 'Active' THEN 'success'
        WHEN 'Completed' THEN 'success'
        WHEN 'Confirmed' THEN 'info'
        WHEN 'Scheduled' THEN 'primary'
        WHEN 'In Progress' THEN 'warning'
        WHEN 'Cancelled' THEN 'danger'
        WHEN 'Expired' THEN 'danger'
        WHEN 'Inactive' THEN 'secondary'
        WHEN 'Lapsed' THEN 'danger'
        ELSE 'secondary'
    END;
END;
$;

-- Get Priority Color
CREATE OR REPLACE FUNCTION fn_get_priority_color(p_priority VARCHAR(10))
RETURNS VARCHAR(20)
LANGUAGE plpgsql
AS $$
BEGIN
    RETURN CASE p_priority
        WHEN 'High' THEN 'danger'
        WHEN 'Medium' THEN 'warning'
        WHEN 'Low' THEN 'info'
        ELSE 'secondary'
    END;
END;
$;

-- Get Appointment Type Icon
CREATE OR REPLACE FUNCTION fn_get_appointment_type_icon(p_type VARCHAR(50))
RETURNS VARCHAR(20)
LANGUAGE plpgsql
AS $$
BEGIN
    RETURN CASE p_type
        WHEN 'Call' THEN 'phone'
        WHEN 'Meeting' THEN 'users'
        WHEN 'Site Visit' THEN 'map-pin'
        WHEN 'Policy Review' THEN 'file-text'
        WHEN 'Claim Processing' THEN 'clipboard'
        ELSE 'calendar'
    END;
END;
$;

-- Parse Template
CREATE OR REPLACE FUNCTION sp_parse_template(p_template TEXT,
    p_client_name VARCHAR(150) DEFAULT NULL,
    p_agent_name VARCHAR(100) DEFAULT NULL,
    p_policy_type VARCHAR(50) DEFAULT NULL,
    p_expiry_date DATE DEFAULT NULL,
    p_company_name VARCHAR(100) DEFAULT NULL)
RETURNS TABLE(parsed_template TEXT)
LANGUAGE plpgsql
AS $$
DECLARE
    v_parsed_template TEXT;
BEGIN
    v_parsed_template := p_template;
    
    -- Replace common placeholders
    v_parsed_template := REPLACE(v_parsed_template, '{name}', COALESCE(p_client_name, '{name}'));
    v_parsed_template := REPLACE(v_parsed_template, '{client_name}', COALESCE(p_client_name, '{client_name}'));
    v_parsed_template := REPLACE(v_parsed_template, '{agent_name}', COALESCE(p_agent_name, '{agent_name}'));
    v_parsed_template := REPLACE(v_parsed_template, '{policy_type}', COALESCE(p_policy_type, '{policy_type}'));
    v_parsed_template := REPLACE(v_parsed_template, '{expiry_date}', COALESCE(p_expiry_date::TEXT, '{expiry_date}'));
    v_parsed_template := REPLACE(v_parsed_template, '{company_name}', COALESCE(p_company_name, '{company_name}'));
    v_parsed_template := REPLACE(v_parsed_template, '{current_date}', CURRENT_DATE::TEXT);
    v_parsed_template := REPLACE(v_parsed_template, '{current_year}', EXTRACT(YEAR FROM CURRENT_DATE)::TEXT);
    
    RETURN QUERY SELECT v_parsed_template;
END;
$;

-- Generate Random Password
CREATE OR REPLACE FUNCTION sp_generate_random_password(p_length INTEGER DEFAULT 12)
RETURNS TABLE(random_password VARCHAR(50))
LANGUAGE plpgsql
AS $$
DECLARE
    v_password TEXT := '';
    v_characters TEXT := 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*';
    v_char_length INTEGER;
    v_counter INTEGER := 0;
BEGIN
    v_char_length := LENGTH(v_characters);
    
    WHILE v_counter < p_length LOOP
        v_password := v_password || SUBSTRING(v_characters FROM (FLOOR(RANDOM() * v_char_length) + 1) FOR 1);
        v_counter := v_counter + 1;
    END LOOP;
    
    RETURN QUERY SELECT v_password::VARCHAR(50);
END;
$;

-- ============================================
-- Notification Service Functions
-- ============================================

-- Create Notifications Table
CREATE TABLE IF NOT EXISTS notifications (
    notification_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    agent_id UUID NOT NULL,
    notification_type VARCHAR(20) NOT NULL CHECK (notification_type IN ('Email', 'SMS', 'WhatsApp', 'Push')),
    recipient VARCHAR(200) NOT NULL,
    subject VARCHAR(200),
    body TEXT NOT NULL,
    status VARCHAR(20) DEFAULT 'Pending' CHECK (status IN ('Pending', 'Sent', 'Failed', 'Cancelled')),
    scheduled_time TIMESTAMPTZ,
    sent_time TIMESTAMPTZ,
    error_message VARCHAR(500),
    retry_count INTEGER DEFAULT 0,
    created_date TIMESTAMPTZ DEFAULT NOW(),
    FOREIGN KEY (agent_id) REFERENCES agent(agent_id) ON DELETE CASCADE
);

-- Send Email Notification
CREATE OR REPLACE FUNCTION sp_send_email_notification(p_agent_id UUID,
    p_to_email VARCHAR(200),
    p_subject VARCHAR(200),
    p_body TEXT)
RETURNS TABLE(
    notification_id UUID,
    success BOOLEAN
)
LANGUAGE plpgsql
AS $$
DECLARE
    v_notification_id UUID;
BEGIN
    v_notification_id := gen_random_uuid();
    
    INSERT INTO notifications (
        notification_id, agent_id, notification_type, recipient, subject, body, status
    )
    VALUES (
        v_notification_id, p_agent_id, 'Email', p_to_email, p_subject, p_body, 'Pending'
    );
    
    -- In a real implementation, this would integrate with an email service
    -- For now, we'll just mark it as sent
    UPDATE notifications 
    SET status = 'Sent', sent_time = NOW()
    WHERE notification_id = v_notification_id;
    
    RETURN QUERY SELECT v_notification_id, TRUE;
END;
$;

-- Send SMS Notification
CREATE OR REPLACE FUNCTION sp_send_sms_notification(p_agent_id UUID,
    p_phone_number VARCHAR(20),
    p_message TEXT)
RETURNS TABLE(
    notification_id UUID,
    success BOOLEAN
)
LANGUAGE plpgsql
AS $$
DECLARE
    v_notification_id UUID;
    v_success BOOLEAN;
BEGIN
    v_notification_id := gen_random_uuid();
    
    INSERT INTO notifications (
        notification_id, agent_id, notification_type, recipient, body, status
    )
    VALUES (
        v_notification_id, p_agent_id, 'SMS', p_phone_number, p_message, 'Pending'
    );
    
    -- In a real implementation, this would integrate with an SMS service
    -- For now, we'll simulate success/failure
    v_success := CASE WHEN RANDOM() > 0.1 THEN TRUE ELSE FALSE END;
    
    IF v_success THEN
        UPDATE notifications 
        SET status = 'Sent', sent_time = NOW()
        WHERE notification_id = v_notification_id;
    ELSE
        UPDATE notifications 
        SET status = 'Failed', error_message = 'Simulated SMS delivery failure'
        WHERE notification_id = v_notification_id;
    END IF;
    
    RETURN QUERY SELECT v_notification_id, v_success;
END;
$;

-- Send WhatsApp Notification
CREATE OR REPLACE FUNCTION sp_send_whatsapp_notification(p_agent_id UUID,
    p_phone_number VARCHAR(20),
    p_message TEXT)
RETURNS TABLE(
    notification_id UUID,
    success BOOLEAN
)
LANGUAGE plpgsql
AS $$
DECLARE
    v_notification_id UUID;
BEGIN
    v_notification_id := gen_random_uuid();
    
    INSERT INTO notifications (
        notification_id, agent_id, notification_type, recipient, body, status
    )
    VALUES (
        v_notification_id, p_agent_id, 'WhatsApp', p_phone_number, p_message, 'Pending'
    );
    
    -- In a real implementation, this would integrate with WhatsApp Business API
    -- For now, we'll simulate success
    UPDATE notifications 
    SET status = 'Sent', sent_time = NOW()
    WHERE notification_id = v_notification_id;
    
    RETURN QUERY SELECT v_notification_id, TRUE;
END;
$;

-- Send Push Notification
CREATE OR REPLACE FUNCTION sp_send_push_notification(p_agent_id UUID,
    p_title VARCHAR(200),
    p_body TEXT)
RETURNS TABLE(
    notification_id UUID,
    success BOOLEAN
)
LANGUAGE plpgsql
AS $$
DECLARE
    v_notification_id UUID;
BEGIN
    v_notification_id := gen_random_uuid();
    
    INSERT INTO notifications (
        notification_id, agent_id, notification_type, recipient, subject, body, status
    )
    VALUES (
        v_notification_id, p_agent_id, 'Push', p_agent_id::TEXT, p_title, p_body, 'Pending'
    );
    
    -- In a real implementation, this would integrate with push notification service
    UPDATE notifications 
    SET status = 'Sent', sent_time = NOW()
    WHERE notification_id = v_notification_id;
    
    RETURN QUERY SELECT v_notification_id, TRUE;
END;
$;

-- Schedule Notification
CREATE OR REPLACE FUNCTION sp_schedule_notification(p_agent_id UUID,
    p_scheduled_time TIMESTAMPTZ,
    p_notification_type VARCHAR(20),
    p_recipient VARCHAR(200),
    p_body TEXT,
    p_subject VARCHAR(200) DEFAULT NULL)
RETURNS TABLE(notification_id UUID)
LANGUAGE plpgsql
AS $$
DECLARE
    v_notification_id UUID;
BEGIN
    v_notification_id := gen_random_uuid();
    
    INSERT INTO notifications (
        notification_id, agent_id, notification_type, recipient, subject, body, scheduled_time, status
    )
    VALUES (
        v_notification_id, p_agent_id, p_notification_type, p_recipient, p_subject, p_body, p_scheduled_time, 'Pending'
    );
    
    RETURN QUERY SELECT v_notification_id;
END;
$;

-- Cancel Scheduled Notification
CREATE OR REPLACE FUNCTION sp_cancel_scheduled_notification(p_notification_id UUID,
    p_agent_id UUID)
RETURNS TABLE(rows_affected INTEGER)
LANGUAGE plpgsql
AS $
DECLARE
    v_rows_affected INTEGER;
BEGIN
    UPDATE notifications 
    SET status = 'Cancelled'
    WHERE notification_id = p_notification_id 
        AND agent_id = p_agent_id 
        AND status = 'Pending';
    
    GET DIAGNOSTICS v_rows_affected = ROW_COUNT;
    
    RETURN QUERY SELECT v_rows_affected;
END;
$;

-- Process Scheduled Notifications
CREATE OR REPLACE FUNCTION sp_process_scheduled_notifications()
RETURNS TABLE(
    notification_id UUID,
    agent_id UUID,
    notification_type VARCHAR(20),
    recipient VARCHAR(200),
    subject VARCHAR(200),
    body TEXT,
    scheduled_time TIMESTAMPTZ
)
LANGUAGE plpgsql
AS $
BEGIN
    RETURN QUERY
    SELECT 
        n.notification_id,
        n.agent_id,
        n.notification_type,
        n.recipient,
        n.subject,
        n.body,
        n.scheduled_time
    FROM notifications n
    WHERE n.status = 'Pending'
        AND n.scheduled_time IS NOT NULL
        AND n.scheduled_time <= NOW()
    ORDER BY n.scheduled_time ASC;
END;
$;

-- Get Notification History
CREATE OR REPLACE FUNCTION sp_get_notification_history(p_agent_id UUID,
    p_start_date DATE DEFAULT NULL,
    p_end_date DATE DEFAULT NULL,
    p_notification_type VARCHAR(20) DEFAULT NULL,
    p_status VARCHAR(20) DEFAULT NULL,
    p_page_size INTEGER DEFAULT 50,
    p_page_number INTEGER DEFAULT 1)
RETURNS TABLE(
    notification_id UUID,
    notification_type VARCHAR(20),
    recipient VARCHAR(200),
    subject VARCHAR(200),
    body TEXT,
    status VARCHAR(20),
    scheduled_time TIMESTAMPTZ,
    sent_time TIMESTAMPTZ,
    error_message VARCHAR(500),
    retry_count INTEGER,
    created_date TIMESTAMPTZ,
    total_records BIGINT
)
LANGUAGE plpgsql
AS $$
DECLARE
    v_start_date DATE;
    v_end_date DATE;
    v_offset INTEGER;
    v_total_records BIGINT;
BEGIN
    v_start_date := COALESCE(p_start_date, CURRENT_DATE - INTERVAL '30 days');
    v_end_date := COALESCE(p_end_date, CURRENT_DATE);
    v_offset := (p_page_number - 1) * p_page_size;
    
    -- Get total count
    SELECT COUNT(*) INTO v_total_records
    FROM notifications n
    WHERE 
        n.agent_id = p_agent_id
        AND n.created_date BETWEEN v_start_date AND (v_end_date + INTERVAL '1 day')
        AND (p_notification_type IS NULL OR n.notification_type = p_notification_type)
        AND (p_status IS NULL OR n.status = p_status);
    
    RETURN QUERY
    SELECT 
        n.notification_id,
        n.notification_type,
        n.recipient,
        n.subject,
        n.body,
        n.status,
        n.scheduled_time,
        n.sent_time,
        n.error_message,
        n.retry_count,
        n.created_date,
        v_total_records
    FROM notifications n
    WHERE 
        n.agent_id = p_agent_id
        AND n.created_date BETWEEN v_start_date AND (v_end_date + INTERVAL '1 day')
        AND (p_notification_type IS NULL OR n.notification_type = p_notification_type)
        AND (p_status IS NULL OR n.status = p_status)
    ORDER BY n.created_date DESC
    LIMIT p_page_size OFFSET v_offset;
END;
$;

-- Update Notification Status
CREATE OR REPLACE FUNCTION sp_update_notification_status(p_notification_id UUID,
    p_status VARCHAR(20),
    p_error_message VARCHAR(500) DEFAULT NULL)
RETURNS TABLE(rows_affected INTEGER)
LANGUAGE plpgsql
AS $$
DECLARE
    v_rows_affected INTEGER;
BEGIN
    UPDATE notifications 
    SET 
        status = p_status,
        sent_time = CASE WHEN p_status = 'Sent' THEN NOW() ELSE sent_time END,
        error_message = p_error_message,
        retry_count = CASE WHEN p_status = 'Failed' THEN retry_count + 1 ELSE retry_count END
    WHERE notification_id = p_notification_id;
    
    GET DIAGNOSTICS v_rows_affected = ROW_COUNT;
    
    RETURN QUERY SELECT v_rows_affected;
END;
$;
-- ============================================
-- Indexes and Performance Optimization (PostgreSQL)
-- ============================================

-- Agent Table Indexes
CREATE INDEX IF NOT EXISTS idx_agent_email ON agent(email);
CREATE INDEX IF NOT EXISTS idx_agent_is_active ON agent(is_active);

-- Clients Table Indexes
CREATE INDEX IF NOT EXISTS idx_clients_agent_id ON clients(agent_id);
CREATE INDEX IF NOT EXISTS idx_clients_is_active ON clients(is_active);
CREATE INDEX IF NOT EXISTS idx_clients_is_client ON clients(is_client);
CREATE INDEX IF NOT EXISTS idx_clients_phone_number ON clients(phone_number);
CREATE INDEX IF NOT EXISTS idx_clients_email ON clients(email);
CREATE INDEX IF NOT EXISTS idx_clients_date_of_birth ON clients(date_of_birth);
CREATE INDEX IF NOT EXISTS idx_clients_insurance_type ON clients(insurance_type);
CREATE INDEX IF NOT EXISTS idx_clients_search ON clients(agent_id, is_active) INCLUDE (first_name, surname, last_name, phone_number, email);

-- Appointments Table Indexes
CREATE INDEX IF NOT EXISTS idx_appointments_agent_id ON appointments(agent_id);
CREATE INDEX IF NOT EXISTS idx_appointments_client_id ON appointments(client_id);
CREATE INDEX IF NOT EXISTS idx_appointments_date ON appointments(appointment_date);
CREATE INDEX IF NOT EXISTS idx_appointments_status ON appointments(status);
CREATE INDEX IF NOT EXISTS idx_appointments_type ON appointments(type);
CREATE INDEX IF NOT EXISTS idx_appointments_is_active ON appointments(is_active);
CREATE INDEX IF NOT EXISTS idx_appointments_dashboard ON appointments(agent_id, appointment_date, is_active) INCLUDE (client_name, title, start_time, end_time, status);

-- Client Policies Indexes
CREATE INDEX IF NOT EXISTS idx_client_policies_client_id ON client_policies(client_id);
CREATE INDEX IF NOT EXISTS idx_client_policies_status ON client_policies(status);
CREATE INDEX IF NOT EXISTS idx_client_policies_end_date ON client_policies(end_date);
CREATE INDEX IF NOT EXISTS idx_client_policies_is_active ON client_policies(is_active);
CREATE INDEX IF NOT EXISTS idx_client_policies_expiring ON client_policies(status, end_date, is_active);

-- Reminders Table Indexes
CREATE INDEX IF NOT EXISTS idx_reminders_agent_id ON reminders(agent_id);
CREATE INDEX IF NOT EXISTS idx_reminders_client_id ON reminders(client_id);
CREATE INDEX IF NOT EXISTS idx_reminders_date ON reminders(reminder_date);
CREATE INDEX IF NOT EXISTS idx_reminders_status ON reminders(status);
CREATE INDEX IF NOT EXISTS idx_reminders_type ON reminders(reminder_type);
CREATE INDEX IF NOT EXISTS idx_reminders_active ON reminders(agent_id, status, reminder_date);

-- Policy Catalog Indexes
CREATE INDEX IF NOT EXISTS idx_policy_catalog_agent_id ON policy_catalog(agent_id);
CREATE INDEX IF NOT EXISTS idx_policy_catalog_type ON policy_catalog(type_id);
CREATE INDEX IF NOT EXISTS idx_policy_catalog_company ON policy_catalog(company_id);
CREATE INDEX IF NOT EXISTS idx_policy_catalog_is_active ON policy_catalog(is_active);

-- Automated Messages Indexes
CREATE INDEX IF NOT EXISTS idx_automated_messages_agent_id ON automated_messages(agent_id);
CREATE INDEX IF NOT EXISTS idx_automated_messages_status ON automated_messages(status);
CREATE INDEX IF NOT EXISTS idx_automated_messages_scheduled_date ON automated_messages(scheduled_date);

-- Activity Log Indexes
CREATE INDEX IF NOT EXISTS idx_activity_log_agent_id ON activity_log(agent_id);
CREATE INDEX IF NOT EXISTS idx_activity_log_date ON activity_log(activity_date);
CREATE INDEX IF NOT EXISTS idx_activity_log_type ON activity_log(activity_type);
CREATE INDEX IF NOT EXISTS idx_activity_log_entity ON activity_log(entity_type, entity_id);

-- Dashboard Statistics Indexes
CREATE INDEX IF NOT EXISTS idx_dashboard_statistics_agent_date ON dashboard_statistics(agent_id, stat_date);

-- Performance Metrics Indexes
CREATE INDEX IF NOT EXISTS idx_performance_metrics_agent_date ON performance_metrics(agent_id, metric_date);

-- Monthly Reports Indexes
CREATE INDEX IF NOT EXISTS idx_monthly_reports_agent_month ON monthly_reports(agent_id, report_month);

-- Settings Tables Indexes (if these tables exist)
CREATE INDEX IF NOT EXISTS idx_reminder_settings_agent_id ON reminder_settings(agent_id);

-- Daily Notes Indexes
CREATE INDEX IF NOT EXISTS idx_daily_notes_agent_date ON daily_notes(agent_id, note_date);

-- Message Recipients Indexes
CREATE INDEX IF NOT EXISTS idx_message_recipients_message_id ON message_recipients(message_id);
CREATE INDEX IF NOT EXISTS idx_message_recipients_client_id ON message_recipients(client_id);
CREATE INDEX IF NOT EXISTS idx_message_recipients_status ON message_recipients(delivery_status);

-- ============================================
-- Additional Constraints and Validations
-- ============================================

-- Ensure email uniqueness across active agents
CREATE UNIQUE INDEX IF NOT EXISTS ux_agent_email_active 
ON agent(email) 
WHERE is_active = TRUE;

-- Ensure phone number format validation (basic constraint for Kenya)
ALTER TABLE clients 
ADD CONSTRAINT IF NOT EXISTS ck_clients_phone_format 
CHECK (
    phone_number ~ '^\+254[0-9]{9}$' 
    OR phone_number ~ '^07[0-9]{8}$'
    OR phone_number ~ '^01[0-9]{8}$'
);

-- Ensure appointment end time is after start time
ALTER TABLE appointments 
ADD CONSTRAINT IF NOT EXISTS ck_appointments_time_order 
CHECK (end_time > start_time);

-- Ensure policy end date is after start date
ALTER TABLE client_policies 
ADD CONSTRAINT IF NOT EXISTS ck_client_policies_date_order 
CHECK (end_date > start_date);

-- Ensure reminder date is not in the past (for new reminders)
ALTER TABLE reminders 
ADD CONSTRAINT IF NOT EXISTS ck_reminders_future_date 
CHECK (reminder_date >= CURRENT_DATE OR status != 'Active');

-- Ensure scheduled message date is in the future
ALTER TABLE automated_messages 
ADD CONSTRAINT IF NOT EXISTS ck_automated_messages_scheduled_date 
CHECK (scheduled_date > NOW() OR status != 'Scheduled');

-- ============================================
-- Views for Common Queries
-- ============================================

-- Active Clients View
CREATE OR REPLACE VIEW vw_active_clients AS
SELECT 
    c.*,
    cp.policy_id,
    cp.policy_name,
    pt.type_name AS policy_type,
    ic.company_name AS policy_company,
    cp.status AS policy_status,
    cp.start_date AS policy_start_date,
    cp.end_date AS policy_end_date,
    fn_calculate_age(c.date_of_birth) AS age
FROM clients c
LEFT JOIN client_policies cp ON c.client_id = cp.client_id AND cp.is_active = TRUE
LEFT JOIN policy_types pt ON cp.type_id = pt.type_id
LEFT JOIN insurance_companies ic ON cp.company_id = ic.company_id
WHERE c.is_active = TRUE;

-- Today's Dashboard View
CREATE OR REPLACE VIEW vw_today_dashboard AS
SELECT 
    c.agent_id,
    -- Today's Appointments
    COUNT(DISTINCT CASE 
        WHEN a.appointment_date = CURRENT_DATE AND a.status NOT IN ('Cancelled') 
        THEN a.appointment_id END) AS today_appointments,
    -- Today's Reminders
    COUNT(DISTINCT CASE 
        WHEN r.reminder_date = CURRENT_DATE AND r.status = 'Active' 
        THEN r.reminder_id END) AS today_reminders,
    -- Today's Birthdays
    COUNT(DISTINCT CASE 
        WHEN EXTRACT(DAY FROM c.date_of_birth) = EXTRACT(DAY FROM CURRENT_DATE) 
        AND EXTRACT(MONTH FROM c.date_of_birth) = EXTRACT(MONTH FROM CURRENT_DATE) 
        THEN c.client_id END) AS today_birthdays,
    -- Expiring Policies (next 30 days)
    COUNT(DISTINCT CASE 
        WHEN cp.end_date BETWEEN CURRENT_DATE AND (CURRENT_DATE + INTERVAL '30 days') 
        AND cp.status = 'Active' 
        THEN cp.policy_id END) AS expiring_policies
FROM clients c
LEFT JOIN appointments a ON c.client_id = a.client_id AND a.is_active = TRUE
LEFT JOIN reminders r ON c.client_id = r.client_id
LEFT JOIN client_policies cp ON c.client_id = cp.client_id AND cp.is_active = TRUE
WHERE c.is_active = TRUE
GROUP BY c.agent_id;

-- Expiring Policies View
CREATE OR REPLACE VIEW vw_expiring_policies AS
SELECT 
    c.agent_id,
    cp.policy_id,
    cp.policy_name,
    pt.type_name AS policy_type,
    ic.company_name AS policy_company,
    cp.end_date,
    c.client_id,
    fn_format_client_name(c.first_name, c.surname, c.last_name) AS client_name,
    c.phone_number,
    c.email,
    fn_days_until_expiry(cp.end_date) AS days_until_expiry
FROM client_policies cp
INNER JOIN clients c ON cp.client_id = c.client_id
LEFT JOIN policy_types pt ON cp.type_id = pt.type_id
LEFT JOIN insurance_companies ic ON cp.company_id = ic.company_id
WHERE 
    cp.status = 'Active' 
    AND cp.is_active = TRUE 
    AND c.is_active = TRUE
    AND cp.end_date BETWEEN CURRENT_DATE AND (CURRENT_DATE + INTERVAL '60 days');

-- Client Summary with Statistics
CREATE OR REPLACE VIEW vw_client_summary AS
SELECT 
    c.client_id,
    c.agent_id,
    c.first_name,
    c.surname,
    c.last_name,
    fn_format_client_name(c.first_name, c.surname, c.last_name) AS full_name,
    c.phone_number,
    c.email,
    c.is_client,
    c.insurance_type,
    c.created_date,
    fn_calculate_age(c.date_of_birth) AS age,
    COUNT(cp.policy_id) AS policy_count,
    COUNT(CASE WHEN cp.status = 'Active' THEN 1 END) AS active_policies,
    MAX(cp.end_date) AS latest_policy_expiry,
    COUNT(a.appointment_id) AS total_appointments,
    COUNT(CASE WHEN a.status = 'Completed' THEN 1 END) AS completed_appointments
FROM clients c
LEFT JOIN client_policies cp ON c.client_id = cp.client_id AND cp.is_active = TRUE
LEFT JOIN appointments a ON c.client_id = a.client_id AND a.is_active = TRUE
WHERE c.is_active = TRUE
GROUP BY c.client_id, c.agent_id, c.first_name, c.surname, c.last_name, 
         c.phone_number, c.email, c.is_client, c.insurance_type, c.created_date, c.date_of_birth;

-- Today's Schedule View
CREATE OR REPLACE VIEW vw_today_schedule AS
SELECT 
    a.appointment_id,
    a.agent_id,
    a.client_name,
    a.title,
    a.start_time,
    a.end_time,
    a.type,
    a.status,
    a.priority,
    a.location,
    a.notes,
    c.phone_number AS client_phone,
    EXTRACT(EPOCH FROM (a.end_time - a.start_time))/3600 AS duration_hours
FROM appointments a
LEFT JOIN clients c ON a.client_id = c.client_id
WHERE a.appointment_date = CURRENT_DATE
    AND a.is_active = TRUE
ORDER BY a.start_time;

-- ============================================
-- Triggers for Audit and Business Logic
-- ============================================

-- Function to update modified_date (already created in main schema)

-- Trigger to log appointment status changes
CREATE OR REPLACE FUNCTION log_appointment_status_change()
RETURNS TRIGGER AS $
BEGIN
    IF OLD.status IS DISTINCT FROM NEW.status THEN
        INSERT INTO activity_log (agent_id, activity_type, entity_type, entity_id, description)
        VALUES (
            NEW.agent_id,
            'appointment_status_changed',
            'appointment',
            NEW.appointment_id,
            'Appointment "' || NEW.title || '" status changed from ' || OLD.status || ' to ' || NEW.status
        );
    END IF;
    RETURN NEW;
END;
$ LANGUAGE plpgsql;

CREATE TRIGGER tr_appointments_status_change
    AFTER UPDATE ON appointments
    FOR EACH ROW
    EXECUTE FUNCTION log_appointment_status_change();

-- Trigger to auto-create reminders for policy expiry
CREATE OR REPLACE FUNCTION create_policy_expiry_reminder()
RETURNS TRIGGER AS $
BEGIN
    -- Only create reminder for active policies that expire more than 30 days from now
    IF NEW.status = 'Active' AND NEW.end_date > (CURRENT_DATE + INTERVAL '30 days') THEN
        -- Check if reminder doesn't already exist
        IF NOT EXISTS (
            SELECT 1 FROM reminders r 
            WHERE r.client_id = NEW.client_id 
            AND r.reminder_type = 'Policy Expiry' 
            AND r.reminder_date = (NEW.end_date - INTERVAL '30 days')
            AND r.status = 'Active'
        ) THEN
            INSERT INTO reminders (
                client_id, 
                agent_id, 
                reminder_type, 
                title, 
                description, 
                reminder_date, 
                priority, 
                enable_push_notification
            )
            SELECT 
                NEW.client_id,
                c.agent_id,
                'Policy Expiry',
                'Policy Expiring: ' || NEW.policy_name,
                'Policy expires on ' || TO_CHAR(NEW.end_date, 'Month DD, YYYY'),
                NEW.end_date - INTERVAL '30 days',
                'High',
                TRUE
            FROM clients c 
            WHERE c.client_id = NEW.client_id;
        END IF;
    END IF;
    RETURN NEW;
END;
$ LANGUAGE plpgsql;

CREATE TRIGGER tr_client_policies_expiry_reminder
    AFTER INSERT OR UPDATE ON client_policies
    FOR EACH ROW
    EXECUTE FUNCTION create_policy_expiry_reminder();

-- Trigger to log client additions
CREATE OR REPLACE FUNCTION log_client_activity()
RETURNS TRIGGER AS $
BEGIN
    IF TG_OP = 'INSERT' THEN
        INSERT INTO activity_log (agent_id, activity_type, entity_type, entity_id, description)
        VALUES (
            NEW.agent_id,
            'client_added',
            'client',
            NEW.client_id,
            'New client added: ' || fn_format_client_name(NEW.first_name, NEW.surname, NEW.last_name)
        );
        RETURN NEW;
    ELSIF TG_OP = 'UPDATE' THEN
        -- Log status changes
        IF OLD.is_client IS DISTINCT FROM NEW.is_client THEN
            INSERT INTO activity_log (agent_id, activity_type, entity_type, entity_id, description)
            VALUES (
                NEW.agent_id,
                CASE WHEN NEW.is_client THEN 'prospect_converted' ELSE 'client_status_changed' END,
                'client',
                NEW.client_id,
                'Client status changed: ' || fn_format_client_name(NEW.first_name, NEW.surname, NEW.last_name)
            );
        END IF;
        RETURN NEW;
    END IF;
    RETURN NULL;
END;
$ LANGUAGE plpgsql;

CREATE TRIGGER tr_clients_activity_log
    AFTER INSERT OR UPDATE ON clients
    FOR EACH ROW
    EXECUTE FUNCTION log_client_activity();

-- Trigger to log appointment creation/updates
CREATE OR REPLACE FUNCTION log_appointment_activity()
RETURNS TRIGGER AS $
BEGIN
    IF TG_OP = 'INSERT' THEN
        INSERT INTO activity_log (agent_id, activity_type, entity_type, entity_id, description)
        VALUES (
            NEW.agent_id,
            'appointment_created',
            'appointment',
            NEW.appointment_id,
            'New appointment created: ' || NEW.title || ' with ' || NEW.client_name
        );
        RETURN NEW;
    ELSIF TG_OP = 'UPDATE' THEN
        -- Log completion
        IF OLD.status IS DISTINCT FROM NEW.status AND NEW.status = 'Completed' THEN
            INSERT INTO activity_log (agent_id, activity_type, entity_type, entity_id, description)
            VALUES (
                NEW.agent_id,
                'appointment_completed',
                'appointment',
                NEW.appointment_id,
                'Appointment completed: ' || NEW.title || ' with ' || NEW.client_name
            );
        END IF;
        RETURN NEW;
    END IF;
    RETURN NULL;
END;
$ LANGUAGE plpgsql;

CREATE TRIGGER tr_appointments_activity_log
    AFTER INSERT OR UPDATE ON appointments
    FOR EACH ROW
    EXECUTE FUNCTION log_appointment_activity();

-- ============================================
-- Functions for Common Calculations (Enhanced)
-- ============================================

-- Function to calculate client age (already created in main schema, but enhanced version here)
CREATE OR REPLACE FUNCTION fn_calculate_age(p_date_of_birth DATE)
RETURNS INTEGER
LANGUAGE plpgsql
AS $
BEGIN
    IF p_date_of_birth IS NULL THEN
        RETURN NULL;
    END IF;
    
    RETURN DATE_PART('year', AGE(CURRENT_DATE, p_date_of_birth))::INTEGER;
END;
$;

-- Function to get days until expiry (already created, enhanced version)
CREATE OR REPLACE FUNCTION fn_days_until_expiry(p_expiry_date DATE)
RETURNS INTEGER
LANGUAGE plpgsql
AS $
BEGIN
    IF p_expiry_date IS NULL THEN
        RETURN NULL;
    END IF;
    
    RETURN (p_expiry_date - CURRENT_DATE)::INTEGER;
END;
$;

-- Function to format client full name (already created, enhanced version)
CREATE OR REPLACE FUNCTION fn_format_client_name(p_first_name VARCHAR(50),
    p_surname VARCHAR(50),
    p_last_name VARCHAR(50) DEFAULT NULL)
RETURNS VARCHAR(152)
LANGUAGE plpgsql
AS $$
BEGIN
    RETURN TRIM(
        COALESCE(p_first_name, '') || ' ' || 
        COALESCE(p_surname, '') || 
        CASE 
            WHEN p_last_name IS NOT NULL AND TRIM(p_last_name) != '' 
            THEN ' ' || TRIM(p_last_name)
            ELSE ''
        END
    );
END;
$;

-- Function to get policy expiry status
CREATE OR REPLACE FUNCTION fn_get_policy_expiry_status(p_end_date DATE)
RETURNS VARCHAR(20)
LANGUAGE plpgsql
AS $
DECLARE
    days_until_expiry INTEGER;
BEGIN
    IF p_end_date IS NULL THEN
        RETURN 'Unknown';
    END IF;
    
    days_until_expiry := fn_days_until_expiry(p_end_date);
    
    CASE 
        WHEN days_until_expiry < 0 THEN RETURN 'Expired';
        WHEN days_until_expiry <= 7 THEN RETURN 'Critical';
        WHEN days_until_expiry <= 30 THEN RETURN 'Warning';
        WHEN days_until_expiry <= 90 THEN RETURN 'Notice';
        ELSE RETURN 'Active';
    END CASE;
END;
$;

-- Function to calculate business days between dates
CREATE OR REPLACE FUNCTION fn_business_days_between(p_start_date DATE,
    p_end_date DATE)
RETURNS INTEGER
LANGUAGE plpgsql
AS $
DECLARE
    business_days INTEGER := 0;
    current_date DATE := p_start_date;
BEGIN
    WHILE current_date <= p_end_date LOOP
        -- Count only Monday through Friday (1-5)
        IF EXTRACT(DOW FROM current_date) BETWEEN 1 AND 5 THEN
            business_days := business_days + 1;
        END IF;
        current_date := current_date + 1;
    END LOOP;
    
    RETURN business_days;
END;
$;

-- Function to get next business day
CREATE OR REPLACE FUNCTION fn_next_business_day(p_date DATE DEFAULT CURRENT_DATE)
RETURNS DATE
LANGUAGE plpgsql
AS $
DECLARE
    next_day DATE := p_date + 1;
BEGIN
    -- Skip weekends
    WHILE EXTRACT(DOW FROM next_day) IN (0, 6) LOOP -- Sunday = 0, Saturday = 6
        next_day := next_day + 1;
    END LOOP;
    
    RETURN next_day;
END;
$;

-- Function to format currency (Kenyan Shilling)
CREATE OR REPLACE FUNCTION fn_format_currency_ksh(p_amount DECIMAL)
RETURNS TEXT
LANGUAGE plpgsql
AS $
BEGIN
    IF p_amount IS NULL THEN
        RETURN 'KSH 0.00';
    END IF;
    
    RETURN 'KSH ' || TO_CHAR(p_amount, 'FM999,999,999.00');
END;
$;

-- ============================================
-- Materialized Views for Performance
-- ============================================

-- Materialized view for agent dashboard statistics
CREATE MATERIALIZED VIEW IF NOT EXISTS mv_agent_dashboard_stats AS
SELECT 
    a.agent_id,
    a.first_name || ' ' || a.last_name AS agent_name,
    COUNT(DISTINCT c.client_id) AS total_clients,
    COUNT(DISTINCT CASE WHEN c.is_client = TRUE THEN c.client_id END) AS active_clients,
    COUNT(DISTINCT CASE WHEN c.is_client = FALSE THEN c.client_id END) AS prospects,
    COUNT(DISTINCT cp.policy_id) AS total_policies,
    COUNT(DISTINCT CASE WHEN cp.status = 'Active' THEN cp.policy_id END) AS active_policies,
    COUNT(DISTINCT CASE WHEN ap.appointment_date = CURRENT_DATE THEN ap.appointment_id END) AS today_appointments,
    COUNT(DISTINCT CASE WHEN r.reminder_date = CURRENT_DATE AND r.status = 'Active' THEN r.reminder_id END) AS today_reminders,
    NOW() AS last_updated
FROM agent a
LEFT JOIN clients c ON a.agent_id = c.agent_id AND c.is_active = TRUE
LEFT JOIN client_policies cp ON c.client_id = cp.client_id AND cp.is_active = TRUE
LEFT JOIN appointments ap ON c.client_id = ap.client_id AND ap.is_active = TRUE
LEFT JOIN reminders r ON c.client_id = r.client_id
WHERE a.is_active = TRUE
GROUP BY a.agent_id, a.first_name, a.last_name;

-- Create indexes on the materialized view
CREATE INDEX IF NOT EXISTS idx_mv_agent_dashboard_stats_agent_id ON mv_agent_dashboard_stats(agent_id);

-- Function to refresh dashboard statistics
CREATE OR REPLACE FUNCTION refresh_agent_dashboard_stats()
RETURNS VOID
LANGUAGE plpgsql
AS $
BEGIN
    REFRESH MATERIALIZED VIEW CONCURRENTLY mv_agent_dashboard_stats;
END;
$;

-- ============================================
-- Utility Functions for Data Cleanup
-- ============================================

-- Function to clean up old activity logs
CREATE OR REPLACE FUNCTION cleanup_old_activity_logs(p_days_to_keep INTEGER DEFAULT 90)
RETURNS INTEGER
LANGUAGE plpgsql
AS $
DECLARE
    deleted_count INTEGER;
BEGIN
    DELETE FROM activity_log 
    WHERE activity_date < (CURRENT_DATE - INTERVAL '1 day' * p_days_to_keep);
    
    GET DIAGNOSTICS deleted_count = ROW_COUNT;
    RETURN deleted_count;
END;
$;

-- Function to update dashboard statistics
CREATE OR REPLACE FUNCTION update_dashboard_statistics(p_agent_id UUID)
RETURNS VOID
LANGUAGE plpgsql
AS $
BEGIN
    INSERT INTO dashboard_statistics (
        agent_id, stat_date, total_clients, total_prospects, active_policies,
        today_appointments, pending_reminders, today_birthdays, expiring_policies
    )
    SELECT 
        p_agent_id,
        CURRENT_DATE,
        COUNT(DISTINCT CASE WHEN c.is_client = TRUE THEN c.client_id END),
        COUNT(DISTINCT CASE WHEN c.is_client = FALSE THEN c.client_id END),
        COUNT(DISTINCT CASE WHEN cp.status = 'Active' THEN cp.policy_id END),
        COUNT(DISTINCT CASE WHEN a.appointment_date = CURRENT_DATE AND a.status NOT IN ('Cancelled') THEN a.appointment_id END),
        COUNT(DISTINCT CASE WHEN r.reminder_date <= CURRENT_DATE AND r.status = 'Active' THEN r.reminder_id END),
        COUNT(DISTINCT CASE WHEN EXTRACT(DAY FROM c.date_of_birth) = EXTRACT(DAY FROM CURRENT_DATE) 
                              AND EXTRACT(MONTH FROM c.date_of_birth) = EXTRACT(MONTH FROM CURRENT_DATE) 
                              THEN c.client_id END),
        COUNT(DISTINCT CASE WHEN cp.end_date BETWEEN CURRENT_DATE AND (CURRENT_DATE + INTERVAL '30 days') 
                              AND cp.status = 'Active' THEN cp.policy_id END)
    FROM clients c
    LEFT JOIN client_policies cp ON c.client_id = cp.client_id AND cp.is_active = TRUE
    LEFT JOIN appointments a ON c.client_id = a.client_id AND a.is_active = TRUE
    LEFT JOIN reminders r ON c.client_id = r.client_id
    WHERE c.agent_id = p_agent_id AND c.is_active = TRUE
    ON CONFLICT (agent_id, stat_date) 
    DO UPDATE SET
        total_clients = EXCLUDED.total_clients,
        total_prospects = EXCLUDED.total_prospects,
        active_policies = EXCLUDED.active_policies,
        today_appointments = EXCLUDED.today_appointments,
        pending_reminders = EXCLUDED.pending_reminders,
        today_birthdays = EXCLUDED.today_birthdays,
        expiring_policies = EXCLUDED.expiring_policies,
        updated_date = NOW();
END;
BEGIN
$ LANGUAGE plpgsql;