


-- -- ===========================================================
-- -- Analytics and Dashboard PostgreSQL Functions
-- -- ===========================================================

-- -- Get Dashboard Overview
-- CREATE OR REPLACE FUNCTION sp_get_dashboard_overview(p_agent_id UUID)
-- RETURNS TABLE (
--     total_clients BIGINT,
--     total_prospects BIGINT,
--     active_policies BIGINT,
--     today_appointments BIGINT,
--     week_appointments BIGINT,
--     month_appointments BIGINT,
--     completed_appointments BIGINT,
--     pending_reminders BIGINT,
--     today_birthdays BIGINT,
--     expiring_policies BIGINT
-- ) AS $$
-- DECLARE
--     v_today DATE := CURRENT_DATE;
--     v_week_start DATE := DATE_TRUNC('week', v_today)::DATE;
--     v_week_end DATE := v_week_start + INTERVAL '6 days';
--     v_month_start DATE := DATE_TRUNC('month', v_today)::DATE;
--     v_month_end DATE := (DATE_TRUNC('month', v_today) + INTERVAL '1 month - 1 day')::DATE;
-- BEGIN
--     RETURN QUERY
--     SELECT 
--         -- Client Statistics
--         COUNT(DISTINCT CASE WHEN c.is_client = TRUE THEN c.client_id END) AS total_clients,
--         COUNT(DISTINCT CASE WHEN c.is_client = FALSE THEN c.client_id END) AS total_prospects,
        
--         -- Policy Statistics
--         COUNT(DISTINCT CASE WHEN cp.status = 'Active' THEN cp.policy_id END) AS active_policies,
        
--         -- Appointment Statistics
--         COUNT(DISTINCT CASE WHEN a.appointment_date = v_today THEN a.appointment_id END) AS today_appointments,
--         COUNT(DISTINCT CASE WHEN a.appointment_date BETWEEN v_week_start AND v_week_end THEN a.appointment_id END) AS week_appointments,
--         COUNT(DISTINCT CASE WHEN a.appointment_date BETWEEN v_month_start AND v_month_end THEN a.appointment_id END) AS month_appointments,
--         COUNT(DISTINCT CASE WHEN a.status = 'Completed' THEN a.appointment_id END) AS completed_appointments,
        
--         -- Reminder Statistics
--         COUNT(DISTINCT CASE WHEN r.status = 'Active' AND r.reminder_date <= v_today THEN r.reminder_id END) AS pending_reminders,
        
--         -- Birthday Statistics
--         COUNT(DISTINCT CASE WHEN EXTRACT(DAY FROM c.date_of_birth) = EXTRACT(DAY FROM v_today) 
--                            AND EXTRACT(MONTH FROM c.date_of_birth) = EXTRACT(MONTH FROM v_today) 
--                            THEN c.client_id END) AS today_birthdays,
        
--         -- Expiring Policies
--         COUNT(DISTINCT CASE WHEN cp.end_date BETWEEN v_today AND (v_today + INTERVAL '30 days') 
--                            AND cp.status = 'Active' THEN cp.policy_id END) AS expiring_policies
        
--     FROM clients c
--     LEFT JOIN client_policies cp ON c.client_id = cp.client_id AND cp.is_active = TRUE
--     LEFT JOIN appointments a ON c.client_id = a.client_id AND a.is_active = TRUE
--     LEFT JOIN reminders r ON c.client_id = r.client_id
--     WHERE c.agent_id = p_agent_id AND c.is_active = TRUE;
-- END;
-- $$ LANGUAGE plpgsql;

-- -- Get Today's Activities
-- CREATE OR REPLACE FUNCTION sp_get_today_activities(p_agent_id UUID)
-- RETURNS TABLE (
--     activity_type VARCHAR(20),
--     entity_id UUID,
--     client_name VARCHAR(255),
--     title VARCHAR(255),
--     time_range VARCHAR(50),
--     location TEXT,
--     type VARCHAR(50),
--     status VARCHAR(20),
--     notes TEXT,
--     priority VARCHAR(10),
--     client_phone VARCHAR(20)
-- ) AS $$
-- DECLARE
--     v_today DATE := CURRENT_DATE;
-- BEGIN
--     -- Today's Appointments
--     RETURN QUERY
--     SELECT 
--         'appointment'::VARCHAR(20) AS activity_type,
--         a.appointment_id AS entity_id,
--         a.client_name,
--         a.title,
--         TO_CHAR(a.start_time, 'HH24:MI') || ' - ' || TO_CHAR(a.end_time, 'HH24:MI') AS time_range,
--         a.location,
--         a.type,
--         a.status,
--         a.notes,
--         a.priority,
--         c.phone_number AS client_phone
--     FROM appointments a
--     LEFT JOIN clients c ON a.client_id = c.client_id
--     WHERE a.agent_id = p_agent_id 
--         AND a.appointment_date = v_today 
--         AND a.is_active = TRUE
--         AND a.status NOT IN ('Cancelled')
--     ORDER BY a.start_time;
    
--     -- Today's Reminders
--     RETURN QUERY
--     SELECT 
--         'reminder'::VARCHAR(20) AS activity_type,
--         r.reminder_id AS entity_id,
--         r.client_name,
--         r.title,
--         COALESCE(TO_CHAR(r.reminder_time, 'HH24:MI'), '') AS time_range,
--         ''::TEXT AS location,
--         r.reminder_type AS type,
--         r.status,
--         r.notes,
--         r.priority,
--         c.phone_number AS client_phone
--     FROM reminders r
--     LEFT JOIN clients c ON r.client_id = c.client_id
--     WHERE r.agent_id = p_agent_id 
--         AND r.reminder_date = v_today 
--         AND r.status = 'Active'
--     ORDER BY r.reminder_time;
    
--     -- Today's Birthdays
--     RETURN QUERY
--     SELECT 
--         'birthday'::VARCHAR(20) AS activity_type,
--         c.client_id AS entity_id,
--         c.first_name || ' ' || c.surname AS client_name,
--         'Birthday - ' || c.first_name || ' ' || c.surname AS title,
--         ''::VARCHAR(50) AS time_range,
--         c.address AS location,
--         'Birthday'::VARCHAR(50) AS type,
--         'Active'::VARCHAR(20) AS status,
--         'Age: ' || EXTRACT(YEAR FROM AGE(c.date_of_birth))::TEXT AS notes,
--         'Medium'::VARCHAR(10) AS priority,
--         c.phone_number AS client_phone
--     FROM clients c
--     WHERE c.agent_id = p_agent_id 
--         AND c.is_active = TRUE
--         AND EXTRACT(DAY FROM c.date_of_birth) = EXTRACT(DAY FROM v_today)
--         AND EXTRACT(MONTH FROM c.date_of_birth) = EXTRACT(MONTH FROM v_today);
-- END;
-- $$ LANGUAGE plpgsql;

-- -- Get Performance Metrics
-- CREATE OR REPLACE FUNCTION sp_get_performance_metrics(
--     p_agent_id UUID,
--     p_start_date DATE DEFAULT NULL,
--     p_end_date DATE DEFAULT NULL,
--     p_period VARCHAR(20) DEFAULT 'month'
-- )
-- RETURNS TABLE (
--     period_start DATE,
--     period_end DATE,
--     period VARCHAR(20),
--     new_clients_added BIGINT,
--     prospects_converted BIGINT,
--     total_appointments BIGINT,
--     completed_appointments BIGINT,
--     cancelled_appointments BIGINT,
--     new_policies BIGINT,
--     expired_policies BIGINT,
--     reminders_created BIGINT,
--     reminders_completed BIGINT,
--     messages_scheduled BIGINT,
--     messages_sent BIGINT
-- ) AS $$
-- DECLARE
--     v_today DATE := CURRENT_DATE;
--     v_start_date DATE;
--     v_end_date DATE;
-- BEGIN
--     -- Set default date range based on period
--     IF p_start_date IS NULL OR p_end_date IS NULL THEN
--         IF p_period = 'week' THEN
--             v_start_date := DATE_TRUNC('week', v_today)::DATE;
--             v_end_date := v_start_date + INTERVAL '6 days';
--         ELSIF p_period = 'month' THEN
--             v_start_date := DATE_TRUNC('month', v_today)::DATE;
--             v_end_date := (DATE_TRUNC('month', v_today) + INTERVAL '1 month - 1 day')::DATE;
--         ELSIF p_period = 'quarter' THEN
--             v_start_date := DATE_TRUNC('quarter', v_today)::DATE;
--             v_end_date := (DATE_TRUNC('quarter', v_today) + INTERVAL '3 months - 1 day')::DATE;
--         ELSIF p_period = 'year' THEN
--             v_start_date := DATE_TRUNC('year', v_today)::DATE;
--             v_end_date := (DATE_TRUNC('year', v_today) + INTERVAL '1 year - 1 day')::DATE;
--         END IF;
--     ELSE
--         v_start_date := p_start_date;
--         v_end_date := p_end_date;
--     END IF;
    
--     RETURN QUERY
--     SELECT 
--         v_start_date AS period_start,
--         v_end_date AS period_end,
--         p_period AS period,
        
--         -- Client Metrics
--         COUNT(DISTINCT CASE WHEN c.created_date::DATE BETWEEN v_start_date AND v_end_date THEN c.client_id END) AS new_clients_added,
--         COUNT(DISTINCT CASE WHEN c.is_client = TRUE AND c.modified_date::DATE BETWEEN v_start_date AND v_end_date THEN c.client_id END) AS prospects_converted,
        
--         -- Appointment Metrics
--         COUNT(CASE WHEN a.appointment_date BETWEEN v_start_date AND v_end_date THEN 1 END) AS total_appointments,
--         COUNT(CASE WHEN a.appointment_date BETWEEN v_start_date AND v_end_date AND a.status = 'Completed' THEN 1 END) AS completed_appointments,
--         COUNT(CASE WHEN a.appointment_date BETWEEN v_start_date AND v_end_date AND a.status = 'Cancelled' THEN 1 END) AS cancelled_appointments,
        
--         -- Policy Metrics
--         COUNT(CASE WHEN cp.created_date::DATE BETWEEN v_start_date AND v_end_date THEN 1 END) AS new_policies,
--         COUNT(CASE WHEN cp.end_date BETWEEN v_start_date AND v_end_date AND cp.status = 'Expired' THEN 1 END) AS expired_policies,
        
--         -- Reminder Metrics
--         COUNT(CASE WHEN r.created_date::DATE BETWEEN v_start_date AND v_end_date THEN 1 END) AS reminders_created,
--         COUNT(CASE WHEN r.completed_date::DATE BETWEEN v_start_date AND v_end_date THEN 1 END) AS reminders_completed,
        
--         -- Message Metrics
--         COUNT(CASE WHEN am.created_date::DATE BETWEEN v_start_date AND v_end_date THEN 1 END) AS messages_scheduled,
--         COUNT(CASE WHEN am.sent_date::DATE BETWEEN v_start_date AND v_end_date THEN 1 END) AS messages_sent
        
--     FROM clients c
--     LEFT JOIN client_policies cp ON c.client_id = cp.client_id AND cp.is_active = TRUE
--     LEFT JOIN appointments a ON c.client_id = a.client_id AND a.is_active = TRUE
--     LEFT JOIN reminders r ON c.client_id = r.client_id
--     LEFT JOIN automated_messages am ON am.agent_id = c.agent_id
--     WHERE c.agent_id = p_agent_id AND c.is_active = TRUE;
-- END;
-- $$ LANGUAGE plpgsql;

-- -- Update Dashboard Statistics Cache
-- CREATE OR REPLACE FUNCTION sp_update_dashboard_statistics(
--     p_agent_id UUID,
--     p_stat_date DATE DEFAULT NULL
-- )
-- RETURNS VOID AS $$
-- DECLARE
--     v_stat_date DATE := COALESCE(p_stat_date, CURRENT_DATE);
--     v_week_start DATE := DATE_TRUNC('week', v_stat_date)::DATE;
--     v_week_end DATE := v_week_start + INTERVAL '6 days';
--     v_month_start DATE := DATE_TRUNC('month', v_stat_date)::DATE;
--     v_month_end DATE := (DATE_TRUNC('month', v_stat_date) + INTERVAL '1 month - 1 day')::DATE;
    
--     v_total_clients INTEGER := 0;
--     v_total_prospects INTEGER := 0;
--     v_active_policies INTEGER := 0;
--     v_today_appointments INTEGER := 0;
--     v_week_appointments INTEGER := 0;
--     v_month_appointments INTEGER := 0;
--     v_completed_appointments INTEGER := 0;
--     v_pending_reminders INTEGER := 0;
--     v_today_birthdays INTEGER := 0;
--     v_expiring_policies INTEGER := 0;
-- BEGIN
--     -- Calculate client statistics
--     SELECT 
--         COUNT(CASE WHEN is_client = TRUE THEN 1 END)::INTEGER,
--         COUNT(CASE WHEN is_client = FALSE THEN 1 END)::INTEGER,
--         COUNT(CASE WHEN EXTRACT(DAY FROM date_of_birth) = EXTRACT(DAY FROM v_stat_date) 
--                    AND EXTRACT(MONTH FROM date_of_birth) = EXTRACT(MONTH FROM v_stat_date) THEN 1 END)::INTEGER
--     INTO v_total_clients, v_total_prospects, v_today_birthdays
--     FROM clients 
--     WHERE agent_id = p_agent_id AND is_active = TRUE;
    
--     -- Calculate active policies
--     SELECT COUNT(DISTINCT cp.policy_id)::INTEGER
--     INTO v_active_policies
--     FROM client_policies cp
--     INNER JOIN clients c ON cp.client_id = c.client_id
--     WHERE c.agent_id = p_agent_id AND cp.status = 'Active' AND cp.is_active = TRUE AND c.is_active = TRUE;
    
--     -- Calculate appointment statistics
--     SELECT 
--         COUNT(CASE WHEN appointment_date = v_stat_date THEN 1 END)::INTEGER,
--         COUNT(CASE WHEN appointment_date BETWEEN v_week_start AND v_week_end THEN 1 END)::INTEGER,
--         COUNT(CASE WHEN appointment_date BETWEEN v_month_start AND v_month_end THEN 1 END)::INTEGER,
--         COUNT(CASE WHEN status = 'Completed' THEN 1 END)::INTEGER
--     INTO v_today_appointments, v_week_appointments, v_month_appointments, v_completed_appointments
--     FROM appointments a
--     INNER JOIN clients c ON a.client_id = c.client_id
--     WHERE c.agent_id = p_agent_id AND a.is_active = TRUE AND c.is_active = TRUE;
    
--     -- Calculate pending reminders
--     SELECT COUNT(*)::INTEGER
--     INTO v_pending_reminders
--     FROM reminders 
--     WHERE agent_id = p_agent_id AND status = 'Active' AND reminder_date <= v_stat_date;
    
--     -- Calculate expiring policies
--     SELECT COUNT(DISTINCT cp.policy_id)::INTEGER
--     INTO v_expiring_policies
--     FROM client_policies cp
--     INNER JOIN clients c ON cp.client_id = c.client_id
--     WHERE c.agent_id = p_agent_id 
--         AND cp.status = 'Active' 
--         AND cp.end_date BETWEEN v_stat_date AND (v_stat_date + INTERVAL '30 days')
--         AND cp.is_active = TRUE AND c.is_active = TRUE;
    
--     -- Update or insert statistics
--     IF EXISTS (SELECT 1 FROM dashboard_statistics WHERE agent_id = p_agent_id AND stat_date = v_stat_date) THEN
--         UPDATE dashboard_statistics 
--         SET 
--             total_clients = v_total_clients,
--             total_prospects = v_total_prospects,
--             active_policies = v_active_policies,
--             today_appointments = v_today_appointments,
--             week_appointments = v_week_appointments,
--             month_appointments = v_month_appointments,
--             completed_appointments = v_completed_appointments,
--             pending_reminders = v_pending_reminders,
--             today_birthdays = v_today_birthdays,
--             expiring_policies = v_expiring_policies,
--             updated_date = NOW()
--         WHERE agent_id = p_agent_id AND stat_date = v_stat_date;
--     ELSE
--         INSERT INTO dashboard_statistics (
--             agent_id, stat_date, total_clients, total_prospects, active_policies,
--             today_appointments, week_appointments, month_appointments, completed_appointments,
--             pending_reminders, today_birthdays, expiring_policies
--         )
--         VALUES (
--             p_agent_id, v_stat_date, v_total_clients, v_total_prospects, v_active_policies,
--             v_today_appointments, v_week_appointments, v_month_appointments, v_completed_appointments,
--             v_pending_reminders, v_today_birthdays, v_expiring_policies
--         );
--     END IF;
-- END;
-- $$ LANGUAGE plpgsql;

-- -- Log Activity
-- CREATE OR REPLACE FUNCTION sp_log_activity(
--     p_agent_id UUID,
--     p_activity_type VARCHAR(50),
--     p_entity_type VARCHAR(50) DEFAULT NULL,
--     p_entity_id UUID DEFAULT NULL,
--     p_description VARCHAR(500),
--     p_additional_data TEXT DEFAULT NULL
-- )
-- RETURNS VOID AS $$
-- DECLARE
--     v_today DATE := CURRENT_DATE;
-- BEGIN
--     INSERT INTO activity_log (
--         agent_id, activity_type, entity_type, entity_id, description, additional_data
--     )
--     VALUES (
--         p_agent_id, p_activity_type, p_entity_type, p_entity_id, p_description, p_additional_data
--     );
    
--     -- Update performance metrics if applicable
--     IF p_activity_type IN ('client_created', 'appointment_completed', 'reminder_completed', 'policy_created') THEN
--         -- Update or create performance metrics for today
--         IF EXISTS (SELECT 1 FROM performance_metrics WHERE agent_id = p_agent_id AND metric_date = v_today) THEN
--             UPDATE performance_metrics 
--             SET 
--                 new_clients_added = new_clients_added + CASE WHEN p_activity_type = 'client_created' THEN 1 ELSE 0 END,
--                 appointments_completed = appointments_completed + CASE WHEN p_activity_type = 'appointment_completed' THEN 1 ELSE 0 END,
--                 reminders_completed = reminders_completed + CASE WHEN p_activity_type = 'reminder_completed' THEN 1 ELSE 0 END,
--                 policies_sold = policies_sold + CASE WHEN p_activity_type = 'policy_created' THEN 1 ELSE 0 END
--             WHERE agent_id = p_agent_id AND metric_date = v_today;
--         ELSE
--             INSERT INTO performance_metrics (
--                 agent_id, metric_date, new_clients_added, appointments_completed, reminders_completed, policies_sold
--             )
--             VALUES (
--                 p_agent_id, v_today,
--                 CASE WHEN p_activity_type = 'client_created' THEN 1 ELSE 0 END,
--                 CASE WHEN p_activity_type = 'appointment_completed' THEN 1 ELSE 0 END,
--                 CASE WHEN p_activity_type = 'reminder_completed' THEN 1 ELSE 0 END,
--                 CASE WHEN p_activity_type = 'policy_created' THEN 1 ELSE 0 END
--             );
--         END IF;
--     END IF;
-- END;
-- $$ LANGUAGE plpgsql;

-- -- Get Activity Log
-- CREATE OR REPLACE FUNCTION sp_get_activity_log(
--     p_agent_id UUID,
--     p_start_date DATE DEFAULT NULL,
--     p_end_date DATE DEFAULT NULL,
--     p_activity_type VARCHAR(50) DEFAULT NULL,
--     p_page_size INTEGER DEFAULT 50,
--     p_page_number INTEGER DEFAULT 1
-- )
-- RETURNS TABLE (
--     activity_id UUID,
--     activity_type VARCHAR(50),
--     entity_type VARCHAR(50),
--     entity_id UUID,
--     description VARCHAR(500),
--     activity_date TIMESTAMPTZ,
--     additional_data TEXT,
--     row_num BIGINT,
--     total_records BIGINT
-- ) AS $$
-- DECLARE
--     v_start_date DATE := COALESCE(p_start_date, CURRENT_DATE - INTERVAL '30 days');
--     v_end_date DATE := COALESCE(p_end_date, CURRENT_DATE);
--     v_offset INTEGER := (p_page_number - 1) * p_page_size;
--     v_total_records BIGINT;
-- BEGIN
--     -- Get total count first
--     SELECT COUNT(*)
--     INTO v_total_records
--     FROM activity_log
--     WHERE 
--         agent_id = p_agent_id
--         AND activity_date::DATE BETWEEN v_start_date AND v_end_date
--         AND (p_activity_type IS NULL OR activity_type = p_activity_type);
    
--     RETURN QUERY
--     SELECT 
--         al.activity_id,
--         al.activity_type,
--         al.entity_type,
--         al.entity_id,
--         al.description,
--         al.activity_date,
--         al.additional_data,
--         ROW_NUMBER() OVER (ORDER BY al.activity_date DESC) AS row_num,
--         v_total_records AS total_records
--     FROM activity_log al
--     WHERE 
--         al.agent_id = p_agent_id
--         AND al.activity_date::DATE BETWEEN v_start_date AND v_end_date
--         AND (p_activity_type IS NULL OR al.activity_type = p_activity_type)
--     ORDER BY al.activity_date DESC
--     OFFSET v_offset
--     LIMIT p_page_size;
-- END;
-- $$ LANGUAGE plpgsql;

-- -- Generate Monthly Report
-- CREATE OR REPLACE FUNCTION sp_generate_monthly_report(
--     p_agent_id UUID,
--     p_report_month DATE
-- )
-- RETURNS TABLE (
--     agent_id UUID,
--     report_month DATE,
--     total_clients_added INTEGER,
--     total_prospects_added INTEGER,
--     prospects_converted INTEGER,
--     total_appointments INTEGER,
--     completed_appointments INTEGER,
--     cancelled_appointments INTEGER,
--     total_reminders INTEGER,
--     completed_reminders INTEGER,
--     messages_sent INTEGER,
--     new_policies INTEGER,
--     renewed_policies INTEGER,
--     expired_policies INTEGER,
--     generated_date TIMESTAMPTZ
-- ) AS $$
-- DECLARE
--     v_month_start DATE := DATE_TRUNC('month', p_report_month)::DATE;
--     v_month_end DATE := (DATE_TRUNC('month', p_report_month) + INTERVAL '1 month - 1 day')::DATE;
    
--     v_total_clients_added INTEGER := 0;
--     v_total_prospects_added INTEGER := 0;
--     v_prospects_converted INTEGER := 0;
--     v_total_appointments INTEGER := 0;
--     v_completed_appointments INTEGER := 0;
--     v_cancelled_appointments INTEGER := 0;
--     v_total_reminders INTEGER := 0;
--     v_completed_reminders INTEGER := 0;
--     v_messages_sent INTEGER := 0;
--     v_new_policies INTEGER := 0;
--     v_renewed_policies INTEGER := 0;
--     v_expired_policies INTEGER := 0;
-- BEGIN
--     -- Client metrics
--     SELECT 
--         COUNT(CASE WHEN is_client = TRUE AND created_date::DATE BETWEEN v_month_start AND v_month_end THEN 1 END)::INTEGER,
--         COUNT(CASE WHEN is_client = FALSE AND created_date::DATE BETWEEN v_month_start AND v_month_end THEN 1 END)::INTEGER,
--         COUNT(CASE WHEN is_client = TRUE AND modified_date::DATE BETWEEN v_month_start AND v_month_end THEN 1 END)::INTEGER
--     INTO v_total_clients_added, v_total_prospects_added, v_prospects_converted
--     FROM clients 
--     WHERE agent_id = p_agent_id;
    
--     -- Appointment metrics
--     SELECT 
--         COUNT(*)::INTEGER,
--         COUNT(CASE WHEN status = 'Completed' THEN 1 END)::INTEGER,
--         COUNT(CASE WHEN status = 'Cancelled' THEN 1 END)::INTEGER
--     INTO v_total_appointments, v_completed_appointments, v_cancelled_appointments
--     FROM appointments a
--     INNER JOIN clients c ON a.client_id = c.client_id
--     WHERE c.agent_id = p_agent_id 
--         AND a.appointment_date BETWEEN v_month_start AND v_month_end;
    
--     -- Reminder metrics
--     SELECT 
--         COUNT(*)::INTEGER,
--         COUNT(CASE WHEN status = 'Completed' THEN 1 END)::INTEGER
--     INTO v_total_reminders, v_completed_reminders
--     FROM reminders 
--     WHERE agent_id = p_agent_id 
--         AND reminder_date BETWEEN v_month_start AND v_month_end;
    
--     -- Message metrics
--     SELECT COUNT(*)::INTEGER
--     INTO v_messages_sent
--     FROM automated_messages 
--     WHERE agent_id = p_agent_id 
--         AND sent_date::DATE BETWEEN v_month_start AND v_month_end;
    
--     -- Policy metrics
--     SELECT 
--         COUNT(CASE WHEN start_date BETWEEN v_month_start AND v_month_end THEN 1 END)::INTEGER,
--         COUNT(CASE WHEN end_date BETWEEN v_month_start AND v_month_end THEN 1 END)::INTEGER
--     INTO v_new_policies, v_expired_policies
--     FROM client_policies cp
--     INNER JOIN clients c ON cp.client_id = c.client_id
--     WHERE c.agent_id = p_agent_id;
    
--     v_renewed_policies := 0; -- This would require more complex logic to track renewals
    
--     -- Update or insert report
--     IF EXISTS (SELECT 1 FROM monthly_reports WHERE agent_id = p_agent_id AND report_month = v_month_start) THEN
--         UPDATE monthly_reports 
--         SET 
--             total_clients_added = v_total_clients_added,
--             total_prospects_added = v_total_prospects_added,
--             prospects_converted = v_prospects_converted,
--             total_appointments = v_total_appointments,
--             completed_appointments = v_completed_appointments,
--             cancelled_appointments = v_cancelled_appointments,
--             total_reminders = v_total_reminders,
--             completed_reminders = v_completed_reminders,
--             messages_sent = v_messages_sent,
--             new_policies = v_new_policies,
--             renewed_policies = v_renewed_policies,
--             expired_policies = v_expired_policies,
--             generated_date = NOW()
--         WHERE agent_id = p_agent_id AND report_month = v_month_start;
--     ELSE
--         INSERT INTO monthly_reports (
--             agent_id, report_month, total_clients_added, total_prospects_added, prospects_converted,
--             total_appointments, completed_appointments, cancelled_appointments,
--             total_reminders, completed_reminders, messages_sent,
--             new_policies, renewed_policies, expired_policies
--         )
--         VALUES (
--             p_agent_id, v_month_start, v_total_clients_added, v_total_prospects_added, v_prospects_converted,
--             v_total_appointments, v_completed_appointments, v_cancelled_appointments,
--             v_total_reminders, v_completed_reminders, v_messages_sent,
--             v_new_policies, v_renewed_policies, v_expired_policies
--         );
--     END IF;
    
--     RETURN QUERY
--     SELECT * FROM monthly_reports 
--     WHERE agent_id = p_agent_id AND report_month = v_month_start;
-- END;-- ===========================================================
-- -- Policy Service Functions
-- -- ===========================================================

-- -- Get Policy Catalog with Filters
-- CREATE OR REPLACE FUNCTION sp_get_policy_catalog(
--     p_agent_id UUID,
--     p_policy_type VARCHAR(50) DEFAULT NULL,
--     p_company_id UUID DEFAULT NULL,
--     p_company_name VARCHAR(100) DEFAULT NULL,
--     p_search_term VARCHAR(100) DEFAULT NULL,
--     p_is_active BOOLEAN DEFAULT TRUE
-- )
-- RETURNS TABLE (
--     policy_catalog_id UUID,
--     agent_id UUID,
--     policy_name VARCHAR(100),
--     policy_type VARCHAR(50),
--     company_id UUID,
--     company_name VARCHAR(100),
--     notes TEXT,
--     is_active BOOLEAN,
--     created_date TIMESTAMPTZ,
--     modified_date TIMESTAMPTZ,
--     company_active BOOLEAN
-- ) AS $$
-- BEGIN
--     RETURN QUERY
--     SELECT 
--         pc.policy_catalog_id,
--         pc.agent_id,
--         pc.policy_name,
--         pc.policy_type,
--         pc.company_id,
--         pc.company_name,
--         pc.notes,
--         pc.is_active,
--         pc.created_date,
--         pc.modified_date,
--         ic.is_active AS company_active
--     FROM policy_catalog pc
--     LEFT JOIN insurance_companies ic ON pc.company_id = ic.company_id
--     WHERE 
--         pc.agent_id = p_agent_id
--         AND (p_policy_type IS NULL OR pc.policy_type = p_policy_type)
--         AND (p_company_id IS NULL OR pc.company_id = p_company_id)
--         AND (p_company_name IS NULL OR pc.company_name ILIKE '%' || p_company_name || '%')
--         AND (p_search_term IS NULL OR pc.policy_name ILIKE '%' || p_search_term || '%')
--         AND (p_is_active IS NULL OR pc.is_active = p_is_active)
--     ORDER BY pc.policy_name ASC;
-- END;
-- $$ LANGUAGE plpgsql;

-- -- Create Policy Catalog Item
-- CREATE OR REPLACE FUNCTION sp_create_policy_catalog_item(
--     p_agent_id UUID,
--     p_policy_name VARCHAR(100),
--     p_policy_type VARCHAR(50),
--     p_company_id UUID,
--     p_notes TEXT DEFAULT NULL
-- )
-- RETURNS TABLE(policy_catalog_id UUID, error_message TEXT) AS $$
-- DECLARE
--     v_policy_catalog_id UUID := gen_random_uuid();
--     v_company_name VARCHAR(100);
-- BEGIN
--     -- Get company name
--     SELECT company_name 
--     INTO v_company_name
--     FROM insurance_companies 
--     WHERE company_id = p_company_id;
    
--     IF v_company_name IS NULL THEN
--         RETURN QUERY SELECT NULL, 'Company not found'::TEXT;
--         RETURN;
--     END IF;
    
--     INSERT INTO policy_catalog (
--         policy_catalog_id, agent_id, policy_name, policy_type, company_id, company_name, notes
--     )
--     VALUES (
--         v_policy_catalog_id, p_agent_id, p_policy_name, p_policy_type, p_company_id, v_company_name, p_notes
--     );
    
--     RETURN QUERY SELECT v_policy_catalog_id, NULL::TEXT;
-- END;
-- $$ LANGUAGE plpgsql;

-- -- Update Policy Catalog Item
-- CREATE OR REPLACE FUNCTION sp_update_policy_catalog_item(
--     p_policy_catalog_id UUID,
--     p_agent_id UUID,
--     p_policy_name VARCHAR(100) DEFAULT NULL,
--     p_policy_type VARCHAR(50) DEFAULT NULL,
--     p_company_id UUID DEFAULT NULL,
--     p_notes TEXT DEFAULT NULL,
--     p_is_active BOOLEAN DEFAULT NULL
-- )
-- RETURNS TABLE(rows_affected INTEGER, error_message TEXT) AS $$
-- DECLARE
--     v_company_name VARCHAR(100);
--     v_rows_affected INTEGER;
-- BEGIN
--     -- Get company name if company_id is provided
--     IF p_company_id IS NOT NULL THEN
--         SELECT company_name 
--         INTO v_company_name
--         FROM insurance_companies 
--         WHERE company_id = p_company_id;
        
--         IF v_company_name IS NULL THEN
--             RETURN QUERY SELECT 0, 'Company not found'::TEXT;
--             RETURN;
--         END IF;
--     END IF;
    
--     UPDATE policy_catalog 
--     SET 
--         policy_name = COALESCE(p_policy_name, policy_name),
--         policy_type = COALESCE(p_policy_type, policy_type),
--         company_id = COALESCE(p_company_id, company_id),
--         company_name = COALESCE(v_company_name, company_name),
--         notes = COALESCE(p_notes, notes),
--         is_active = COALESCE(p_is_active, is_active),
--         modified_date = NOW()
--     WHERE policy_catalog_id = p_policy_catalog_id AND agent_id = p_agent_id;
    
--     GET DIAGNOSTICS v_rows_affected = ROW_COUNT;
--     RETURN QUERY SELECT v_rows_affected, NULL::TEXT;
-- END;
-- $$ LANGUAGE plpgsql;

-- -- Delete Policy Catalog Item
-- CREATE OR REPLACE FUNCTION sp_delete_policy_catalog_item(
--     p_policy_catalog_id UUID,
--     p_agent_id UUID
-- )
-- RETURNS TABLE(rows_affected INTEGER) AS $$
-- DECLARE
--     v_rows_affected INTEGER;
-- BEGIN
--     -- Soft delete by setting is_active to FALSE
--     UPDATE policy_catalog 
--     SET 
--         is_active = FALSE,
--         modified_date = NOW()
--     WHERE policy_catalog_id = p_policy_catalog_id AND agent_id = p_agent_id;
    
--     GET DIAGNOSTICS v_rows_affected = ROW_COUNT;
--     RETURN QUERY SELECT v_rows_affected;
-- END;
-- $$ LANGUAGE plpgsql;

-- -- Get Client Policies
-- CREATE OR REPLACE FUNCTION sp_get_client_policies(
--     p_client_id UUID,
--     p_status VARCHAR(20) DEFAULT NULL,
--     p_policy_type VARCHAR(50) DEFAULT NULL
-- )
-- RETURNS TABLE (
--     policy_id UUID,
--     client_id UUID,
--     policy_name VARCHAR(100),
--     policy_type VARCHAR(50),
--     company_name VARCHAR(100),
--     status VARCHAR(20),
--     start_date DATE,
--     end_date DATE,
--     notes TEXT,
--     created_date TIMESTAMPTZ,
--     modified_date TIMESTAMPTZ,
--     is_active BOOLEAN,
--     days_until_expiry INTEGER,
--     client_name VARCHAR(255),
--     client_phone VARCHAR(20)
-- ) AS $$
-- BEGIN
--     RETURN QUERY
--     SELECT 
--         cp.policy_id,
--         cp.client_id,
--         cp.policy_name,
--         cp.policy_type,
--         cp.company_name,
--         cp.status,
--         cp.start_date,
--         cp.end_date,
--         cp.notes,
--         cp.created_date,
--         cp.modified_date,
--         cp.is_active,
--         EXTRACT(DAY FROM (cp.end_date - CURRENT_DATE))::INTEGER AS days_until_expiry,
--         c.first_name || ' ' || c.surname AS client_name,
--         c.phone_number AS client_phone
--     FROM client_policies cp
--     INNER JOIN clients c ON cp.client_id = c.client_id
--     WHERE 
--         cp.client_id = p_client_id
--         AND cp.is_active = TRUE
--         AND (p_status IS NULL OR cp.status = p_status)
--         AND (p_policy_type IS NULL OR cp.policy_type = p_policy_type)
--     ORDER BY cp.start_date DESC;
-- END;
-- $$ LANGUAGE plpgsql;

-- -- Create Client Policy
-- CREATE OR REPLACE FUNCTION sp_create_client_policy(
--     p_client_id UUID,
--     p_policy_name VARCHAR(100),
--     p_policy_type VARCHAR(50),
--     p_company_name VARCHAR(100),
--     p_status VARCHAR(20) DEFAULT 'Active',
--     p_start_date DATE,
--     p_end_date DATE,
--     p_notes TEXT DEFAULT NULL
-- )
-- RETURNS TABLE(policy_id UUID) AS $$
-- DECLARE
--     v_policy_id UUID := gen_random_uuid();
-- BEGIN
--     INSERT INTO client_policies (
--         policy_id, client_id, policy_name, policy_type, company_name, status, start_date, end_date, notes
--     )
--     VALUES (
--         v_policy_id, p_client_id, p_policy_name, p_policy_type, p_company_name, p_status, p_start_date, p_end_date, p_notes
--     );
    
--     RETURN QUERY SELECT v_policy_id;
-- END;
-- $$ LANGUAGE plpgsql;

-- -- Update Client Policy
-- CREATE OR REPLACE FUNCTION sp_update_client_policy(
--     p_policy_id UUID,
--     p_policy_name VARCHAR(100) DEFAULT NULL,
--     p_policy_type VARCHAR(50) DEFAULT NULL,
--     p_company_name VARCHAR(100) DEFAULT NULL,
--     p_status VARCHAR(20) DEFAULT NULL,
--     p_start_date DATE DEFAULT NULL,
--     p_end_date DATE DEFAULT NULL,
--     p_notes TEXT DEFAULT NULL,
--     p_is_active BOOLEAN DEFAULT NULL
-- )
-- RETURNS TABLE(rows_affected INTEGER) AS $$
-- DECLARE
--     v_rows_affected INTEGER;
-- BEGIN
--     UPDATE client_policies 
--     SET 
--         policy_name = COALESCE(p_policy_name, policy_name),
--         policy_type = COALESCE(p_policy_type, policy_type),
--         company_name = COALESCE(p_company_name, company_name),
--         status = COALESCE(p_status, status),
--         start_date = COALESCE(p_start_date, start_date),
--         end_date = COALESCE(p_end_date, end_date),
--         notes = COALESCE(p_notes, notes),
--         is_active = COALESCE(p_is_active, is_active),
--         modified_date = NOW()
--     WHERE policy_id = p_policy_id;
    
--     GET DIAGNOSTICS v_rows_affected = ROW_COUNT;
--     RETURN QUERY SELECT v_rows_affected;
-- END;
-- $$ LANGUAGE plpgsql;

-- -- Get Expiring Policies
-- CREATE OR REPLACE FUNCTION sp_get_expiring_policies(
--     p_agent_id UUID,
--     p_days_ahead INTEGER DEFAULT 30
-- )
-- RETURNS TABLE (
--     policy_id UUID,
--     client_id UUID,
--     policy_name VARCHAR(100),
--     policy_type VARCHAR(50),
--     company_name VARCHAR(100),
--     status VARCHAR(20),
--     start_date DATE,
--     end_date DATE,
--     notes TEXT,
--     client_name VARCHAR(255),
--     client_phone VARCHAR(20),
--     client_email VARCHAR(100),
--     days_until_expiry INTEGER
-- ) AS $$
-- DECLARE
--     v_start_date DATE := CURRENT_DATE;
--     v_end_date DATE := CURRENT_DATE + (p_days_ahead || ' days')::INTERVAL;
-- BEGIN
--     RETURN QUERY
--     SELECT 
--         cp.policy_id,
--         cp.client_id,
--         cp.policy_name,
--         cp.policy_type,
--         cp.company_name,
--         cp.status,
--         cp.start_date,
--         cp.end_date,
--         cp.notes,
--         c.first_name || ' ' || c.surname AS client_name,
--         c.phone_number AS client_phone,
--         c.email AS client_email,
--         EXTRACT(DAY FROM (cp.end_date - v_start_date))::INTEGER AS days_until_expiry
--     FROM client_policies cp
--     INNER JOIN clients c ON cp.client_id = c.client_id
--     WHERE 
--         c.agent_id = p_agent_id 
--         AND cp.status = 'Active'
--         AND cp.is_active = TRUE
--         AND c.is_active = TRUE
--         AND cp.end_date BETWEEN v_start_date AND v_end_date
--     ORDER BY cp.end_date ASC;
-- END;
-- $$ LANGUAGE plpgsql;

-- -- Get Policy Statistics
-- CREATE OR REPLACE FUNCTION sp_get_policy_statistics(p_agent_id UUID)
-- RETURNS TABLE (
--     total_policies BIGINT,
--     active_policies BIGINT,
--     expired_policies BIGINT,
--     lapsed_policies BIGINT,
--     inactive_policies BIGINT,
--     expiring_in_30_days BIGINT,
--     expiring_in_7_days BIGINT,
--     new_policies_this_month BIGINT,
--     motor_policies BIGINT,
--     life_policies BIGINT,
--     health_policies BIGINT,
--     travel_policies BIGINT,
--     property_policies BIGINT,
--     marine_policies BIGINT,
--     business_policies BIGINT,
--     catalog_policies BIGINT
-- ) AS $$
-- DECLARE
--     v_today DATE := CURRENT_DATE;
--     v_month_start DATE := DATE_TRUNC('month', v_today)::DATE;
--     v_month_end DATE := (DATE_TRUNC('month', v_today) + INTERVAL '1 month - 1 day')::DATE;
-- BEGIN
--     RETURN QUERY
--     SELECT 
--         -- Total Policies
--         COUNT(DISTINCT cp.policy_id) AS total_policies,
--         COUNT(DISTINCT CASE WHEN cp.status = 'Active' THEN cp.policy_id END) AS active_policies,
--         COUNT(DISTINCT CASE WHEN cp.status = 'Expired' THEN cp.policy_id END) AS expired_policies,
--         COUNT(DISTINCT CASE WHEN cp.status = 'Lapsed' THEN cp.policy_id END) AS lapsed_policies,
--         COUNT(DISTINCT CASE WHEN cp.status = 'Inactive' THEN cp.policy_id END) AS inactive_policies,
        
--         -- Expiring Soon (next 30 days)
--         COUNT(DISTINCT CASE WHEN cp.end_date BETWEEN v_today AND (v_today + INTERVAL '30 days') AND cp.status = 'Active' THEN cp.policy_id END) AS expiring_in_30_days,
--         COUNT(DISTINCT CASE WHEN cp.end_date BETWEEN v_today AND (v_today + INTERVAL '7 days') AND cp.status = 'Active' THEN cp.policy_id END) AS expiring_in_7_days,
        
--         -- New Policies This Month
--         COUNT(DISTINCT CASE WHEN cp.start_date BETWEEN v_month_start AND v_month_end THEN cp.policy_id END) AS new_policies_this_month,
        
--         -- Policies by Type
--         COUNT(DISTINCT CASE WHEN cp.policy_type = 'Motor' THEN cp.policy_id END) AS motor_policies,
--         COUNT(DISTINCT CASE WHEN cp.policy_type = 'Life' THEN cp.policy_id END) AS life_policies,
--         COUNT(DISTINCT CASE WHEN cp.policy_type = 'Health' THEN cp.policy_id END) AS health_policies,
--         COUNT(DISTINCT CASE WHEN cp.policy_type = 'Travel' THEN cp.policy_id END) AS travel_policies,
--         COUNT(DISTINCT CASE WHEN cp.policy_type = 'Property' THEN cp.policy_id END) AS property_policies,
--         COUNT(DISTINCT CASE WHEN cp.policy_type = 'Marine' THEN cp.policy_id END) AS marine_policies,
--         COUNT(DISTINCT CASE WHEN cp.policy_type = 'Business' THEN cp.policy_id END) AS business_policies,
        
--         -- Catalog Statistics
--         COUNT(DISTINCT pc.policy_catalog_id) AS catalog_policies
        
--     FROM client_policies cp
--     INNER JOIN clients c ON cp.client_id = c.client_id
--     LEFT JOIN policy_catalog pc ON pc.agent_id = c.agent_id AND pc.is_active = TRUE
--     WHERE c.agent_id = p_agent_id AND cp.is_active = TRUE AND c.is_active = TRUE;
-- END;
-- $$ LANGUAGE plpgsql;

-- -- Get Insurance Companies
-- CREATE OR REPLACE FUNCTION sp_get_insurance_companies_all(p_is_active BOOLEAN DEFAULT TRUE)
-- RETURNS TABLE (
--     company_id UUID,
--     company_name VARCHAR(100),
--     is_active BOOLEAN,
--     created_date TIMESTAMPTZ
-- ) AS $$
-- BEGIN
--     RETURN QUERY
--     SELECT 
--         ic.company_id,
--         ic.company_name,
--         ic.is_active,
--         ic.created_date
--     FROM insurance_companies ic
--     WHERE (p_is_active IS NULL OR ic.is_active = p_is_active)
--     ORDER BY ic.company_name ASC;
-- END;
-- $$ LANGUAGE plpgsql;

-- -- Get Policy Types
-- CREATE OR REPLACE FUNCTION sp_get_policy_types_all(p_is_active BOOLEAN DEFAULT TRUE)
-- RETURNS TABLE (
--     type_id UUID,
--     type_name VARCHAR(100),
--     is_active BOOLEAN,
--     created_date TIMESTAMPTZ
-- ) AS $$
-- BEGIN
--     RETURN QUERY
--     SELECT 
--         pt.type_id,
--         pt.type_name,
--         pt.is_active,
--         pt.created_date
--     FROM policy_types pt
--     WHERE (p_is_active IS NULL OR pt.is_active = p_is_active)
--     ORDER BY pt.type_name ASC;
-- END;
-- $$ LANGUAGE plpgsql;

-- -- Get Policy Templates
-- CREATE OR REPLACE FUNCTION sp_get_policy_templates(
--     p_agent_id UUID,
--     p_policy_type VARCHAR(50) DEFAULT NULL,
--     p_is_active BOOLEAN DEFAULT TRUE
-- )
-- RETURNS TABLE (
--     template_id UUID,
--     agent_id UUID,
--     template_name VARCHAR(100),
--     policy_type VARCHAR(50),
--     default_term_months INTEGER,
--     default_premium DECIMAL(10,2),
--     coverage_description TEXT,
--     terms TEXT,
--     is_active BOOLEAN,
--     created_date TIMESTAMPTZ
-- ) AS $$
-- BEGIN
--     RETURN QUERY
--     SELECT 
--         pt.template_id,
--         pt.agent_id,
--         pt.template_name,
--         pt.policy_type,
--         pt.default_term_months,
--         pt.default_premium,
--         pt.coverage_description,
--         pt.terms,
--         pt.is_active,
--         pt.created_date
--     FROM policy_templates pt
--     WHERE 
--         pt.agent_id = p_agent_id
--         AND (p_policy_type IS NULL OR pt.policy_type = p_policy_type)
--         AND (p_is_active IS NULL OR pt.is_active = p_is_active)
--     ORDER BY pt.template_name ASC;
-- END;
-- $$ LANGUAGE plpgsql;

-- -- Create Policy Template
-- CREATE OR REPLACE FUNCTION sp_create_policy_template(
--     p_agent_id UUID,
--     p_template_name VARCHAR(100),
--     p_policy_type VARCHAR(50),
--     p_default_term_months INTEGER DEFAULT NULL,
--     p_default_premium DECIMAL(10,2) DEFAULT NULL,
--     p_coverage_description TEXT DEFAULT NULL,
--     p_terms TEXT DEFAULT NULL
-- )
-- RETURNS TABLE(template_id UUID) AS $$
-- DECLARE
--     v_template_id UUID := gen_random_uuid();
-- BEGIN
--     INSERT INTO policy_templates (
--         template_id, agent_id, template_name, policy_type, default_term_months, default_premium, coverage_description, terms
--     )
--     VALUES (
--         v_template_id, p_agent_id, p_template_name, p_policy_type, p_default_term_months, p_default_premium, p_coverage_description, p_terms
--     );
    
--     RETURN QUERY SELECT v_template_id;
-- END;
-- $$ LANGUAGE plpgsql;

-- -- Validate Policy Data
-- CREATE OR REPLACE FUNCTION sp_validate_policy_data(
--     p_policy_name VARCHAR(100),
--     p_policy_type VARCHAR(50),
--     p_company_id UUID DEFAULT NULL,
--     p_start_date DATE DEFAULT NULL,
--     p_end_date DATE DEFAULT NULL
-- )
-- RETURNS TABLE(
--     is_valid BOOLEAN,
--     validation_errors TEXT
-- ) AS $$
-- DECLARE
--     v_is_valid BOOLEAN := TRUE;
--     v_validation_errors TEXT := '';
-- BEGIN
--     -- Validate Policy Name
--     IF p_policy_name IS NULL OR LENGTH(TRIM(p_policy_name)) = 0 THEN
--         v_is_valid := FALSE;
--         v_validation_errors := v_validation_errors || 'Policy name is required. ';
--     END IF;
    
--     -- Validate Policy Type
--     IF p_policy_type IS NULL OR NOT EXISTS (SELECT 1 FROM policy_types WHERE type_name = p_policy_type AND is_active = TRUE) THEN
--         v_is_valid := FALSE;
--         v_validation_errors := v_validation_errors || 'Valid policy type is required. ';
--     END IF;
    
--     -- Validate Company
--     IF p_company_id IS NOT NULL AND NOT EXISTS (SELECT 1 FROM insurance_companies WHERE company_id = p_company_id AND is_active = TRUE) THEN
--         v_is_valid := FALSE;
--         v_validation_errors := v_validation_errors || 'Valid insurance company is required. ';
--     END IF;
    
--     -- Validate Dates
--     IF p_start_date IS NOT NULL AND p_end_date IS NOT NULL AND p_start_date >= p_end_date THEN
--         v_is_valid := FALSE;
--         v_validation_errors := v_validation_errors || 'End date must be after start date. ';
--     END IF;
    
--     RETURN QUERY SELECT v_is_valid, TRIM(v_validation_errors);
-- END;
-- $$ LANGUAGE plpgsql;










-- -- ===========================================================
-- -- ===========================================================

-- -- ===========================================================
-- -- Get Appointment Statistics
-- -- ===========================================================
-- CREATE OR REPLACE FUNCTION sp_get_appointment_statistics(p_agent_id UUID)
-- RETURNS TABLE(
--     today_appointments BIGINT,
--     week_appointments BIGINT,
--     month_appointments BIGINT,
--     completed_appointments BIGINT,
--     upcoming_appointments BIGINT,
--     cancelled_appointments BIGINT
-- ) AS $$
-- DECLARE
--     v_today DATE := CURRENT_DATE;
--     v_week_start DATE := v_today - EXTRACT(DOW FROM v_today)::INTEGER;
--     v_week_end DATE := v_week_start + INTERVAL '6 days';
--     v_month_start DATE := DATE_TRUNC('month', v_today)::DATE;
--     v_month_end DATE := (DATE_TRUNC('month', v_today) + INTERVAL '1 month - 1 day')::DATE;
-- BEGIN
--     RETURN QUERY
--     SELECT 
--         COUNT(CASE WHEN appointment_date = v_today THEN 1 END) AS today_appointments,
--         COUNT(CASE WHEN appointment_date BETWEEN v_week_start AND v_week_end THEN 1 END) AS week_appointments,
--         COUNT(CASE WHEN appointment_date BETWEEN v_month_start AND v_month_end THEN 1 END) AS month_appointments,
--         COUNT(CASE WHEN status = 'Completed' THEN 1 END) AS completed_appointments,
--         COUNT(CASE WHEN status IN ('Scheduled', 'Confirmed') THEN 1 END) AS upcoming_appointments,
--         COUNT(CASE WHEN status = 'Cancelled' THEN 1 END) AS cancelled_appointments
--     FROM appointments
--     WHERE agent_id = p_agent_id AND is_active = TRUE;
-- END;
-- $$ LANGUAGE plpgsql;

-- -- ===========================================================
-- -- Get All Appointments with Filters
-- -- ===========================================================
-- CREATE OR REPLACE FUNCTION sp_get_all_appointments(
--     p_agent_id UUID,
--     p_start_date DATE DEFAULT NULL,
--     p_end_date DATE DEFAULT NULL,
--     p_status VARCHAR(20) DEFAULT NULL,
--     p_type VARCHAR(50) DEFAULT NULL,
--     p_priority VARCHAR(10) DEFAULT NULL,
--     p_client_id UUID DEFAULT NULL,
--     p_search_term VARCHAR(200) DEFAULT NULL,
--     p_page_size INTEGER DEFAULT 50,
--     p_page_number INTEGER DEFAULT 1
-- )
-- RETURNS TABLE(
--     appointment_id UUID,
--     client_id UUID,
--     client_name VARCHAR(150),
--     client_phone VARCHAR(20),
--     title VARCHAR(200),
--     description TEXT,
--     appointment_date DATE,
--     start_time TIME,
--     end_time TIME,
--     location VARCHAR(200),
--     type VARCHAR(50),
--     status VARCHAR(20),
--     priority VARCHAR(10),
--     notes TEXT,
--     reminder_set BOOLEAN,
--     created_date TIMESTAMPTZ,
--     modified_date TIMESTAMPTZ,
--     client_email VARCHAR(100),
--     client_address TEXT,
--     total_records BIGINT
-- ) AS $$
-- DECLARE
--     v_offset INTEGER := (p_page_number - 1) * p_page_size;
--     v_total_records BIGINT;
-- BEGIN
--     -- Get total count first
--     SELECT COUNT(*)
--     INTO v_total_records
--     FROM appointments a
--     WHERE a.agent_id = p_agent_id 
--         AND a.is_active = TRUE
--         AND (p_start_date IS NULL OR a.appointment_date >= p_start_date)
--         AND (p_end_date IS NULL OR a.appointment_date <= p_end_date)
--         AND (p_status IS NULL OR a.status = p_status)
--         AND (p_type IS NULL OR a.type = p_type)
--         AND (p_priority IS NULL OR a.priority = p_priority)
--         AND (p_client_id IS NULL OR a.client_id = p_client_id)
--         AND (p_search_term IS NULL OR 
--              a.client_name ILIKE '%' || p_search_term || '%' OR 
--              a.title ILIKE '%' || p_search_term || '%' OR
--              a.description ILIKE '%' || p_search_term || '%' OR
--              a.location ILIKE '%' || p_search_term || '%');

--     RETURN QUERY
--     SELECT 
--         a.appointment_id,
--         a.client_id,
--         a.client_name,
--         a.client_phone,
--         a.title,
--         a.description,
--         a.appointment_date,
--         a.start_time,
--         a.end_time,
--         a.location,
--         a.type,
--         a.status,
--         a.priority,
--         a.notes,
--         a.reminder_set,
--         a.created_date,
--         a.modified_date,
--         c.email AS client_email,
--         c.address AS client_address,
--         v_total_records
--     FROM appointments a
--     LEFT JOIN clients c ON a.client_id = c.client_id
--     WHERE a.agent_id = p_agent_id 
--         AND a.is_active = TRUE
--         AND (p_start_date IS NULL OR a.appointment_date >= p_start_date)
--         AND (p_end_date IS NULL OR a.appointment_date <= p_end_date)
--         AND (p_status IS NULL OR a.status = p_status)
--         AND (p_type IS NULL OR a.type = p_type)
--         AND (p_priority IS NULL OR a.priority = p_priority)
--         AND (p_client_id IS NULL OR a.client_id = p_client_id)
--         AND (p_search_term IS NULL OR 
--              a.client_name ILIKE '%' || p_search_term || '%' OR 
--              a.title ILIKE '%' || p_search_term || '%' OR
--              a.description ILIKE '%' || p_search_term || '%' OR
--              a.location ILIKE '%' || p_search_term || '%')
--     ORDER BY a.appointment_date DESC, a.start_time DESC
--     OFFSET v_offset
--     LIMIT p_page_size;
-- END;
-- $$ LANGUAGE plpgsql;

-- -- ===========================================================
-- -- Get Appointment By ID
-- -- ===========================================================
-- CREATE OR REPLACE FUNCTION sp_get_appointment_by_id(
--     p_appointment_id UUID,
--     p_agent_id UUID
-- )
-- RETURNS TABLE(
--     appointment_id UUID,
--     client_id UUID,
--     client_name VARCHAR(150),
--     client_phone VARCHAR(20),
--     title VARCHAR(200),
--     description TEXT,
--     appointment_date DATE,
--     start_time TIME,
--     end_time TIME,
--     location VARCHAR(200),
--     type VARCHAR(50),
--     status VARCHAR(20),
--     priority VARCHAR(10),
--     notes TEXT,
--     reminder_set BOOLEAN,
--     created_date TIMESTAMPTZ,
--     modified_date TIMESTAMPTZ,
--     client_email VARCHAR(100),
--     client_address TEXT,
--     first_name VARCHAR(50),
--     surname VARCHAR(50),
--     last_name VARCHAR(50)
-- ) AS $$
-- BEGIN
--     RETURN QUERY
--     SELECT 
--         a.appointment_id,
--         a.client_id,
--         a.client_name,
--         a.client_phone,
--         a.title,
--         a.description,
--         a.appointment_date,
--         a.start_time,
--         a.end_time,
--         a.location,
--         a.type,
--         a.status,
--         a.priority,
--         a.notes,
--         a.reminder_set,
--         a.created_date,
--         a.modified_date,
--         c.email AS client_email,
--         c.address AS client_address,
--         c.first_name,
--         c.surname,
--         c.last_name
--     FROM appointments a
--     LEFT JOIN clients c ON a.client_id = c.client_id
--     WHERE a.appointment_id = p_appointment_id 
--         AND a.agent_id = p_agent_id 
--         AND a.is_active = TRUE;
-- END;
-- $$ LANGUAGE plpgsql;

-- -- ===========================================================
-- -- Create Appointment
-- -- ===========================================================
-- CREATE OR REPLACE FUNCTION sp_create_appointment(
--     p_agent_id UUID,
--     p_client_id UUID,
--     p_title VARCHAR(200),
--     p_description TEXT DEFAULT NULL,
--     p_appointment_date DATE,
--     p_start_time TIME,
--     p_end_time TIME,
--     p_location VARCHAR(200) DEFAULT NULL,
--     p_type VARCHAR(50),
--     p_status VARCHAR(20) DEFAULT 'Scheduled',
--     p_priority VARCHAR(10) DEFAULT 'Medium',
--     p_notes TEXT DEFAULT NULL,
--     p_reminder_set BOOLEAN DEFAULT FALSE
-- )
-- RETURNS TABLE(success INTEGER, message TEXT, appointment_id UUID) AS $$
-- DECLARE
--     v_appointment_id UUID := gen_random_uuid();
--     v_client_name VARCHAR(150);
--     v_client_phone VARCHAR(20);
-- BEGIN
--     -- Validate time range
--     IF p_end_time <= p_start_time THEN
--         RETURN QUERY SELECT 0, 'End time must be after start time', NULL;
--         RETURN;
--     END IF;

--     -- Get client details
--     SELECT 
--         first_name || ' ' || surname,
--         phone_number
--     INTO v_client_name, v_client_phone
--     FROM clients 
--     WHERE client_id = p_client_id 
--       AND agent_id = p_agent_id 
--       AND is_active = TRUE;
    
--     IF v_client_name IS NULL THEN
--         RETURN QUERY SELECT 0, 'Client not found', NULL;
--         RETURN;
--     END IF;
    
--     -- Check for time conflicts
--     IF EXISTS (
--         SELECT 1 
--         FROM appointments 
--         WHERE agent_id = p_agent_id 
--           AND appointment_date = p_appointment_date
--           AND is_active = TRUE
--           AND status NOT IN ('Cancelled')
--           AND NOT (p_end_time <= start_time OR p_start_time >= end_time)
--     ) THEN
--         RETURN QUERY SELECT 0, 'Time conflict with existing appointment', NULL;
--         RETURN;
--     END IF;
    
--     -- Insert new appointment
--     INSERT INTO appointments (
--         appointment_id, client_id, agent_id, client_name, client_phone,
--         title, description, appointment_date, start_time, end_time,
--         location, type, status, priority, notes, reminder_set
--     )
--     VALUES (
--         v_appointment_id, p_client_id, p_agent_id, v_client_name, v_client_phone,
--         p_title, p_description, p_appointment_date, p_start_time, p_end_time,
--         p_location, p_type, p_status, p_priority, p_notes, p_reminder_set
--     );
    
--     RETURN QUERY SELECT 1, 'Appointment created successfully', v_appointment_id;
-- END;
-- $$ LANGUAGE plpgsql;

-- -- ===========================================================
-- -- Update Appointment
-- -- ===========================================================
-- CREATE OR REPLACE FUNCTION sp_update_appointment(
--     p_appointment_id UUID,
--     p_agent_id UUID,
--     p_title VARCHAR(200) DEFAULT NULL,
--     p_description TEXT DEFAULT NULL,
--     p_appointment_date DATE DEFAULT NULL,
--     p_start_time TIME DEFAULT NULL,
--     p_end_time TIME DEFAULT NULL,
--     p_location VARCHAR(200) DEFAULT NULL,
--     p_type VARCHAR(50) DEFAULT NULL,
--     p_priority VARCHAR(10) DEFAULT NULL,
--     p_notes TEXT DEFAULT NULL,
--     p_reminder_set BOOLEAN DEFAULT NULL
-- )
-- RETURNS TABLE(success INTEGER, message TEXT) AS $$
-- BEGIN
--     -- Check if appointment exists
--     IF NOT EXISTS (SELECT 1 FROM appointments WHERE appointment_id = p_appointment_id AND agent_id = p_agent_id AND is_active = TRUE) THEN
--         RETURN QUERY SELECT 0, 'Appointment not found';
--         RETURN;
--     END IF;
    
--     -- If updating date/time, check for conflicts
--     IF p_appointment_date IS NOT NULL AND p_start_time IS NOT NULL AND p_end_time IS NOT NULL THEN
--         IF EXISTS (
--             SELECT 1 FROM appointments 
--             WHERE agent_id = p_agent_id 
--                 AND appointment_id <> p_appointment_id
--                 AND appointment_date = p_appointment_date
--                 AND is_active = TRUE
--                 AND status NOT IN ('Cancelled')
--                 AND NOT (p_end_time <= start_time OR p_start_time >= end_time)
--         ) THEN
--             RETURN QUERY SELECT 0, 'Time conflict with existing appointment';
--             RETURN;
--         END IF;
--     END IF;
    
--     UPDATE appointments 
--     SET 
--         title = COALESCE(p_title, title),
--         description = COALESCE(p_description, description),
--         appointment_date = COALESCE(p_appointment_date, appointment_date),
--         start_time = COALESCE(p_start_time, start_time),
--         end_time = COALESCE(p_end_time, end_time),
--         location = COALESCE(p_location, location),
--         type = COALESCE(p_type, type),
--         priority = COALESCE(p_priority, priority),
--         notes = COALESCE(p_notes, notes),
--         reminder_set = COALESCE(p_reminder_set, reminder_set),
--         modified_date = NOW()
--     WHERE appointment_id = p_appointment_id AND agent_id = p_agent_id;
    
--     RETURN QUERY SELECT 1, 'Appointment updated successfully';
-- END;
-- $$ LANGUAGE plpgsql;

-- -- ===========================================================
-- -- Check Time Conflicts
-- -- ===========================================================
-- CREATE OR REPLACE FUNCTION sp_check_time_conflicts(
--     p_agent_id UUID,
--     p_appointment_date DATE,
--     p_start_time TIME,
--     p_end_time TIME,
--     p_exclude_appointment_id UUID DEFAULT NULL
-- )
-- RETURNS TABLE(has_conflict INTEGER, conflict_count BIGINT) AS $$
-- DECLARE
--     v_conflict_count BIGINT;
-- BEGIN
--     SELECT COUNT(*)
--     INTO v_conflict_count
--     FROM appointments
--     WHERE agent_id = p_agent_id
--       AND appointment_date = p_appointment_date
--       AND is_active = TRUE
--       AND status NOT IN ('Cancelled')
--       AND (p_exclude_appointment_id IS NULL OR appointment_id <> p_exclude_appointment_id)
--       AND NOT (p_end_time <= start_time OR p_start_time >= end_time);

--     RETURN QUERY
--     SELECT 
--         CASE WHEN v_conflict_count > 0 THEN 1 ELSE 0 END,
--         v_conflict_count;
-- END;
-- $$ LANGUAGE plpgsql;

-- -- ===========================================================
-- -- Get Today's Appointments
-- -- ===========================================================
-- CREATE OR REPLACE FUNCTION sp_get_today_appointments(p_agent_id UUID)
-- RETURNS TABLE(
--     appointment_id UUID,
--     client_id UUID,
--     client_name VARCHAR(150),
--     title VARCHAR(200),
--     appointment_date DATE,
--     start_time TIME,
--     end_time TIME,
--     location VARCHAR(200),
--     type VARCHAR(50),
--     status VARCHAR(20),
--     priority VARCHAR(10),
--     notes TEXT,
--     time_range TEXT
-- ) AS $$
-- BEGIN
--     RETURN QUERY
--     SELECT 
--         a.appointment_id,
--         a.client_id,
--         a.client_name,
--         a.title,
--         a.appointment_date,
--         a.start_time,
--         a.end_time,
--         a.location,
--         a.type,
--         a.status,
--         a.priority,
--         a.notes,
--         a.start_time::TEXT || ' - ' || a.end_time::TEXT AS time_range
--     FROM appointments a
--     WHERE 
--         a.agent_id = p_agent_id 
--         AND a.is_active = TRUE
--         AND a.appointment_date = CURRENT_DATE
--         AND a.status NOT IN ('Cancelled')
--     ORDER BY a.start_time;
-- END;
-- $$ LANGUAGE plpgsql;

-- -- ===========================================================
-- -- Get Week View Appointments
-- -- ===========================================================
-- CREATE OR REPLACE FUNCTION sp_get_week_view_appointments(
--     p_agent_id UUID,
--     p_week_start_date DATE DEFAULT NULL
-- )
-- RETURNS TABLE(
--     appointment_id UUID,
--     client_id UUID,
--     client_name VARCHAR(150),
--     title VARCHAR(200),
--     appointment_date DATE,
--     start_time TIME,
--     end_time TIME,
--     location VARCHAR(200),
--     type VARCHAR(50),
--     status VARCHAR(20),
--     priority VARCHAR(10),
--     day_name TEXT,
--     day_number INTEGER
-- ) AS $$
-- DECLARE
--     v_week_start_date DATE;
--     v_week_end_date DATE;
-- BEGIN
--     -- Default to current week if no date provided
--     IF p_week_start_date IS NULL THEN
--         v_week_start_date := CURRENT_DATE - EXTRACT(DOW FROM CURRENT_DATE)::INTEGER;
--     ELSE
--         v_week_start_date := p_week_start_date;
--     END IF;
    
--     v_week_end_date := v_week_start_date + INTERVAL '6 days';
    
--     RETURN QUERY
--     SELECT 
--         a.appointment_id,
--         a.client_id,
--         a.client_name,
--         a.title,
--         a.appointment_date,
--         a.start_time,
--         a.end_time,
--         a.location,
--         a.type,
--         a.status,
--         a.priority,
--         TO_CHAR(a.appointment_date, 'Day') AS day_name,
--         EXTRACT(DAY FROM a.appointment_date)::INTEGER AS day_number
--     FROM appointments a
--     WHERE 
--         a.agent_id = p_agent_id 
--         AND a.is_active = TRUE
--         AND a.appointment_date BETWEEN v_week_start_date AND v_week_end_date
--         AND a.status NOT IN ('Cancelled')
--     ORDER BY a.appointment_date, a.start_time;
-- END;
-- $$ LANGUAGE plpgsql;

-- -- ===========================================================
-- -- Get Calendar Appointments
-- -- ===========================================================
-- CREATE OR REPLACE FUNCTION sp_get_calendar_appointments(
--     p_agent_id UUID,
--     p_month INTEGER,
--     p_year INTEGER
-- )
-- RETURNS TABLE(
--     appointment_id UUID,
--     client_id UUID,
--     client_name VARCHAR(150),
--     title VARCHAR(200),
--     appointment_date DATE,
--     start_time TIME,
--     type VARCHAR(50),
--     status VARCHAR(20),
--     priority VARCHAR(10),
--     day_number INTEGER,
--     appointments_on_day BIGINT
-- ) AS $$
-- DECLARE
--     v_start_date DATE;
--     v_end_date DATE;
-- BEGIN
--     v_start_date := DATE(p_year || '-' || p_month || '-01');
--     v_end_date := (v_start_date + INTERVAL '1 month - 1 day')::DATE;
    
--     RETURN QUERY
--     SELECT 
--         a.appointment_id,
--         a.client_id,
--         a.client_name,
--         a.title,
--         a.appointment_date,
--         a.start_time,
--         a.type,
--         a.status,
--         a.priority,
--         EXTRACT(DAY FROM a.appointment_date)::INTEGER AS day_number,
--         COUNT(*) OVER (PARTITION BY a.appointment_date) AS appointments_on_day
--     FROM appointments a
--     WHERE 
--         a.agent_id = p_agent_id 
--         AND a.is_active = TRUE
--         AND a.appointment_date BETWEEN v_start_date AND v_end_date
--         AND a.status NOT IN ('Cancelled')
--     ORDER BY a.appointment_date, a.start_time;
-- END;
-- $$ LANGUAGE plpgsql;

-- -- ===========================================================
-- -- Update Appointment Status
-- -- ===========================================================
-- CREATE OR REPLACE FUNCTION sp_update_appointment_status(
--     p_appointment_id UUID,
--     p_agent_id UUID,
--     p_status VARCHAR(20)
-- )
-- RETURNS TABLE(rows_affected INTEGER) AS $$
-- DECLARE
--     v_title VARCHAR(200);
--     v_client_name VARCHAR(150);
--     v_rows_affected INTEGER;
-- BEGIN
--     -- Get appointment details for logging
--     SELECT title, client_name
--     INTO v_title, v_client_name
--     FROM appointments 
--     WHERE appointment_id = p_appointment_id;
    
--     UPDATE appointments 
--     SET status = p_status, modified_date = NOW()
--     WHERE appointment_id = p_appointment_id AND agent_id = p_agent_id;
    
--     GET DIAGNOSTICS v_rows_affected = ROW_COUNT;
    
--     -- Log activity (if you have activity_log table)
--     IF v_rows_affected > 0 THEN
--         INSERT INTO activity_log (agent_id, activity_type, entity_type, entity_id, description)
--         VALUES (p_agent_id, 'appointment_status_changed', 'appointment', p_appointment_id, 
--                 'Appointment "' || v_title || '" status changed to ' || p_status);
--     END IF;
    
--     RETURN QUERY SELECT v_rows_affected;
-- END;
-- $$ LANGUAGE plpgsql;

-- -- ===========================================================
-- -- Delete Appointment (Soft Delete)
-- -- ===========================================================
-- CREATE OR REPLACE FUNCTION sp_delete_appointment(
--     p_appointment_id UUID,
--     p_agent_id UUID
-- )
-- RETURNS TABLE(rows_affected INTEGER) AS $$
-- DECLARE
--     v_title VARCHAR(200);
--     v_client_name VARCHAR(150);
--     v_rows_affected INTEGER;
-- BEGIN
--     -- Get appointment details for logging
--     SELECT title, client_name
--     INTO v_title, v_client_name
--     FROM appointments 
--     WHERE appointment_id = p_appointment_id;
    
--     -- Soft delete
--     UPDATE appointments 
--     SET is_active = FALSE, modified_date = NOW()
--     WHERE appointment_id = p_appointment_id AND agent_id = p_agent_id;
    
--     GET DIAGNOSTICS v_rows_affected = ROW_COUNT;
    
--     -- Also update related reminders
--     IF v_rows_affected > 0 THEN
--         UPDATE reminders 
--         SET status = 'Cancelled'
--         WHERE appointment_id = p_appointment_id;
        
--         -- Log activity (if you have activity_log table)
--         INSERT INTO activity_log (agent_id, activity_type, entity_type, entity_id, description)
--         VALUES (p_agent_id, 'appointment_deleted', 'appointment', p_appointment_id, 
--                 'Appointment "' || v_title || '" deleted');
--     END IF;
    
--     RETURN QUERY SELECT v_rows_affected;
-- END;
-- $$ LANGUAGE plpgsql;

-- -- ===========================================================
-- -- Get Appointments with Filters
-- -- ===========================================================
-- CREATE OR REPLACE FUNCTION sp_get_appointments(
--     p_agent_id UUID,
--     p_date_range_filter VARCHAR(20) DEFAULT 'all',
--     p_status_filter VARCHAR(20) DEFAULT 'all',
--     p_type_filter VARCHAR(50) DEFAULT 'all',
--     p_search_term VARCHAR(100) DEFAULT NULL,
--     p_start_date DATE DEFAULT NULL,
--     p_end_date DATE DEFAULT NULL
-- )
-- RETURNS TABLE(
--     appointment_id UUID,
--     client_id UUID,
--     client_name VARCHAR(150),
--     client_phone VARCHAR(20),
--     title VARCHAR(200),
--     description TEXT,
--     appointment_date DATE,
--     start_time TIME,
--     end_time TIME,
--     location VARCHAR(200),
--     type VARCHAR(50),
--     status VARCHAR(20),
--     priority VARCHAR(10),
--     notes TEXT,
--     reminder_set BOOLEAN,
--     created_date TIMESTAMPTZ,
--     modified_date TIMESTAMPTZ,
--     computed_client_name TEXT,
--     client_email VARCHAR(100),
--     insurance_type VARCHAR(50)
-- ) AS $$
-- DECLARE
--     v_filter_start_date DATE;
--     v_filter_end_date DATE;
-- BEGIN
--     -- Calculate date range filters
--     CASE p_date_range_filter
--         WHEN 'today' THEN
--             v_filter_start_date := CURRENT_DATE;
--             v_filter_end_date := CURRENT_DATE;
--         WHEN 'week' THEN
--             v_filter_start_date := CURRENT_DATE - EXTRACT(DOW FROM CURRENT_DATE)::INTEGER;
--             v_filter_end_date := v_filter_start_date + INTERVAL '6 days';
--         WHEN 'month' THEN
--             v_filter_start_date := DATE_TRUNC('month', CURRENT_DATE)::DATE;
--             v_filter_end_date := (DATE_TRUNC('month', CURRENT_DATE) + INTERVAL '1 month - 1 day')::DATE;
--         ELSE
--             v_filter_start_date := COALESCE(p_start_date, '1900-01-01'::DATE);
--             v_filter_end_date := COALESCE(p_end_date, '2100-12-31'::DATE);
--     END CASE;
    
--     RETURN QUERY
--     SELECT 
--         a.appointment_id,
--         a.client_id,
--         a.client_name,
--         a.client_phone,
--         a.title,
--         a.description,
--         a.appointment_date,
--         a.start_time,
--         a.end_time,
--         a.location,
--         a.type,
--         a.status,
--         a.priority,
--         a.notes,
--         a.reminder_set,
--         a.created_date,
--         a.modified_date,
--         COALESCE(c.first_name || ' ' || c.surname, a.client_name) AS computed_client_name,
--         c.email AS client_email,
--         c.insurance_type
--     FROM appointments a
--     LEFT JOIN clients c ON a.client_id = c.client_id
--     WHERE 
--         a.agent_id = p_agent_id 
--         AND a.is_active = TRUE
--         AND a.appointment_date BETWEEN v_filter_start_date AND v_filter_end_date
--         AND (p_status_filter = 'all' OR a.status = p_status_filter)
--         AND (p_type_filter = 'all' OR a.type = p_type_filter)
--         AND (p_search_term IS NULL OR 
--              a.client_name ILIKE '%' || p_search_term || '%' OR
--              a.title ILIKE '%' || p_search_term || '%')
--     ORDER BY a.appointment_date DESC, a.start_time DESC;
-- END;
-- $$ LANGUAGE plpgsql;

-- -- ===========================================================
-- -- Get Appointments for Specific Date
-- -- ===========================================================
-- CREATE OR REPLACE FUNCTION sp_get_appointments_for_date(
--     p_agent_id UUID,
--     p_appointment_date DATE
-- )
-- RETURNS TABLE(
--     appointment_id UUID,
--     client_id UUID,
--     client_name VARCHAR(150),
--     client_phone VARCHAR(20),
--     title VARCHAR(200),
--     description TEXT,
--     start_time TIME,
--     end_time TIME,
--     location VARCHAR(200),
--     type VARCHAR(50),
--     status VARCHAR(20),
--     priority VARCHAR(10),
--     notes TEXT,
--     reminder_set BOOLEAN
-- ) AS $$
-- BEGIN
--     RETURN QUERY
--     SELECT 
--         a.appointment_id,
--         a.client_id,
--         a.client_name,
--         a.client_phone,
--         a.title,
--         a.description,
--         a.start_time,
--         a.end_time,
--         a.location,
--         a.type,
--         a.status,
--         a.priority,
--         a.notes,
--         a.reminder_set
--     FROM appointments a
--     WHERE a.agent_id = p_agent_id 
--         AND a.appointment_date = p_appointment_date
--         AND a.is_active = TRUE
--         AND a.status NOT IN ('Cancelled')
--     ORDER BY a.start_time;
-- END;
-- $$ LANGUAGE plpgsql;

-- -- ===========================================================
-- -- Search Appointments
-- -- ===========================================================
-- CREATE OR REPLACE FUNCTION sp_search_appointments(
--     p_agent_id UUID,
--     p_search_term VARCHAR(200)
-- )
-- RETURNS TABLE(
--     appointment_id UUID,
--     client_id UUID,
--     client_name VARCHAR(150),
--     client_phone VARCHAR(20),

--     title VARCHAR(200),
--     description TEXT,
--     appointment_date DATE,
--     start_time TIME,
--     end_time TIME,
--     location VARCHAR(200),
--     type VARCHAR(50),
--     status VARCHAR(20),
--     priority VARCHAR(10),
--     notes TEXT,
--     created_date TIMESTAMPTZ
-- ) AS $$
-- BEGIN
--     RETURN QUERY
--     SELECT 
--         a.appointment_id,
--         a.client_id,
--         a.client_name,
--         a.client_phone,
--         a.title,
--         a.description,
--         a.appointment_date,
--         a.start_time,
--         a.end_time,
--         a.location,
--         a.type,
--         a.status,
--         a.priority,
--         a.notes,
--         a.created_date
--     FROM appointments a
--     WHERE a.agent_id = p_agent_id 
--         AND a.is_active = TRUE
--         AND (
--             a.client_name ILIKE '%' || p_search_term || '%' OR 
--             a.title ILIKE '%' || p_search_term || '%' OR
--             a.description ILIKE '%' || p_search_term || '%' OR
--             a.location ILIKE '%' || p_search_term || '%' OR
--             a.type ILIKE '%' || p_search_term || '%'
--         )
--     ORDER BY a.appointment_date DESC, a.start_time DESC;
-- END;
-- $$ LANGUAGE plpgsql;





























-- -- ===========================================================
-- -- Get Policy Statistics
-- -- ===========================================================
-- CREATE OR REPLACE FUNCTION sp_get_policy_statistics(p_agent_id UUID)
-- RETURNS TABLE(
--     active_policies BIGINT,
--     expired_policies BIGINT,
--     lapsed_policies BIGINT,
--     expiring_policies BIGINT,
--     policy_types BIGINT,
--     insurance_companies BIGINT
-- ) AS $$
-- BEGIN
--     RETURN QUERY
--     SELECT 
--         COUNT(CASE WHEN cp.status = 'Active' THEN 1 END) AS active_policies,
--         COUNT(CASE WHEN cp.status = 'Expired' THEN 1 END) AS expired_policies,
--         COUNT(CASE WHEN cp.status = 'Lapsed' THEN 1 END) AS lapsed_policies,
--         COUNT(CASE WHEN cp.end_date BETWEEN CURRENT_DATE AND (CURRENT_DATE + INTERVAL '30 days') THEN 1 END) AS expiring_policies,
--         COUNT(DISTINCT pt.type_id) AS policy_types,
--         COUNT(DISTINCT ic.company_id) AS insurance_companies
--     FROM client_policy cp
--     INNER JOIN client c ON cp.client_id = c.client_id
--     LEFT JOIN policy_types pt ON cp.type_id = pt.type_id
--     LEFT JOIN insurance_companies ic ON cp.company_id = ic.company_id
--     WHERE c.agent_id = p_agent_id AND cp.is_active = TRUE AND c.is_active = TRUE;
-- END;
-- $$ LANGUAGE plpgsql;

-- -- ===========================================================
-- -- Get Policy Statistics Detailed
-- -- ===========================================================
-- CREATE OR REPLACE FUNCTION sp_get_policy_statistics_detailed(p_agent_id UUID)
-- RETURNS TABLE(
--     total_policies BIGINT,
--     active_policies BIGINT,
--     expired_policies BIGINT,
--     lapsed_policies BIGINT,
--     inactive_policies BIGINT,
--     expiring_in_30_days BIGINT,
--     expiring_in_7_days BIGINT,
--     new_policies_this_month BIGINT,
--     motor_policies BIGINT,
--     life_policies BIGINT,
--     health_policies BIGINT,
--     travel_policies BIGINT,
--     property_policies BIGINT,
--     marine_policies BIGINT,
--     business_policies BIGINT,
--     catalog_policies BIGINT,
--     policy_types BIGINT,
--     insurance_companies BIGINT
-- ) AS $$
-- DECLARE
--     v_today DATE := CURRENT_DATE;
--     v_month_start DATE := DATE_TRUNC('month', CURRENT_DATE)::DATE;
--     v_month_end DATE := (DATE_TRUNC('month', CURRENT_DATE) + INTERVAL '1 month - 1 day')::DATE;
-- BEGIN
--     RETURN QUERY
--     SELECT 
--         -- Total Policies
--         COUNT(DISTINCT cp.policy_id) AS total_policies,
--         COUNT(DISTINCT CASE WHEN cp.status = 'Active' THEN cp.policy_id END) AS active_policies,
--         COUNT(DISTINCT CASE WHEN cp.status = 'Expired' THEN cp.policy_id END) AS expired_policies,
--         COUNT(DISTINCT CASE WHEN cp.status = 'Lapsed' THEN cp.policy_id END) AS lapsed_policies,
--         COUNT(DISTINCT CASE WHEN cp.status = 'Inactive' THEN cp.policy_id END) AS inactive_policies,

--         -- Expiring Soon (next 30 days)
--         COUNT(DISTINCT CASE WHEN cp.end_date BETWEEN v_today AND (v_today + INTERVAL '30 days') 
--                              AND cp.status = 'Active' THEN cp.policy_id END) AS expiring_in_30_days,
--         COUNT(DISTINCT CASE WHEN cp.end_date BETWEEN v_today AND (v_today + INTERVAL '7 days') 
--                              AND cp.status = 'Active' THEN cp.policy_id END) AS expiring_in_7_days,

--         -- New Policies This Month
--         COUNT(DISTINCT CASE WHEN cp.start_date BETWEEN v_month_start AND v_month_end THEN cp.policy_id END) AS new_policies_this_month,

--         -- Policies by Type (using joins to get actual type names)
--         COUNT(DISTINCT CASE WHEN pt.type_name = 'Motor' THEN cp.policy_id END) AS motor_policies,
--         COUNT(DISTINCT CASE WHEN pt.type_name = 'Life' THEN cp.policy_id END) AS life_policies,
--         COUNT(DISTINCT CASE WHEN pt.type_name = 'Health' THEN cp.policy_id END) AS health_policies,
--         COUNT(DISTINCT CASE WHEN pt.type_name = 'Travel' THEN cp.policy_id END) AS travel_policies,
--         COUNT(DISTINCT CASE WHEN pt.type_name = 'Property' THEN cp.policy_id END) AS property_policies,
--         COUNT(DISTINCT CASE WHEN pt.type_name = 'Marine' THEN cp.policy_id END) AS marine_policies,
--         COUNT(DISTINCT CASE WHEN pt.type_name = 'Business' THEN cp.policy_id END) AS business_policies,

--         -- Catalog Statistics
--         COUNT(DISTINCT pc.policy_catalog_id) AS catalog_policies,
--         COUNT(DISTINCT pt.type_id) AS policy_types,
--         COUNT(DISTINCT ic.company_id) AS insurance_companies
        
--     FROM client_policy cp
--     INNER JOIN client c ON cp.client_id = c.client_id
--     LEFT JOIN policy_catalog pc ON cp.policy_catalog_id = pc.policy_catalog_id
--     LEFT JOIN policy_types pt ON cp.type_id = pt.type_id
--     LEFT JOIN insurance_companies ic ON cp.company_id = ic.company_id
--     WHERE c.agent_id = p_agent_id 
--       AND cp.is_active = TRUE 
--       AND c.is_active = TRUE;
-- END;
-- $$ LANGUAGE plpgsql;

-- -- ===========================================================
-- -- Get Expiring Policies
-- -- ===========================================================
-- CREATE OR REPLACE FUNCTION sp_get_expiring_policies(
--     p_agent_id UUID,
--     p_days_ahead INTEGER DEFAULT 30
-- )
-- RETURNS TABLE(
--     policy_id UUID,
--     client_id UUID,
--     policy_name VARCHAR(100),
--     type_name VARCHAR(100),
--     company_name VARCHAR(100),
--     status VARCHAR(20),
--     start_date DATE,
--     end_date DATE,
--     notes TEXT,
--     client_name VARCHAR(150),
--     client_phone VARCHAR(20),
--     client_email VARCHAR(100),
--     days_until_expiry INTEGER
-- ) AS $$
-- DECLARE
--     v_start_date DATE := CURRENT_DATE;
--     v_end_date DATE := CURRENT_DATE + INTERVAL '1 day' * p_days_ahead;
-- BEGIN
--     RETURN QUERY
--     SELECT 
--         cp.policy_id,
--         cp.client_id,
--         cp.policy_name,
--         pt.type_name,
--         ic.company_name,
--         cp.status,
--         cp.start_date,
--         cp.end_date,
--         cp.notes,
--         (c.first_name || ' ' || c.surname) AS client_name,
--         c.phone AS client_phone,
--         c.email AS client_email,
--         (cp.end_date - v_start_date)::INTEGER AS days_until_expiry
--     FROM client_policy cp
--     INNER JOIN client c ON cp.client_id = c.client_id
--     LEFT JOIN policy_types pt ON cp.type_id = pt.type_id
--     LEFT JOIN insurance_companies ic ON cp.company_id = ic.company_id
--     WHERE 
--         c.agent_id = p_agent_id 
--         AND cp.status = 'Active'
--         AND cp.is_active = TRUE
--         AND c.is_active = TRUE
--         AND cp.end_date BETWEEN v_start_date AND v_end_date
--     ORDER BY cp.end_date ASC;
-- END;
-- $$ LANGUAGE plpgsql;

-- -- ===========================================================
-- -- Get Expiring Policies by Period
-- -- ===========================================================
-- CREATE OR REPLACE FUNCTION sp_get_expiring_policies_by_period(
--     p_agent_id UUID DEFAULT NULL,
--     p_period VARCHAR(20)
-- )
-- RETURNS TABLE(
--     policy_id UUID,
--     client_id UUID,
--     client_name VARCHAR(150),
--     client_phone VARCHAR(20),
--     client_email VARCHAR(100),
--     policy_name VARCHAR(100),
--     policy_type VARCHAR(100),
--     company_name VARCHAR(100),
--     start_date DATE,
--     end_date DATE,
--     status VARCHAR(20),
--     notes TEXT,
--     days_until_expiry INTEGER
-- ) AS $$
-- DECLARE
--     v_days INTEGER;
-- BEGIN
--     -- Determine days based on period
--     v_days := CASE UPPER(p_period)
--                 WHEN '1D' THEN 1
--                 WHEN '1W' THEN 7
--                 WHEN '1M' THEN 30
--                 WHEN '1Y' THEN 365
--                 WHEN '2Y' THEN 730
--                 WHEN '3Y' THEN 1095
--                 ELSE NULL
--               END;

--     IF v_days IS NULL THEN
--         RAISE EXCEPTION 'Invalid period specified. Use 1D, 1W, 1M, 1Y, 2Y, or 3Y.';
--     END IF;

--     RETURN QUERY
--     SELECT 
--         cp.policy_id,
--         cp.client_id,
--         (c.first_name || ' ' || c.surname) AS client_name,
--         c.phone AS client_phone,
--         c.email AS client_email,
--         cp.policy_name,
--         pt.type_name AS policy_type,
--         ic.company_name,
--         cp.start_date,
--         cp.end_date,
--         cp.status,
--         cp.notes,
--         (cp.end_date - CURRENT_DATE)::INTEGER AS days_until_expiry
--     FROM client_policy cp
--     INNER JOIN client c ON cp.client_id = c.client_id
--     LEFT JOIN policy_types pt ON cp.type_id = pt.type_id
--     LEFT JOIN insurance_companies ic ON cp.company_id = ic.company_id
--     WHERE 
--         cp.is_active = TRUE
--         AND cp.status = 'Active'
--         AND c.is_active = TRUE
--         AND (p_agent_id IS NULL OR c.agent_id = p_agent_id)
--         AND cp.end_date BETWEEN CURRENT_DATE AND (CURRENT_DATE + INTERVAL '1 day' * v_days)
--     ORDER BY cp.end_date ASC;
-- END;
-- $$ LANGUAGE plpgsql;

-- -- ===========================================================
-- -- Get Dashboard Analytics
-- -- ===========================================================
-- CREATE OR REPLACE FUNCTION sp_get_dashboard_analytics(p_agent_id UUID)
-- RETURNS TABLE(
--     total_clients BIGINT,
--     total_prospects BIGINT,
--     active_policies BIGINT,
--     expiring_policies BIGINT,
--     today_birthdays BIGINT,
--     this_week_appointments BIGINT,
--     pending_reminders BIGINT,
--     recent_activities BIGINT,
--     policy_type_breakdown JSONB,
--     monthly_growth JSONB
-- ) AS $$
-- DECLARE
--     v_today DATE := CURRENT_DATE;
--     v_week_start DATE := DATE_TRUNC('week', CURRENT_DATE)::DATE;
--     v_week_end DATE := v_week_start + INTERVAL '6 days';
--     v_month_start DATE := DATE_TRUNC('month', CURRENT_DATE)::DATE;
--     v_last_month_start DATE := (DATE_TRUNC('month', CURRENT_DATE) - INTERVAL '1 month')::DATE;
--     v_last_month_end DATE := (DATE_TRUNC('month', CURRENT_DATE) - INTERVAL '1 day')::DATE;
-- BEGIN
--     RETURN QUERY
--     SELECT 
--         -- Basic counts
--         (SELECT COUNT(*) FROM client WHERE agent_id = p_agent_id AND is_client = TRUE AND is_active = TRUE) AS total_clients,
--         (SELECT COUNT(*) FROM client WHERE agent_id = p_agent_id AND is_client = FALSE AND is_active = TRUE) AS total_prospects,
        
--         -- Policy counts
--         (SELECT COUNT(*) FROM client_policy cp 
--          INNER JOIN client c ON cp.client_id = c.client_id 
--          WHERE c.agent_id = p_agent_id AND cp.status = 'Active' AND cp.is_active = TRUE) AS active_policies,
        
--         (SELECT COUNT(*) FROM client_policy cp 
--          INNER JOIN client c ON cp.client_id = c.client_id 
--          WHERE c.agent_id = p_agent_id AND cp.status = 'Active' AND cp.is_active = TRUE
--          AND cp.end_date BETWEEN v_today AND (v_today + INTERVAL '30 days')) AS expiring_policies,
        
--         -- Today's birthdays
--         (SELECT COUNT(*) FROM client 
--          WHERE agent_id = p_agent_id AND is_active = TRUE
--          AND EXTRACT(MONTH FROM date_of_birth) = EXTRACT(MONTH FROM v_today)
--          AND EXTRACT(DAY FROM date_of_birth) = EXTRACT(DAY FROM v_today)) AS today_birthdays,
        
--         -- This week appointments
--         (SELECT COUNT(*) FROM appointment 
--          WHERE agent_id = p_agent_id AND is_active = TRUE
--          AND appointment_date BETWEEN v_week_start AND v_week_end) AS this_week_appointments,
        
--         -- Pending reminders
--         (SELECT COUNT(*) FROM reminder 
--          WHERE agent_id = p_agent_id AND status = 'Pending'
--          AND reminder_date <= v_today) AS pending_reminders,
        
--         -- Recent activities (last 7 days)
--         (SELECT COUNT(*) FROM activity_log 
--          WHERE agent_id = p_agent_id 
--          AND created_date >= (v_today - INTERVAL '7 days')) AS recent_activities,
        
--         -- Policy type breakdown
--         (SELECT jsonb_agg(
--             jsonb_build_object(
--                 'type_name', type_name,
--                 'count', policy_count
--             )
--         )
--          FROM (
--             SELECT pt.type_name, COUNT(cp.policy_id) AS policy_count
--             FROM client_policy cp
--             INNER JOIN client c ON cp.client_id = c.client_id
--             INNER JOIN policy_types pt ON cp.type_id = pt.type_id
--             WHERE c.agent_id = p_agent_id AND cp.is_active = TRUE AND cp.status = 'Active'
--             GROUP BY pt.type_name
--             ORDER BY policy_count DESC
--          ) breakdown) AS policy_type_breakdown,
        
--         -- Monthly growth comparison
--         (SELECT jsonb_build_object(
--             'current_month_clients', current_month.count_clients,
--             'last_month_clients', last_month.count_clients,
--             'current_month_policies', current_month.count_policies,
--             'last_month_policies', last_month.count_policies
--         )
--          FROM (
--             SELECT 
--                 COUNT(CASE WHEN is_client = TRUE THEN 1 END) AS count_clients,
--                 0 AS count_policies
--             FROM client 
--             WHERE agent_id = p_agent_id AND is_active = TRUE
--             AND created_date >= v_month_start
--          ) current_month,
--          (
--             SELECT 
--                 COUNT(CASE WHEN is_client = TRUE THEN 1 END) AS count_clients,
--                 0 AS count_policies
--             FROM client 
--             WHERE agent_id = p_agent_id AND is_active = TRUE
--             AND created_date BETWEEN v_last_month_start AND v_last_month_end
--          ) last_month) AS monthly_growth;
-- END;
-- $$ LANGUAGE plpgsql;

-- -- ===========================================================
-- -- Get Client Growth Analytics
-- -- ===========================================================
-- CREATE OR REPLACE FUNCTION sp_get_client_growth_analytics(
--     p_agent_id UUID,
--     p_months INTEGER DEFAULT 12
-- )
-- RETURNS TABLE(
--     month_year VARCHAR(7),
--     new_clients BIGINT,
--     new_prospects BIGINT,
--     total_new BIGINT,
--     cumulative_clients BIGINT,
--     cumulative_prospects BIGINT
-- ) AS $$
-- DECLARE
--     v_start_date DATE := (CURRENT_DATE - INTERVAL '1 month' * p_months)::DATE;
-- BEGIN
--     RETURN QUERY
--     WITH monthly_data AS (
--         SELECT 
--             TO_CHAR(DATE_TRUNC('month', created_date), 'YYYY-MM') AS month_year,
--             COUNT(CASE WHEN is_client = TRUE THEN 1 END) AS new_clients,
--             COUNT(CASE WHEN is_client = FALSE THEN 1 END) AS new_prospects,
--             COUNT(*) AS total_new
--         FROM client
--         WHERE agent_id = p_agent_id 
--           AND is_active = TRUE
--           AND created_date >= v_start_date
--         GROUP BY DATE_TRUNC('month', created_date)
--         ORDER BY DATE_TRUNC('month', created_date)
--     )
--     SELECT 
--         md.month_year,
--         md.new_clients,
--         md.new_prospects,
--         md.total_new,
--         SUM(md.new_clients) OVER (ORDER BY md.month_year) AS cumulative_clients,
--         SUM(md.new_prospects) OVER (ORDER BY md.month_year) AS cumulative_prospects
--     FROM monthly_data md;
-- END;
-- $$ LANGUAGE plpgsql;

-- -- ===========================================================
-- -- Get Policy Performance Analytics
-- -- ===========================================================
-- CREATE OR REPLACE FUNCTION sp_get_policy_performance_analytics(
--     p_agent_id UUID,
--     p_months INTEGER DEFAULT 12
-- )
-- RETURNS TABLE(
--     policy_type VARCHAR(100),
--     active_count BIGINT,
--     expired_count BIGINT,
--     lapsed_count BIGINT,
--     renewal_rate NUMERIC(5,2),
--     avg_duration_days NUMERIC(10,2),
--     expiring_next_30_days BIGINT
-- ) AS $$
-- DECLARE
--     v_start_date DATE := (CURRENT_DATE - INTERVAL '1 month' * p_months)::DATE;
-- BEGIN
--     RETURN QUERY
--     SELECT 
--         pt.type_name AS policy_type,
--         COUNT(CASE WHEN cp.status = 'Active' THEN 1 END) AS active_count,
--         COUNT(CASE WHEN cp.status = 'Expired' THEN 1 END) AS expired_count,
--         COUNT(CASE WHEN cp.status = 'Lapsed' THEN 1 END) AS lapsed_count,
--         CASE 
--             WHEN COUNT(CASE WHEN cp.status IN ('Expired', 'Lapsed') THEN 1 END) = 0 THEN 0
--             ELSE ROUND(
--                 (COUNT(CASE WHEN cp.status = 'Active' THEN 1 END)::NUMERIC / 
--                  COUNT(CASE WHEN cp.status IN ('Active', 'Expired', 'Lapsed') THEN 1 END)::NUMERIC) * 100, 2
--             )
--         END AS renewal_rate,
--         ROUND(AVG(EXTRACT(EPOCH FROM (cp.end_date - cp.start_date)) / 86400), 2) AS avg_duration_days,
--         COUNT(CASE WHEN cp.end_date BETWEEN CURRENT_DATE AND (CURRENT_DATE + INTERVAL '30 days') 
--                    AND cp.status = 'Active' THEN 1 END) AS expiring_next_30_days
--     FROM client_policy cp
--     INNER JOIN client c ON cp.client_id = c.client_id
--     INNER JOIN policy_types pt ON cp.type_id = pt.type_id
--     WHERE c.agent_id = p_agent_id 
--       AND cp.is_active = TRUE
--       AND cp.created_date >= v_start_date
--     GROUP BY pt.type_name
--     ORDER BY active_count DESC;
-- END;
-- $$ LANGUAGE plpgsql;
-- -- ===========================================================
-- -- Dashboard Statistics Functions
-- -- ===========================================================

-- -- Get Dashboard Statistics
-- CREATE OR REPLACE FUNCTION sp_get_dashboard_stats(p_agent_id UUID)
-- RETURNS TABLE (
--     total_clients INTEGER,
--     total_policies INTEGER,
--     active_policies INTEGER,
--     expiring_policies INTEGER,
--     today_appointments INTEGER,
--     pending_reminders INTEGER,
--     today_birthdays INTEGER,
--     monthly_revenue DECIMAL(10,2)
-- ) AS $$
-- BEGIN
--     RETURN QUERY
--     SELECT 
--         (SELECT COUNT(*)::INTEGER FROM clients WHERE agent_id = p_agent_id AND is_active = TRUE),
--         (SELECT COUNT(*)::INTEGER FROM client_policies cp 
--          INNER JOIN clients c ON cp.client_id = c.client_id 
--          WHERE c.agent_id = p_agent_id AND cp.is_active = TRUE),
--         (SELECT COUNT(*)::INTEGER FROM client_policies cp 
--          INNER JOIN clients c ON cp.client_id = c.client_id 
--          WHERE c.agent_id = p_agent_id AND cp.status = 'Active' AND cp.is_active = TRUE),
--         (SELECT COUNT(*)::INTEGER FROM client_policies cp 
--          INNER JOIN clients c ON cp.client_id = c.client_id 
--          WHERE c.agent_id = p_agent_id AND cp.status = 'Active' 
--          AND cp.end_date BETWEEN CURRENT_DATE AND CURRENT_DATE + INTERVAL '30 days'),
--         (SELECT COUNT(*)::INTEGER FROM appointments a 
--          INNER JOIN clients c ON a.client_id = c.client_id 
--          WHERE c.agent_id = p_agent_id AND a.appointment_date = CURRENT_DATE 
--          AND a.status NOT IN ('Cancelled') AND a.is_active = TRUE),
--         (SELECT COUNT(*)::INTEGER FROM reminders r 
--          INNER JOIN clients c ON r.client_id = c.client_id 
--          WHERE c.agent_id = p_agent_id AND r.status = 'Active' 
--          AND r.reminder_date <= CURRENT_DATE),
--         (SELECT COUNT(*)::INTEGER FROM clients 
--          WHERE agent_id = p_agent_id AND is_active = TRUE 
--          AND EXTRACT(MONTH FROM date_of_birth) = EXTRACT(MONTH FROM CURRENT_DATE)
--          AND EXTRACT(DAY FROM date_of_birth) = EXTRACT(DAY FROM CURRENT_DATE)),
--         (SELECT COALESCE(SUM(premium_amount), 0)::DECIMAL(10,2) FROM client_policies cp 
--          INNER JOIN clients c ON cp.client_id = c.client_id 
--          WHERE c.agent_id = p_agent_id AND cp.status = 'Active' 
--          AND EXTRACT(MONTH FROM cp.created_date) = EXTRACT(MONTH FROM CURRENT_DATE)
--          AND EXTRACT(YEAR FROM cp.created_date) = EXTRACT(YEAR FROM CURRENT_DATE));
-- END;
-- $$ LANGUAGE plpgsql;

-- -- Get Recent Activities
-- CREATE OR REPLACE FUNCTION sp_get_recent_activities(
--     p_agent_id UUID,
--     p_limit INTEGER DEFAULT 10
-- )
-- RETURNS TABLE (
--     activity_id UUID,
--     activity_type VARCHAR(50),
--     entity_type VARCHAR(50),
--     entity_id UUID,
--     description TEXT,
--     activity_date TIMESTAMPTZ
-- ) AS $$
-- BEGIN
--     RETURN QUERY
--     SELECT 
--         al.activity_id,
--         al.activity_type,
--         al.entity_type,
--         al.entity_id,
--         al.description,
--         al.activity_date
--     FROM activity_log al
--     WHERE al.agent_id = p_agent_id
--     ORDER BY al.activity_date DESC
--     LIMIT p_limit;
-- END;
-- $$ LANGUAGE plpgsql;

-- -- Get Today's Appointments
-- CREATE OR REPLACE FUNCTION sp_get_today_appointments(p_agent_id UUID)
-- RETURNS TABLE (
--     appointment_id UUID,
--     client_id UUID,
--     client_name VARCHAR(150),
--     title VARCHAR(200),
--     start_time TIME,
--     end_time TIME,
--     status VARCHAR(20),
--     appointment_type VARCHAR(50),
--     notes TEXT,
--     phone_number VARCHAR(20)
-- ) AS $$
-- BEGIN
--     RETURN QUERY
--     SELECT 
--         a.appointment_id,
--         a.client_id,
--         CONCAT(c.first_name, ' ', c.surname, ' ', COALESCE(c.last_name, '')) as client_name,
--         a.title,
--         a.start_time,
--         a.end_time,
--         a.status,
--         a.appointment_type,
--         a.notes,
--         c.phone_number
--     FROM appointments a
--     INNER JOIN clients c ON a.client_id = c.client_id
--     WHERE c.agent_id = p_agent_id 
--     AND a.appointment_date = CURRENT_DATE
--     AND a.is_active = TRUE
--     ORDER BY a.start_time;
-- END;
-- $$ LANGUAGE plpgsql;

-- -- Get Expiring Policies
-- CREATE OR REPLACE FUNCTION sp_get_expiring_policies(
--     p_agent_id UUID,
--     p_days_ahead INTEGER DEFAULT 30
-- )
-- RETURNS TABLE (
--     policy_id UUID,
--     client_id UUID,
--     client_name VARCHAR(150),
--     policy_name VARCHAR(200),
--     policy_type VARCHAR(100),
--     company_name VARCHAR(100),
--     end_date DATE,
--     days_until_expiry INTEGER,
--     premium_amount DECIMAL(10,2),
--     phone_number VARCHAR(20),
--     email VARCHAR(100)
-- ) AS $$
-- BEGIN
--     RETURN QUERY
--     SELECT 
--         cp.policy_id,
--         cp.client_id,
--         CONCAT(c.first_name, ' ', c.surname, ' ', COALESCE(c.last_name, '')) as client_name,
--         cp.policy_name,
--         cp.policy_type,
--         cp.company_name,
--         cp.end_date,
--         (cp.end_date - CURRENT_DATE)::INTEGER as days_until_expiry,
--         cp.premium_amount,
--         c.phone_number,
--         c.email
--     FROM client_policies cp
--     INNER JOIN clients c ON cp.client_id = c.client_id
--     WHERE c.agent_id = p_agent_id 
--     AND cp.status = 'Active' 
--     AND cp.is_active = TRUE
--     AND cp.end_date BETWEEN CURRENT_DATE AND CURRENT_DATE + INTERVAL '1 day' * p_days_ahead
--     ORDER BY cp.end_date;
-- END;
-- $$ LANGUAGE plpgsql;

-- -- Get Today's Birthdays
-- CREATE OR REPLACE FUNCTION sp_get_today_birthdays(p_agent_id UUID)
-- RETURNS TABLE (
--     client_id UUID,
--     client_name VARCHAR(150),
--     phone_number VARCHAR(20),
--     email VARCHAR(100),
--     date_of_birth DATE,
--     age INTEGER
-- ) AS $$
-- BEGIN
--     RETURN QUERY
--     SELECT 
--         c.client_id,
--         CONCAT(c.first_name, ' ', c.surname, ' ', COALESCE(c.last_name, '')) as client_name,
--         c.phone_number,
--         c.email,
--         c.date_of_birth,
--         (EXTRACT(YEAR FROM AGE(CURRENT_DATE, c.date_of_birth)))::INTEGER as age
--     FROM clients c
--     WHERE c.agent_id = p_agent_id 
--     AND c.is_active = TRUE
--     AND EXTRACT(MONTH FROM c.date_of_birth) = EXTRACT(MONTH FROM CURRENT_DATE)
--     AND EXTRACT(DAY FROM c.date_of_birth) = EXTRACT(DAY FROM CURRENT_DATE)
--     ORDER BY c.first_name, c.surname;
-- END;
-- $$ LANGUAGE plpgsql;

-- -- ===========================================================
-- -- Performance Analytics Functions
-- -- ===========================================================

-- -- Get Monthly Performance
-- CREATE OR REPLACE FUNCTION sp_get_monthly_performance(
--     p_agent_id UUID,
--     p_year INTEGER DEFAULT NULL,
--     p_month INTEGER DEFAULT NULL
-- )
-- RETURNS TABLE (
--     month_year VARCHAR(7),
--     new_clients INTEGER,
--     new_policies INTEGER,
--     total_premium DECIMAL(10,2),
--     appointments_scheduled INTEGER,
--     appointments_completed INTEGER,
--     conversion_rate DECIMAL(5,2)
-- ) AS $$
-- DECLARE
--     v_year INTEGER := COALESCE(p_year, EXTRACT(YEAR FROM CURRENT_DATE));
--     v_month INTEGER := COALESCE(p_month, EXTRACT(MONTH FROM CURRENT_DATE));
-- BEGIN
--     RETURN QUERY
--     WITH monthly_stats AS (
--         SELECT 
--             TO_CHAR(DATE_TRUNC('month', generate_series), 'YYYY-MM') as month_year,
--             generate_series as month_start
--         FROM generate_series(
--             DATE_TRUNC('month', MAKE_DATE(v_year, GREATEST(1, v_month - 5), 1)),
--             DATE_TRUNC('month', MAKE_DATE(v_year, v_month, 1)),
--             INTERVAL '1 month'
--         )
--     )
--     SELECT 
--         ms.month_year,
--         COALESCE(client_stats.new_clients, 0)::INTEGER,
--         COALESCE(policy_stats.new_policies, 0)::INTEGER,
--         COALESCE(policy_stats.total_premium, 0)::DECIMAL(10,2),
--         COALESCE(appt_stats.scheduled, 0)::INTEGER,
--         COALESCE(appt_stats.completed, 0)::INTEGER,
--         CASE 
--             WHEN COALESCE(appt_stats.scheduled, 0) > 0 
--             THEN ROUND((COALESCE(appt_stats.completed, 0)::DECIMAL / appt_stats.scheduled) * 100, 2)
--             ELSE 0 
--         END::DECIMAL(5,2) as conversion_rate
--     FROM monthly_stats ms
--     LEFT JOIN (
--         SELECT 
--             TO_CHAR(DATE_TRUNC('month', created_date), 'YYYY-MM') as month_year,
--             COUNT(*)::INTEGER as new_clients
--         FROM clients 
--         WHERE agent_id = p_agent_id 
--         AND is_active = TRUE
--         GROUP BY DATE_TRUNC('month', created_date)
--     ) client_stats ON ms.month_year = client_stats.month_year
--     LEFT JOIN (
--         SELECT 
--             TO_CHAR(DATE_TRUNC('month', cp.created_date), 'YYYY-MM') as month_year,
--             COUNT(*)::INTEGER as new_policies,
--             SUM(cp.premium_amount)::DECIMAL(10,2) as total_premium
--         FROM client_policies cp
--         INNER JOIN clients c ON cp.client_id = c.client_id
--         WHERE c.agent_id = p_agent_id 
--         AND cp.is_active = TRUE
--         GROUP BY DATE_TRUNC('month', cp.created_date)
--     ) policy_stats ON ms.month_year = policy_stats.month_year
--     LEFT JOIN (
--         SELECT 
--             TO_CHAR(DATE_TRUNC('month', a.appointment_date), 'YYYY-MM') as month_year,
--             COUNT(*)::INTEGER as scheduled,
--             COUNT(CASE WHEN a.status = 'Completed' THEN 1 END)::INTEGER as completed
--         FROM appointments a
--         INNER JOIN clients c ON a.client_id = c.client_id
--         WHERE c.agent_id = p_agent_id 
--         AND a.is_active = TRUE
--         GROUP BY DATE_TRUNC('month', a.appointment_date)
--     ) appt_stats ON ms.month_year = appt_stats.month_year
--     ORDER BY ms.month_year;
-- END;
-- $$ LANGUAGE plpgsql;

-- -- Get Policy Distribution
-- CREATE OR REPLACE FUNCTION sp_get_policy_distribution(p_agent_id UUID)
-- RETURNS TABLE (
--     policy_type VARCHAR(100),
--     policy_count INTEGER,
--     total_premium DECIMAL(10,2),
--     percentage DECIMAL(5,2)
-- ) AS $$
-- BEGIN
--     RETURN QUERY
--     WITH policy_totals AS (
--         SELECT 
--             cp.policy_type,
--             COUNT(*)::INTEGER as policy_count,
--             SUM(cp.premium_amount)::DECIMAL(10,2) as total_premium
--         FROM client_policies cp
--         INNER JOIN clients c ON cp.client_id = c.client_id
--         WHERE c.agent_id = p_agent_id 
--         AND cp.status = 'Active' 
--         AND cp.is_active = TRUE
--         GROUP BY cp.policy_type
--     ),
--     grand_total AS (
--         SELECT SUM(policy_count) as total_count
--         FROM policy_totals
--     )
--     SELECT 
--         pt.policy_type,
--         pt.policy_count,
--         pt.total_premium,
--         CASE 
--             WHEN gt.total_count > 0 
--             THEN ROUND((pt.policy_count::DECIMAL / gt.total_count) * 100, 2)
--             ELSE 0 
--         END::DECIMAL(5,2) as percentage
--     FROM policy_totals pt
--     CROSS JOIN grand_total gt
--     ORDER BY pt.policy_count DESC;
-- END;
-- $$ LANGUAGE plpgsql;

-- -- Get Client Demographics
-- CREATE OR REPLACE FUNCTION sp_get_client_demographics(p_agent_id UUID)
-- RETURNS TABLE (
--     age_group VARCHAR(20),
--     client_count INTEGER,
--     percentage DECIMAL(5,2)
-- ) AS $$
-- BEGIN
--     RETURN QUERY
--     WITH age_groups AS (
--         SELECT 
--             CASE 
--                 WHEN EXTRACT(YEAR FROM AGE(CURRENT_DATE, date_of_birth)) < 25 THEN '18-24'
--                 WHEN EXTRACT(YEAR FROM AGE(CURRENT_DATE, date_of_birth)) < 35 THEN '25-34'
--                 WHEN EXTRACT(YEAR FROM AGE(CURRENT_DATE, date_of_birth)) < 45 THEN '35-44'
--                 WHEN EXTRACT(YEAR FROM AGE(CURRENT_DATE, date_of_birth)) < 55 THEN '45-54'
--                 WHEN EXTRACT(YEAR FROM AGE(CURRENT_DATE, date_of_birth)) < 65 THEN '55-64'
--                 ELSE '65+'
--             END as age_group,
--             COUNT(*)::INTEGER as client_count
--         FROM clients 
--         WHERE agent_id = p_agent_id 
--         AND is_active = TRUE
--         AND date_of_birth IS NOT NULL
--         GROUP BY 
--             CASE 
--                 WHEN EXTRACT(YEAR FROM AGE(CURRENT_DATE, date_of_birth)) < 25 THEN '18-24'
--                 WHEN EXTRACT(YEAR FROM AGE(CURRENT_DATE, date_of_birth)) < 35 THEN '25-34'
--                 WHEN EXTRACT(YEAR FROM AGE(CURRENT_DATE, date_of_birth)) < 45 THEN '35-44'
--                 WHEN EXTRACT(YEAR FROM AGE(CURRENT_DATE, date_of_birth)) < 55 THEN '45-54'
--                 WHEN EXTRACT(YEAR FROM AGE(CURRENT_DATE, date_of_birth)) < 65 THEN '55-64'
--                 ELSE '65+'
--             END
--     ),
--     total_clients AS (
--         SELECT SUM(client_count) as total_count
--         FROM age_groups
--     )
--     SELECT 
--         ag.age_group,
--         ag.client_count,
--         CASE 
--             WHEN tc.total_count > 0 
--             THEN ROUND((ag.client_count::DECIMAL / tc.total_count) * 100, 2)
--             ELSE 0 
--         END::DECIMAL(5,2) as percentage
--     FROM age_groups ag
--     CROSS JOIN total_clients tc
--     ORDER BY 
--         CASE ag.age_group
--             WHEN '18-24' THEN 1
--             WHEN '25-34' THEN 2
--             WHEN '35-44' THEN 3
--             WHEN '45-54' THEN 4
--             WHEN '55-64' THEN 5
--             WHEN '65+' THEN 6
--         END;
-- END;
-- $$ LANGUAGE plpgsql;

-- -- ===========================================================
-- -- Revenue Analytics Functions
-- -- ===========================================================

-- -- Get Revenue Summary
-- CREATE OR REPLACE FUNCTION sp_get_revenue_summary(
--     p_agent_id UUID,
--     p_start_date DATE DEFAULT NULL,
--     p_end_date DATE DEFAULT NULL
-- )
-- RETURNS TABLE (
--     total_revenue DECIMAL(10,2),
--     monthly_revenue DECIMAL(10,2),
--     average_policy_value DECIMAL(10,2),
--     highest_value_policy DECIMAL(10,2),
--     policy_count INTEGER,
--     growth_rate DECIMAL(5,2)
-- ) AS $$
-- DECLARE
--     v_start_date DATE := COALESCE(p_start_date, CURRENT_DATE - INTERVAL '1 year');
--     v_end_date DATE := COALESCE(p_end_date, CURRENT_DATE);
--     v_prev_period_start DATE := v_start_date - (v_end_date - v_start_date);
--     v_prev_period_end DATE := v_start_date;
-- BEGIN
--     RETURN QUERY
--     WITH current_period AS (
--         SELECT 
--             SUM(cp.premium_amount) as total_revenue,
--             COUNT(*) as policy_count,
--             AVG(cp.premium_amount) as avg_premium,
--             MAX(cp.premium_amount) as max_premium
--         FROM client_policies cp
--         INNER JOIN clients c ON cp.client_id = c.client_id
--         WHERE c.agent_id = p_agent_id 
--         AND cp.created_date BETWEEN v_start_date AND v_end_date
--         AND cp.is_active = TRUE
--     ),
--     previous_period AS (
--         SELECT 
--             COALESCE(SUM(cp.premium_amount), 0) as prev_total_revenue
--         FROM client_policies cp
--         INNER JOIN clients c ON cp.client_id = c.client_id
--         WHERE c.agent_id = p_agent_id 
--         AND cp.created_date BETWEEN v_prev_period_start AND v_prev_period_end
--         AND cp.is_active = TRUE
--     )
--     SELECT 
--         COALESCE(cp.total_revenue, 0)::DECIMAL(10,2) as total_revenue,
--         ROUND(COALESCE(cp.total_revenue, 0) / 
--               EXTRACT(MONTHS FROM AGE(v_end_date, v_start_date)), 2)::DECIMAL(10,2) as monthly_revenue,
--         COALESCE(cp.avg_premium, 0)::DECIMAL(10,2) as average_policy_value,
--         COALESCE(cp.max_premium, 0)::DECIMAL(10,2) as highest_value_policy,
--         COALESCE(cp.policy_count, 0)::INTEGER as policy_count,
--         CASE 
--             WHEN pp.prev_total_revenue > 0 AND cp.total_revenue IS NOT NULL
--             THEN ROUND(((cp.total_revenue - pp.prev_total_revenue) / pp.prev_total_revenue) * 100, 2)
--             ELSE 0 
--         END::DECIMAL(5,2) as growth_rate
--     FROM current_period cp
--     CROSS JOIN previous_period pp;
-- END;
-- $$ LANGUAGE plpgsql;

-- -- Get Monthly Revenue Trend
-- CREATE OR REPLACE FUNCTION sp_get_monthly_revenue_trend(
--     p_agent_id UUID,
--     p_months INTEGER DEFAULT 12
-- )
-- RETURNS TABLE (
--     month_year VARCHAR(7),
--     revenue DECIMAL(10,2),
--     policy_count INTEGER,
--     avg_policy_value DECIMAL(10,2)
-- ) AS $$
-- BEGIN
--     RETURN QUERY
--     WITH monthly_series AS (
--         SELECT 
--             TO_CHAR(DATE_TRUNC('month', generate_series), 'YYYY-MM') as month_year,
--             generate_series as month_start
--         FROM generate_series(
--             DATE_TRUNC('month', CURRENT_DATE - INTERVAL '1 month' * (p_months - 1)),
--             DATE_TRUNC('month', CURRENT_DATE),
--             INTERVAL '1 month'
--         )
--     )
--     SELECT 
--         ms.month_year,
--         COALESCE(rev.revenue, 0)::DECIMAL(10,2),
--         COALESCE(rev.policy_count, 0)::INTEGER,
--         COALESCE(rev.avg_policy_value, 0)::DECIMAL(10,2)
--     FROM monthly_series ms
--     LEFT JOIN (
--         SELECT 
--             TO_CHAR(DATE_TRUNC('month', cp.created_date), 'YYYY-MM') as month_year,
--             SUM(cp.premium_amount)::DECIMAL(10,2) as revenue,
--             COUNT(*)::INTEGER as policy_count,
--             AVG(cp.premium_amount)::DECIMAL(10,2) as avg_policy_value
--         FROM client_policies cp
--         INNER JOIN clients c ON cp.client_id = c.client_id
--         WHERE c.agent_id = p_agent_id 
--         AND cp.is_active = TRUE
--         GROUP BY DATE_TRUNC('month', cp.created_date)
--     ) rev ON ms.month_year = rev.month_year
--     ORDER BY ms.month_year;
-- END;
-- $$ LANGUAGE plpgsql;

-- -- ===========================================================
-- -- Appointment Analytics Functions
-- -- ===========================================================

-- -- Get Appointment Statistics
-- CREATE OR REPLACE FUNCTION sp_get_appointment_stats(
--     p_agent_id UUID,
--     p_start_date DATE DEFAULT NULL,
--     p_end_date DATE DEFAULT NULL
-- )
-- RETURNS TABLE (
--     total_appointments INTEGER,
--     completed_appointments INTEGER,
--     cancelled_appointments INTEGER,
--     rescheduled_appointments INTEGER,
--     completion_rate DECIMAL(5,2),
--     most_common_type VARCHAR(50),
--     busiest_day_of_week VARCHAR(10)
-- ) AS $$
-- DECLARE
--     v_start_date DATE := COALESCE(p_start_date, CURRENT_DATE - INTERVAL '30 days');
--     v_end_date DATE := COALESCE(p_end_date, CURRENT_DATE);
-- BEGIN
--     RETURN QUERY
--     WITH appointment_stats AS (
--         SELECT 
--             COUNT(*) as total_appointments,
--             COUNT(CASE WHEN a.status = 'Completed' THEN 1 END) as completed_appointments,
--             COUNT(CASE WHEN a.status = 'Cancelled' THEN 1 END) as cancelled_appointments,
--             COUNT(CASE WHEN a.status = 'Rescheduled' THEN 1 END) as rescheduled_appointments
--         FROM appointments a
--         INNER JOIN clients c ON a.client_id = c.client_id
--         WHERE c.agent_id = p_agent_id 
--         AND a.appointment_date BETWEEN v_start_date AND v_end_date
--         AND a.is_active = TRUE
--     ),
--     common_type AS (
--         SELECT a.appointment_type
--         FROM appointments a
--         INNER JOIN clients c ON a.client_id = c.client_id
--         WHERE c.agent_id = p_agent_id 
--         AND a.appointment_date BETWEEN v_start_date AND v_end_date
--         AND a.is_active = TRUE
--         GROUP BY a.appointment_type
--         ORDER BY COUNT(*) DESC
--         LIMIT 1
--     ),
--     busiest_day AS (
--         SELECT TO_CHAR(a.appointment_date, 'Day') as day_of_week
--         FROM appointments a
--         INNER JOIN clients c ON a.client_id = c.client_id
--         WHERE c.agent_id = p_agent_id 
--         AND a.appointment_date BETWEEN v_start_date AND v_end_date
--         AND a.is_active = TRUE
--         GROUP BY TO_CHAR(a.appointment_date, 'Day'), EXTRACT(DOW FROM a.appointment_date)
--         ORDER BY COUNT(*) DESC, EXTRACT(DOW FROM a.appointment_date)
--         LIMIT 1
--     )
--     SELECT 
--         ast.total_appointments::INTEGER,
--         ast.completed_appointments::INTEGER,
--         ast.cancelled_appointments::INTEGER,
--         ast.rescheduled_appointments::INTEGER,
--         CASE 
--             WHEN ast.total_appointments > 0 
--             THEN ROUND((ast.completed_appointments::DECIMAL / ast.total_appointments) * 100, 2)
--             ELSE 0 
--         END::DECIMAL(5,2) as completion_rate,
--         COALESCE(ct.appointment_type, 'N/A')::VARCHAR(50) as most_common_type,
--         COALESCE(TRIM(bd.day_of_week), 'N/A')::VARCHAR(10) as busiest_day_of_week
--     FROM appointment_stats ast
--     LEFT JOIN common_type ct ON TRUE
--     LEFT JOIN busiest_day bd ON TRUE;
-- END;
-- $$ LANGUAGE plpgsql;

-- -- ===========================================================
-- -- Reminder Analytics Functions  
-- -- ===========================================================

-- -- Get Reminder Statistics
-- CREATE OR REPLACE FUNCTION sp_get_reminder_stats(p_agent_id UUID)
-- RETURNS TABLE (
--     total_reminders INTEGER,
--     active_reminders INTEGER,
--     completed_reminders INTEGER,
--     overdue_reminders INTEGER,
--     reminder_types JSONB
-- ) AS $$
-- BEGIN
--     RETURN QUERY
--     WITH reminder_stats AS (
--         SELECT 
--             COUNT(*) as total_reminders,
--             COUNT(CASE WHEN r.status = 'Active' THEN 1 END) as active_reminders,
--             COUNT(CASE WHEN r.status = 'Completed' THEN 1 END) as completed_reminders,
--             COUNT(CASE WHEN r.status = 'Active' AND r.reminder_date < CURRENT_DATE THEN 1 END) as overdue_reminders
--         FROM reminders r
--         INNER JOIN clients c ON r.client_id = c.client_id
--         WHERE c.agent_id = p_agent_id
--     ),
--     reminder_type_stats AS (
--         SELECT jsonb_agg(
--             jsonb_build_object(
--                 'type', r.reminder_type,
--                 'count', type_counts.type_count
--             )
--         ) as reminder_types
--         FROM (
--             SELECT 
--                 r.reminder_type,
--                 COUNT(*) as type_count
--             FROM reminders r
--             INNER JOIN clients c ON r.client_id = c.client_id
--             WHERE c.agent_id = p_agent_id
--             GROUP BY r.reminder_type
--         ) type_counts
--         JOIN reminders r ON r.reminder_type = type_counts.reminder_type
--         GROUP BY TRUE
--     )
--     SELECT 
--         rs.total_reminders::INTEGER,
--         rs.active_reminders::INTEGER,
--         rs.completed_reminders::INTEGER,
--         rs.overdue_reminders::INTEGER,
--         COALESCE(rts.reminder_types, '[]'::JSONB) as reminder_types
--     FROM reminder_stats rs
--     LEFT JOIN reminder_type_stats rts ON TRUE;
-- END;
-- $$ LANGUAGE plpgsql;


-- -- ============================================
-- -- Aminius Insurance Management System
-- -- PostgreSQL Functions for Policy Management
-- -- ============================================

-- -- ============================================
-- -- POLICY CATALOG FUNCTIONS
-- -- ============================================

-- -- Get Policy Catalog
-- CREATE OR REPLACE FUNCTION sp_get_policy_catalog(
--     p_agent_id UUID DEFAULT NULL,
--     p_company_id UUID DEFAULT NULL,
--     p_category_id UUID DEFAULT NULL,
--     p_type_id UUID DEFAULT NULL,
--     p_is_active BOOLEAN DEFAULT TRUE
-- )
-- RETURNS TABLE (
--     policy_catalog_id UUID,
--     agent_id UUID,
--     policy_name VARCHAR(100),
--     company_id UUID,
--     company_name VARCHAR(100),
--     notes TEXT,
--     is_active BOOLEAN,
--     created_date TIMESTAMPTZ,
--     modified_date TIMESTAMPTZ,
--     category_id UUID,
--     category_name VARCHAR(100),
--     type_id UUID,
--     type_name VARCHAR(100)
-- ) AS $$
-- BEGIN
--     RETURN QUERY
--     SELECT 
--         pc.policy_catalog_id,
--         pc.agent_id,
--         pc.policy_name,
--         pc.company_id,
--         ic.company_name,
--         pc.notes,
--         pc.is_active,
--         pc.created_date,
--         pc.modified_date,
--         pc.category_id,
--         pcat.category_name,
--         pc.type_id,
--         pt.type_name
--     FROM policy_catalog pc
--         LEFT JOIN insurance_companies ic ON pc.company_id = ic.company_id
--         LEFT JOIN policy_categories pcat ON pc.category_id = pcat.category_id
--         LEFT JOIN policy_types pt ON pc.type_id = pt.type_id
--     WHERE (p_agent_id IS NULL OR pc.agent_id = p_agent_id)
--         AND (p_company_id IS NULL OR pc.company_id = p_company_id)
--         AND (p_category_id IS NULL OR pc.category_id = p_category_id)
--         AND (p_type_id IS NULL OR pc.type_id = p_type_id)
--         AND (p_is_active IS NULL OR pc.is_active = p_is_active)
--     ORDER BY pc.policy_name;
-- END;
-- $$ LANGUAGE plpgsql;

-- -- Create Policy Catalog Item
-- CREATE OR REPLACE FUNCTION sp_create_policy_catalog_item(
--     p_agent_id UUID,
--     p_policy_name VARCHAR(100),
--     p_company_id UUID,
--     p_notes TEXT DEFAULT NULL,
--     p_category_id UUID DEFAULT NULL,
--     p_type_id UUID DEFAULT NULL
-- )
-- RETURNS TABLE(policy_catalog_id UUID) AS $$
-- DECLARE
--     v_policy_catalog_id UUID := gen_random_uuid();
-- BEGIN
--     INSERT INTO policy_catalog (
--         policy_catalog_id, agent_id, policy_name, company_id, 
--         notes, category_id, type_id, is_active, created_date
--     )
--     VALUES (
--         v_policy_catalog_id, p_agent_id, p_policy_name, p_company_id,
--         p_notes, p_category_id, p_type_id, TRUE, NOW()
--     );
    
--     RETURN QUERY SELECT v_policy_catalog_id;
-- END;
-- $$ LANGUAGE plpgsql;

-- -- Update Policy Catalog Item
-- CREATE OR REPLACE FUNCTION sp_update_policy_catalog_item(
--     p_policy_catalog_id UUID,
--     p_policy_name VARCHAR(100) DEFAULT NULL,
--     p_company_id UUID DEFAULT NULL,
--     p_notes TEXT DEFAULT NULL,
--     p_category_id UUID DEFAULT NULL,
--     p_type_id UUID DEFAULT NULL,
--     p_is_active BOOLEAN DEFAULT NULL
-- )
-- RETURNS TABLE(rows_affected INTEGER) AS $$
-- DECLARE
--     v_rows_affected INTEGER;
-- BEGIN
--     UPDATE policy_catalog
--     SET 
--         policy_name = COALESCE(p_policy_name, policy_name),
--         company_id = COALESCE(p_company_id, company_id),
--         notes = COALESCE(p_notes, notes),
--         category_id = COALESCE(p_category_id, category_id),
--         type_id = COALESCE(p_type_id, type_id),
--         is_active = COALESCE(p_is_active, is_active),
--         modified_date = NOW()
--     WHERE policy_catalog_id = p_policy_catalog_id;
    
--     GET DIAGNOSTICS v_rows_affected = ROW_COUNT;
--     RETURN QUERY SELECT v_rows_affected;
-- END;
-- $$ LANGUAGE plpgsql;

-- -- Delete Policy Catalog Item
-- CREATE OR REPLACE FUNCTION sp_delete_policy_catalog_item(
--     p_policy_catalog_id UUID,
--     p_hard_delete BOOLEAN DEFAULT FALSE
-- )
-- RETURNS TABLE(rows_affected INTEGER) AS $$
-- DECLARE
--     v_rows_affected INTEGER;
-- BEGIN
--     IF p_hard_delete = TRUE THEN
--         DELETE FROM policy_catalog WHERE policy_catalog_id = p_policy_catalog_id;
--     ELSE
--         UPDATE policy_catalog 
--         SET is_active = FALSE, modified_date = NOW()
--         WHERE policy_catalog_id = p_policy_catalog_id;
--     END IF;
    
--     GET DIAGNOSTICS v_rows_affected = ROW_COUNT;
--     RETURN QUERY SELECT v_rows_affected;
-- END;
-- $$ LANGUAGE plpgsql;

-- -- Upsert Policy Catalog
-- CREATE OR REPLACE FUNCTION sp_upsert_policy_catalog(
--     p_policy_catalog_id UUID DEFAULT NULL,
--     p_agent_id UUID,
--     p_policy_name VARCHAR(100),
--     p_company_id UUID,
--     p_notes TEXT DEFAULT NULL,
--     p_category_id UUID DEFAULT NULL,
--     p_type_id UUID DEFAULT NULL
-- )
-- RETURNS TABLE(policy_catalog_id UUID) AS $$
-- DECLARE
--     v_policy_catalog_id UUID;
-- BEGIN
--     IF p_policy_catalog_id IS NULL OR NOT EXISTS (SELECT 1 FROM policy_catalog WHERE policy_catalog_id = p_policy_catalog_id) THEN
--         -- Insert new record
--         v_policy_catalog_id := gen_random_uuid();
--         INSERT INTO policy_catalog (
--             policy_catalog_id, agent_id, policy_name, company_id, 
--             notes, category_id, type_id, is_active, created_date
--         )
--         VALUES (
--             v_policy_catalog_id, p_agent_id, p_policy_name, p_company_id,
--             p_notes, p_category_id, p_type_id, TRUE, NOW()
--         );
--     ELSE
--         -- Update existing record
--         v_policy_catalog_id := p_policy_catalog_id;
--         UPDATE policy_catalog
--         SET 
--             policy_name = p_policy_name,
--             company_id = p_company_id,
--             notes = p_notes,
--             category_id = p_category_id,
--             type_id = p_type_id,
--             modified_date = NOW()
--         WHERE policy_catalog_id = p_policy_catalog_id;
--     END IF;
    
--     RETURN QUERY SELECT v_policy_catalog_id;
-- END;
-- $$ LANGUAGE plpgsql;

-- -- ============================================
-- -- CLIENT POLICIES FUNCTIONS
-- -- ============================================

-- -- Get Client Policies
-- CREATE OR REPLACE FUNCTION sp_get_client_policies(
--     p_client_id UUID DEFAULT NULL,
--     p_agent_id UUID DEFAULT NULL,
--     p_status VARCHAR(20) DEFAULT NULL,
--     p_is_active BOOLEAN DEFAULT TRUE
-- )
-- RETURNS TABLE (
--     policy_id UUID,
--     client_id UUID,
--     policy_name VARCHAR(100),
--     status VARCHAR(20),
--     start_date DATE,
--     end_date DATE,
--     notes TEXT,
--     created_date TIMESTAMPTZ,
--     modified_date TIMESTAMPTZ,
--     is_active BOOLEAN,
--     policy_catalog_id UUID,
--     catalog_policy_name VARCHAR(100),
--     type_id UUID,
--     type_name VARCHAR(100),
--     company_id UUID,
--     company_name VARCHAR(100),
--     days_until_expiry INTEGER
-- ) AS $$
-- BEGIN
--     RETURN QUERY
--     SELECT 
--         cp.policy_id,
--         cp.client_id,
--         cp.policy_name,
--         cp.status,
--         cp.start_date,
--         cp.end_date,
--         cp.notes,
--         cp.created_date,
--         cp.modified_date,
--         cp.is_active,
--         cp.policy_catalog_id,
--         pc.policy_name as catalog_policy_name,
--         cp.type_id,
--         pt.type_name,
--         cp.company_id,
--         ic.company_name,
--         EXTRACT(DAYS FROM (cp.end_date - CURRENT_DATE))::INTEGER as days_until_expiry
--     FROM client_policies cp
--         LEFT JOIN policy_catalog pc ON cp.policy_catalog_id = pc.policy_catalog_id
--         LEFT JOIN policy_types pt ON cp.type_id = pt.type_id
--         LEFT JOIN insurance_companies ic ON cp.company_id = ic.company_id
--     WHERE (p_client_id IS NULL OR cp.client_id = p_client_id)
--         AND (p_agent_id IS NULL OR pc.agent_id = p_agent_id)
--         AND (p_status IS NULL OR cp.status = p_status)
--         AND (p_is_active IS NULL OR cp.is_active = p_is_active)
--     ORDER BY cp.end_date DESC;
-- END;
-- $$ LANGUAGE plpgsql;

-- -- Get Policy By ID
-- CREATE OR REPLACE FUNCTION sp_get_policy_by_id(p_policy_id UUID)
-- RETURNS TABLE (
--     policy_id UUID,
--     client_id UUID,
--     policy_name VARCHAR(100),
--     status VARCHAR(20),
--     start_date DATE,
--     end_date DATE,
--     notes TEXT,
--     created_date TIMESTAMPTZ,
--     modified_date TIMESTAMPTZ,
--     is_active BOOLEAN,
--     policy_catalog_id UUID,
--     catalog_policy_name VARCHAR(100),
--     type_id UUID,
--     type_name VARCHAR(100),
--     company_id UUID,
--     company_name VARCHAR(100),
--     days_until_expiry INTEGER
-- ) AS $$
-- BEGIN
--     RETURN QUERY
--     SELECT 
--         cp.policy_id,
--         cp.client_id,
--         cp.policy_name,
--         cp.status,
--         cp.start_date,
--         cp.end_date,
--         cp.notes,
--         cp.created_date,
--         cp.modified_date,
--         cp.is_active,
--         cp.policy_catalog_id,
--         pc.policy_name as catalog_policy_name,
--         cp.type_id,
--         pt.type_name,
--         cp.company_id,
--         ic.company_name,
--         EXTRACT(DAYS FROM (cp.end_date - CURRENT_DATE))::INTEGER as days_until_expiry
--     FROM client_policies cp
--         LEFT JOIN policy_catalog pc ON cp.policy_catalog_id = pc.policy_catalog_id
--         LEFT JOIN policy_types pt ON cp.type_id = pt.type_id
--         LEFT JOIN insurance_companies ic ON cp.company_id = ic.company_id
--     WHERE cp.policy_id = p_policy_id;
-- END;
-- $$ LANGUAGE plpgsql;

-- -- Create Client Policy
-- CREATE OR REPLACE FUNCTION sp_create_client_policy(
--     p_client_id UUID,
--     p_policy_name VARCHAR(100),
--     p_status VARCHAR(20) DEFAULT 'Active',
--     p_start_date DATE,
--     p_end_date DATE,
--     p_notes TEXT DEFAULT NULL,
--     p_policy_catalog_id UUID DEFAULT NULL
-- )
-- RETURNS TABLE(policy_id UUID) AS $$
-- DECLARE
--     v_policy_id UUID := gen_random_uuid();
--     v_company_id UUID;
--     v_type_id UUID;
-- BEGIN
--     -- Pull company_id and type_id from policy_catalog
--     SELECT company_id, type_id
--     INTO v_company_id, v_type_id
--     FROM policy_catalog
--     WHERE policy_catalog_id = p_policy_catalog_id;

--     INSERT INTO client_policies (
--         policy_id, client_id, policy_name, status, start_date, end_date,
--         notes, policy_catalog_id, type_id, company_id, is_active, created_date
--     )
--     VALUES (
--         v_policy_id, p_client_id, p_policy_name, p_status, p_start_date, p_end_date,
--         p_notes, p_policy_catalog_id, v_type_id, v_company_id, TRUE, NOW()
--     );
    
--     RETURN QUERY SELECT v_policy_id;
-- END;
-- $$ LANGUAGE plpgsql;

-- -- Update Client Policy
-- CREATE OR REPLACE FUNCTION sp_update_client_policy(
--     p_policy_id UUID,
--     p_policy_name VARCHAR(100) DEFAULT NULL,
--     p_status VARCHAR(20) DEFAULT NULL,
--     p_start_date DATE DEFAULT NULL,
--     p_end_date DATE DEFAULT NULL,
--     p_notes TEXT DEFAULT NULL,
--     p_policy_catalog_id UUID DEFAULT NULL,
--     p_type_id UUID DEFAULT NULL,
--     p_company_id UUID DEFAULT NULL,
--     p_is_active BOOLEAN DEFAULT NULL
-- )
-- RETURNS TABLE(rows_affected INTEGER) AS $$
-- DECLARE
--     v_rows_affected INTEGER;
-- BEGIN
--     UPDATE client_policies
--     SET 
--         policy_name = COALESCE(p_policy_name, policy_name),
--         status = COALESCE(p_status, status),
--         start_date = COALESCE(p_start_date, start_date),
--         end_date = COALESCE(p_end_date, end_date),
--         notes = COALESCE(p_notes, notes),
--         policy_catalog_id = COALESCE(p_policy_catalog_id, policy_catalog_id),
--         type_id = COALESCE(p_type_id, type_id),
--         company_id = COALESCE(p_company_id, company_id),
--         is_active = COALESCE(p_is_active, is_active),
--         modified_date = NOW()
--     WHERE policy_id = p_policy_id;
    
--     GET DIAGNOSTICS v_rows_affected = ROW_COUNT;
--     RETURN QUERY SELECT v_rows_affected;
-- END;
-- $$ LANGUAGE plpgsql;

-- -- Delete Client Policy
-- CREATE OR REPLACE FUNCTION sp_delete_client_policy(
--     p_policy_id UUID,
--     p_hard_delete BOOLEAN DEFAULT FALSE
-- )
-- RETURNS TABLE(rows_affected INTEGER) AS $$
-- DECLARE
--     v_rows_affected INTEGER;
-- BEGIN
--     IF p_hard_delete = TRUE THEN
--         DELETE FROM client_policies WHERE policy_id = p_policy_id;
--     ELSE
--         UPDATE client_policies 
--         SET is_active = FALSE, status = 'Cancelled', modified_date = NOW()
--         WHERE policy_id = p_policy_id;
--     END IF;
    
--     GET DIAGNOSTICS v_rows_affected = ROW_COUNT;
--     RETURN QUERY SELECT v_rows_affected;
-- END;
-- $$ LANGUAGE plpgsql;

-- -- Upsert Client Policy
-- CREATE OR REPLACE FUNCTION sp_upsert_client_policy(
--     p_policy_id UUID DEFAULT NULL,
--     p_client_id UUID,
--     p_policy_name VARCHAR(100),
--     p_status VARCHAR(20) DEFAULT 'Active',
--     p_start_date DATE,
--     p_end_date DATE,
--     p_notes TEXT DEFAULT NULL,
--     p_policy_catalog_id UUID DEFAULT NULL,
--     p_type_id UUID DEFAULT NULL,
--     p_company_id UUID DEFAULT NULL
-- )
-- RETURNS TABLE(policy_id UUID) AS $$
-- DECLARE
--     v_policy_id UUID;
-- BEGIN
--     IF p_policy_id IS NULL OR NOT EXISTS (SELECT 1 FROM client_policies WHERE policy_id = p_policy_id) THEN
--         -- Insert new record
--         v_policy_id := gen_random_uuid();
--         INSERT INTO client_policies (
--             policy_id, client_id, policy_name, status, start_date, end_date,
--             notes, policy_catalog_id, type_id, company_id, is_active, created_date
--         )
--         VALUES (
--             v_policy_id, p_client_id, p_policy_name, p_status, p_start_date, p_end_date,
--             p_notes, p_policy_catalog_id, p_type_id, p_company_id, TRUE, NOW()
--         );
--     ELSE
--         -- Update existing record
--         v_policy_id := p_policy_id;
--         UPDATE client_policies
--         SET 
--             policy_name = p_policy_name,
--             status = p_status,
--             start_date = p_start_date,
--             end_date = p_end_date,
--             notes = p_notes,
--             policy_catalog_id = p_policy_catalog_id,
--             type_id = p_type_id,
--             company_id = p_company_id,
--             modified_date = NOW()
--         WHERE policy_id = p_policy_id;
--     END IF;
    
--     RETURN QUERY SELECT v_policy_id;
-- END;
-- $$ LANGUAGE plpgsql;

-- -- Get Expiring Policies
-- CREATE OR REPLACE FUNCTION sp_get_expiring_policies(
--     p_agent_id UUID DEFAULT NULL,
--     p_days_ahead INTEGER DEFAULT 30,
--     p_status VARCHAR(20) DEFAULT 'Active'
-- )
-- RETURNS TABLE (
--     policy_id UUID,
--     client_id UUID,
--     policy_name VARCHAR(100),
--     status VARCHAR(20),
--     start_date DATE,
--     end_date DATE,
--     notes TEXT,
--     company_id UUID,
--     company_name VARCHAR(100),
--     type_id UUID,
--     type_name VARCHAR(100),
--     days_until_expiry INTEGER
-- ) AS $$
-- BEGIN
--     RETURN QUERY
--     SELECT 
--         cp.policy_id,
--         cp.client_id,
--         cp.policy_name,
--         cp.status,
--         cp.start_date,
--         cp.end_date,
--         cp.notes,
--         cp.company_id,
--         ic.company_name,
--         cp.type_id,
--         pt.type_name,
--         EXTRACT(DAYS FROM (cp.end_date - CURRENT_DATE))::INTEGER as days_until_expiry
--     FROM client_policies cp
--         LEFT JOIN policy_catalog pc ON cp.policy_catalog_id = pc.policy_catalog_id
--         LEFT JOIN policy_types pt ON cp.type_id = pt.type_id
--         LEFT JOIN insurance_companies ic ON cp.company_id = ic.company_id
--     WHERE cp.is_active = TRUE
--         AND cp.status = p_status
--         AND cp.end_date BETWEEN CURRENT_DATE AND (CURRENT_DATE + INTERVAL '%s days')
--         AND (p_agent_id IS NULL OR pc.agent_id = p_agent_id)
--     ORDER BY cp.end_date;
-- END;
-- $$ LANGUAGE plpgsql;

-- -- Get Policy Statistics
-- CREATE OR REPLACE FUNCTION sp_get_policy_statistics(
--     p_agent_id UUID DEFAULT NULL,
--     p_start_date DATE DEFAULT NULL,
--     p_end_date DATE DEFAULT NULL
-- )
-- RETURNS TABLE (
--     total_policies BIGINT,
--     active_policies BIGINT,
--     expired_policies BIGINT,
--     cancelled_policies BIGINT,
--     expiring_in_30_days BIGINT,
--     expiring_in_60_days BIGINT
-- ) AS $$
-- DECLARE
--     v_start_date DATE := COALESCE(p_start_date, CURRENT_DATE - INTERVAL '1 year');
--     v_end_date DATE := COALESCE(p_end_date, CURRENT_DATE);
-- BEGIN
--     RETURN QUERY
--     SELECT 
--         COUNT(*) as total_policies,
--         SUM(CASE WHEN cp.status = 'Active' THEN 1 ELSE 0 END) as active_policies,
--         SUM(CASE WHEN cp.status = 'Expired' THEN 1 ELSE 0 END) as expired_policies,
--         SUM(CASE WHEN cp.status = 'Cancelled' THEN 1 ELSE 0 END) as cancelled_policies,
--         SUM(CASE WHEN cp.end_date BETWEEN CURRENT_DATE AND (CURRENT_DATE + INTERVAL '30 days') THEN 1 ELSE 0 END) as expiring_in_30_days,
--         SUM(CASE WHEN cp.end_date BETWEEN CURRENT_DATE AND (CURRENT_DATE + INTERVAL '60 days') THEN 1 ELSE 0 END) as expiring_in_60_days
--     FROM client_policies cp
--         LEFT JOIN policy_catalog pc ON cp.policy_catalog_id = pc.policy_catalog_id
--     WHERE cp.is_active = TRUE
--         AND cp.created_date BETWEEN v_start_date AND v_end_date
--         AND (p_agent_id IS NULL OR pc.agent_id = p_agent_id);
-- END;
-- $$ LANGUAGE plpgsql;

-- -- Get Policy Statistics Detailed
-- CREATE OR REPLACE FUNCTION sp_get_policy_statistics_detailed(
--     p_agent_id UUID DEFAULT NULL,
--     p_start_date DATE DEFAULT NULL,
--     p_end_date DATE DEFAULT NULL
-- )
-- RETURNS TABLE (
--     group_type VARCHAR(20),
--     group_name VARCHAR(100),
--     policy_count BIGINT,
--     active_count BIGINT
-- ) AS $$
-- DECLARE
--     v_start_date DATE := COALESCE(p_start_date, CURRENT_DATE - INTERVAL '1 year');
--     v_end_date DATE := COALESCE(p_end_date, CURRENT_DATE);
-- BEGIN
--     RETURN QUERY
--     -- By Company
--     SELECT 
--         'By Company'::VARCHAR(20) as group_type,
--         ic.company_name as group_name,
--         COUNT(*) as policy_count,
--         SUM(CASE WHEN cp.status = 'Active' THEN 1 ELSE 0 END) as active_count
--     FROM client_policies cp
--         LEFT JOIN insurance_companies ic ON cp.company_id = ic.company_id
--         LEFT JOIN policy_catalog pc ON cp.policy_catalog_id = pc.policy_catalog_id
--     WHERE cp.is_active = TRUE
--         AND cp.created_date BETWEEN v_start_date AND v_end_date
--         AND (p_agent_id IS NULL OR pc.agent_id = p_agent_id)
--     GROUP BY ic.company_name
    
--     UNION ALL
    
--     -- By Type
--     SELECT 
--         'By Type'::VARCHAR(20) as group_type,
--         pt.type_name as group_name,
--         COUNT(*) as policy_count,
--         SUM(CASE WHEN cp.status = 'Active' THEN 1 ELSE 0 END) as active_count
--     FROM client_policies cp
--         LEFT JOIN policy_types pt ON cp.type_id = pt.type_id
--         LEFT JOIN policy_catalog pc ON cp.policy_catalog_id = pc.policy_catalog_id
--     WHERE cp.is_active = TRUE
--         AND cp.created_date BETWEEN v_start_date AND v_end_date
--         AND (p_agent_id IS NULL OR pc.agent_id = p_agent_id)
--     GROUP BY pt.type_name
    
--     ORDER BY group_type, policy_count DESC;
-- END;
-- $$ LANGUAGE plpgsql;

-- -- ============================================
-- -- POLICY SEARCH AND FILTERING FUNCTIONS
-- -- ============================================

-- -- Search Policies
-- CREATE OR REPLACE FUNCTION sp_search_policies(
--     p_search_term VARCHAR(100) DEFAULT NULL,
--     p_agent_id UUID DEFAULT NULL,
--     p_client_id UUID DEFAULT NULL,
--     p_company_id UUID DEFAULT NULL,
--     p_type_id UUID DEFAULT NULL,
--     p_status VARCHAR(20) DEFAULT NULL,
--     p_start_date DATE DEFAULT NULL,
--     p_end_date DATE DEFAULT NULL,
--     p_page_size INTEGER DEFAULT 50,
--     p_page_number INTEGER DEFAULT 1
-- )
-- RETURNS TABLE (
--     policy_id UUID,
--     client_id UUID,
--     policy_name VARCHAR(100),
--     status VARCHAR(20),
--     start_date DATE,
--     end_date DATE,
--     notes TEXT,
--     company_id UUID,
--     company_name VARCHAR(100),
--     type_id UUID,
--     type_name VARCHAR(100),
--     policy_catalog_id UUID,
--     catalog_policy_name VARCHAR(100),
--     days_until_expiry INTEGER
-- ) AS $$
-- DECLARE
--     v_offset INTEGER := (p_page_number - 1) * p_page_size;
-- BEGIN
--     RETURN QUERY
--     SELECT 
--         cp.policy_id,
--         cp.client_id,
--         cp.policy_name,
--         cp.status,
--         cp.start_date,
--         cp.end_date,
--         cp.notes,
--         cp.company_id,
--         ic.company_name,
--         cp.type_id,
--         pt.type_name,
--         cp.policy_catalog_id,
--         pc.policy_name as catalog_policy_name,
--         EXTRACT(DAYS FROM (cp.end_date - CURRENT_DATE))::INTEGER as days_until_expiry
--     FROM client_policies cp
--         LEFT JOIN policy_catalog pc ON cp.policy_catalog_id = pc.policy_catalog_id
--         LEFT JOIN policy_types pt ON cp.type_id = pt.type_id
--         LEFT JOIN insurance_companies ic ON cp.company_id = ic.company_id
--     WHERE cp.is_active = TRUE
--         AND (p_search_term IS NULL OR cp.policy_name ILIKE '%' || p_search_term || '%' OR cp.notes ILIKE '%' || p_search_term || '%')
--         AND (p_agent_id IS NULL OR pc.agent_id = p_agent_id)
--         AND (p_client_id IS NULL OR cp.client_id = p_client_id)
--         AND (p_company_id IS NULL OR cp.company_id = p_company_id)
--         AND (p_type_id IS NULL OR cp.type_id = p_type_id)
--         AND (p_status IS NULL OR cp.status = p_status)
--         AND (p_start_date IS NULL OR cp.start_date >= p_start_date)
--         AND (p_end_date IS NULL OR cp.end_date <= p_end_date)
--     ORDER BY cp.created_date DESC
--     LIMIT p_page_size OFFSET v_offset;
-- END;
-- $$ LANGUAGE plpgsql;

-- -- Get Policies By Status
-- CREATE OR REPLACE FUNCTION sp_get_policies_by_status(
--     p_status VARCHAR(20),
--     p_agent_id UUID DEFAULT NULL
-- )
-- RETURNS TABLE (
--     policy_id UUID,
--     client_id UUID,
--     policy_name VARCHAR(100),
--     status VARCHAR(20),
--     start_date DATE,
--     end_date DATE,
--     company_id UUID,
--     company_name VARCHAR(100),
--     type_id UUID,
--     type_name VARCHAR(100),
--     days_until_expiry INTEGER
-- ) AS $$
-- BEGIN
--     RETURN QUERY
--     SELECT 
--         cp.policy_id,
--         cp.client_id,
--         cp.policy_name,
--         cp.status,
--         cp.start_date,
--         cp.end_date,
--         cp.company_id,
--         ic.company_name,
--         cp.type_id,
--         pt.type_name,
--         EXTRACT(DAYS FROM (cp.end_date - CURRENT_DATE))::INTEGER as days_until_expiry
--     FROM client_policies cp
--         LEFT JOIN policy_catalog pc ON cp.policy_catalog_id = pc.policy_catalog_id
--         LEFT JOIN policy_types pt ON cp.type_id = pt.type_id
--         LEFT JOIN insurance_companies ic ON cp.company_id = ic.company_id
--     WHERE cp.is_active = TRUE
--         AND cp.status = p_status
--         AND (p_agent_id IS NULL OR pc.agent_id = p_agent_id)
--     ORDER BY cp.end_date;
-- END;
-- $$ LANGUAGE plpgsql;

-- -- ============================================
-- -- POLICY MANAGEMENT ACTIONS
-- -- ============================================

-- -- Renew Policy
-- CREATE OR REPLACE FUNCTION sp_renew_policy(
--     p_policy_id UUID,
--     p_new_start_date DATE,
--     p_new_end_date DATE,
--     p_new_policy_name VARCHAR(100) DEFAULT NULL,
--     p_notes TEXT DEFAULT NULL
-- )
-- RETURNS TABLE(new_policy_id UUID, rows_affected INTEGER) AS $$
-- DECLARE
--     v_new_policy_id UUID := gen_random_uuid();
--     v_client_id UUID;
--     v_policy_name VARCHAR(100);
--     v_policy_catalog_id UUID;
--     v_type_id UUID;
--     v_company_id UUID;
--     v_rows_affected INTEGER;
-- BEGIN
--     -- Update old policy status
--     UPDATE client_policies 
--     SET status = 'Renewed', modified_date = NOW()
--     WHERE policy_id = p_policy_id;
    
--     GET DIAGNOSTICS v_rows_affected = ROW_COUNT;
    
--     -- Get policy details for renewal
--     SELECT 
--         client_id,
--         COALESCE(p_new_policy_name, policy_name),
--         policy_catalog_id,
--         type_id,
--         company_id
--     INTO v_client_id, v_policy_name, v_policy_catalog_id, v_type_id, v_company_id
--     FROM client_policies 
--     WHERE policy_id = p_policy_id;
    
--     -- Create new policy
--     INSERT INTO client_policies (
--         policy_id, client_id, policy_name, status, start_date, end_date,
--         notes, policy_catalog_id, type_id, company_id, is_active, created_date
--     )
--     VALUES (
--         v_new_policy_id, v_client_id, v_policy_name, 'Active', p_new_start_date, p_new_end_date,
--         p_notes, v_policy_catalog_id, v_type_id, v_company_id, TRUE, NOW()
--     );
    
--     RETURN QUERY SELECT v_new_policy_id, v_rows_affected;
-- END;
-- $$ LANGUAGE plpgsql;

-- -- Bulk Update Policy Status
-- CREATE OR REPLACE FUNCTION sp_bulk_update_policy_status(
--     p_policy_ids TEXT, -- Comma-separated list of UUIDs
--     p_new_status VARCHAR(20)
-- )
-- RETURNS TABLE(rows_affected INTEGER) AS $$
-- DECLARE
--     v_rows_affected INTEGER;
--     policy_id_array UUID[];
-- BEGIN
--     -- Parse the comma-separated list into array
--     SELECT ARRAY(
--         SELECT CAST(trim(unnest(string_to_array(p_policy_ids, ','))) AS UUID)
--     ) INTO policy_id_array;
    
--     -- Update policies
--     UPDATE client_policies
--     SET status = p_new_status, modified_date = NOW()
--     WHERE policy_id = ANY(policy_id_array);
    
--     GET DIAGNOSTICS v_rows_affected = ROW_COUNT;
--     RETURN QUERY SELECT v_rows_affected;
-- END;
-- $$ LANGUAGE plpgsql;

-- -- ============================================
-- -- POLICY TEMPLATES FUNCTIONS
-- -- ============================================

-- -- Get Policy Templates
-- CREATE OR REPLACE FUNCTION sp_get_policy_templates(
--     p_agent_id UUID DEFAULT NULL,
--     p_category_id UUID DEFAULT NULL,
--     p_type_id UUID DEFAULT NULL,
--     p_is_active BOOLEAN DEFAULT TRUE
-- )
-- RETURNS TABLE (
--     template_id UUID,
--     agent_id UUID,
--     template_name VARCHAR(100),
--     default_term_months INTEGER,
--     default_premium DECIMAL(18, 2),
--     coverage_description TEXT,
--     terms TEXT,
--     is_active BOOLEAN,
--     created_date TIMESTAMPTZ,
--     category_id UUID,
--     category_name VARCHAR(100),
--     policy_catalog_id UUID,
--     catalog_policy_name VARCHAR(100),
--     type_id UUID,
--     type_name VARCHAR(100)
-- ) AS $
-- BEGIN
--     RETURN QUERY
--     SELECT 
--         pt.template_id,
--         pt.agent_id,
--         pt.template_name,
--         pt.default_term_months,
--         pt.default_premium,
--         pt.coverage_description,
--         pt.terms,
--         pt.is_active,
--         pt.created_date,
--         pt.category_id,
--         pc.category_name,
--         pt.policy_catalog_id,
--         pol.policy_name as catalog_policy_name,
--         pt.type_id,
--         pty.type_name
--     FROM policy_templates pt
--         LEFT JOIN policy_categories pc ON pt.category_id = pc.category_id
--         LEFT JOIN policy_catalog pol ON pt.policy_catalog_id = pol.policy_catalog_id
--         LEFT JOIN policy_types pty ON pt.type_id = pty.type_id
--     WHERE (p_agent_id IS NULL OR pt.agent_id = p_agent_id)
--         AND (p_category_id IS NULL OR pt.category_id = p_category_id)
--         AND (p_type_id IS NULL OR pt.type_id = p_type_id)
--         AND (p_is_active IS NULL OR pt.is_active = p_is_active)
--     ORDER BY pt.template_name;
-- END;
-- $ LANGUAGE plpgsql;

-- -- Create Policy Template
-- CREATE OR REPLACE FUNCTION sp_create_policy_template(
--     p_agent_id UUID,
--     p_template_name VARCHAR(100),
--     p_default_term_months INTEGER DEFAULT NULL,
--     p_default_premium DECIMAL(18, 2) DEFAULT NULL,
--     p_coverage_description TEXT DEFAULT NULL,
--     p_terms TEXT DEFAULT NULL,
--     p_category_id UUID DEFAULT NULL,
--     p_policy_catalog_id UUID DEFAULT NULL,
--     p_type_id UUID DEFAULT NULL
-- )
-- RETURNS TABLE(template_id UUID) AS $
-- DECLARE
--     v_template_id UUID := gen_random_uuid();
-- BEGIN
--     INSERT INTO policy_templates (
--         template_id, agent_id, template_name, default_term_months, default_premium,
--         coverage_description, terms, category_id, policy_catalog_id, type_id, is_active, created_date
--     )
--     VALUES (
--         v_template_id, p_agent_id, p_template_name, p_default_term_months, p_default_premium,
--         p_coverage_description, p_terms, p_category_id, p_policy_catalog_id, p_type_id, TRUE, NOW()
--     );
    
--     RETURN QUERY SELECT v_template_id;
-- END;
-- $ LANGUAGE plpgsql;

-- -- Update Policy Template
-- CREATE OR REPLACE FUNCTION sp_update_policy_template(
--     p_template_id UUID,
--     p_template_name VARCHAR(100) DEFAULT NULL,
--     p_default_term_months INTEGER DEFAULT NULL,
--     p_default_premium DECIMAL(18, 2) DEFAULT NULL,
--     p_coverage_description TEXT DEFAULT NULL,
--     p_terms TEXT DEFAULT NULL,
--     p_category_id UUID DEFAULT NULL,
--     p_policy_catalog_id UUID DEFAULT NULL,
--     p_type_id UUID DEFAULT NULL,
--     p_is_active BOOLEAN DEFAULT NULL
-- )
-- RETURNS TABLE(rows_affected INTEGER) AS $
-- DECLARE
--     v_rows_affected INTEGER;
-- BEGIN
--     UPDATE policy_templates
--     SET 
--         template_name = COALESCE(p_template_name, template_name),
--         default_term_months = COALESCE(p_default_term_months, default_term_months),
--         default_premium = COALESCE(p_default_premium, default_premium),
--         coverage_description = COALESCE(p_coverage_description, coverage_description),
--         terms = COALESCE(p_terms, terms),
--         category_id = COALESCE(p_category_id, category_id),
--         policy_catalog_id = COALESCE(p_policy_catalog_id, policy_catalog_id),
--         type_id = COALESCE(p_type_id, type_id),
--         is_active = COALESCE(p_is_active, is_active)
--     WHERE template_id = p_template_id;
    
--     GET DIAGNOSTICS v_rows_affected = ROW_COUNT;
--     RETURN QUERY SELECT v_rows_affected;
-- END;
-- $ LANGUAGE plpgsql;

-- -- Delete Policy Template
-- CREATE OR REPLACE FUNCTION sp_delete_policy_template(
--     p_template_id UUID,
--     p_hard_delete BOOLEAN DEFAULT FALSE
-- )
-- RETURNS TABLE(rows_affected INTEGER) AS $
-- DECLARE
--     v_rows_affected INTEGER;
-- BEGIN
--     IF p_hard_delete = TRUE THEN
--         DELETE FROM policy_templates WHERE template_id = p_template_id;
--     ELSE
--         UPDATE policy_templates 
--         SET is_active = FALSE
--         WHERE template_id = p_template_id;
--     END IF;
    
--     GET DIAGNOSTICS v_rows_affected = ROW_COUNT;
--     RETURN QUERY SELECT v_rows_affected;
-- END;
-- $ LANGUAGE plpgsql;

-- -- ============================================
-- -- REFERENCE DATA FUNCTIONS
-- -- ============================================

-- -- Get Insurance Companies
-- CREATE OR REPLACE FUNCTION sp_get_insurance_companies(p_is_active BOOLEAN DEFAULT TRUE)
-- RETURNS TABLE(company_id UUID, company_name VARCHAR(100), is_active BOOLEAN, created_date TIMESTAMPTZ) AS $
-- BEGIN
--     RETURN QUERY
--     SELECT 
--         ic.company_id,
--         ic.company_name,
--         ic.is_active,
--         ic.created_date
--     FROM insurance_companies ic
--     WHERE (p_is_active IS NULL OR ic.is_active = p_is_active)
--     ORDER BY ic.company_name;
-- END;
-- $ LANGUAGE plpgsql;

-- -- Get Policy Types
-- CREATE OR REPLACE FUNCTION sp_get_policy_types_list(p_is_active BOOLEAN DEFAULT TRUE)
-- RETURNS TABLE(type_id UUID, type_name VARCHAR(100), is_active BOOLEAN, created_date TIMESTAMPTZ) AS $
-- BEGIN
--     RETURN QUERY
--     SELECT 
--         pt.type_id,
--         pt.type_name,
--         pt.is_active,
--         pt.created_date
--     FROM policy_types pt
--     WHERE (p_is_active IS NULL OR pt.is_active = p_is_active)
--     ORDER BY pt.type_name;
-- END;
-- $ LANGUAGE plpgsql;

-- -- Get Policy Categories
-- CREATE OR REPLACE FUNCTION sp_get_policy_categories_list(p_is_active BOOLEAN DEFAULT TRUE)
-- RETURNS TABLE(
--     category_id UUID, 
--     category_name VARCHAR(100), 
--     description TEXT, 
--     is_active BOOLEAN, 
--     created_date TIMESTAMPTZ
-- ) AS $
-- BEGIN
--     RETURN QUERY
--     SELECT 
--         pc.category_id,
--         pc.category_name,
--         pc.description,
--         pc.is_active,
--         pc.created_date
--     FROM policy_categories pc
--     WHERE (p_is_active IS NULL OR pc.is_active = p_is_active)
--     ORDER BY pc.category_name;
-- END;
-- $ LANGUAGE plpgsql;

-- -- Create Policy Category
-- CREATE OR REPLACE FUNCTION sp_create_policy_category(
--     p_category_name VARCHAR(100),
--     p_description TEXT DEFAULT NULL
-- )
-- RETURNS TABLE(category_id UUID) AS $
-- DECLARE
--     v_category_id UUID := gen_random_uuid();
-- BEGIN
--     INSERT INTO policy_categories (
--         category_id, category_name, description, is_active, created_date
--     )
--     VALUES (
--         v_category_id, p_category_name, p_description, TRUE, NOW()
--     );
    
--     RETURN QUERY SELECT v_category_id;
-- END;
-- $ LANGUAGE plpgsql;

-- -- ============================================
-- -- ADDITIONAL RECOMMENDED FUNCTIONS
-- -- ============================================

-- -- Create Insurance Company
-- CREATE OR REPLACE FUNCTION sp_create_insurance_company(p_company_name VARCHAR(100))
-- RETURNS TABLE(company_id UUID) AS $
-- DECLARE
--     v_company_id UUID := gen_random_uuid();
-- BEGIN
--     INSERT INTO insurance_companies (
--         company_id, company_name, is_active, created_date
--     )
--     VALUES (
--         v_company_id, p_company_name, TRUE, NOW()
--     );
    
--     RETURN QUERY SELECT v_company_id;
-- END;
-- $ LANGUAGE plpgsql;

-- -- Create Policy Type
-- CREATE OR REPLACE FUNCTION sp_create_policy_type_new(p_type_name VARCHAR(100))
-- RETURNS TABLE(type_id UUID) AS $
-- DECLARE
--     v_type_id UUID := gen_random_uuid();
-- BEGIN
--     INSERT INTO policy_types (
--         type_id, type_name, is_active, created_date
--     )
--     VALUES (
--         v_type_id, p_type_name, TRUE, NOW()
--     );
    
--     RETURN QUERY SELECT v_type_id;
-- END;
-- $ LANGUAGE plpgsql;

-- -- Get Policy Renewal Candidates
-- CREATE OR REPLACE FUNCTION sp_get_policy_renewal_candidates(
--     p_agent_id UUID DEFAULT NULL,
--     p_days_ahead INTEGER DEFAULT 60
-- )
-- RETURNS TABLE (
--     policy_id UUID,
--     client_id UUID,
--     policy_name VARCHAR(100),
--     status VARCHAR(20),
--     start_date DATE,
--     end_date DATE,
--     company_id UUID,
--     company_name VARCHAR(100),
--     type_id UUID,
--     type_name VARCHAR(100),
--     days_until_expiry INTEGER,
--     renewal_priority VARCHAR(10)
-- ) AS $
-- BEGIN
--     RETURN QUERY
--     SELECT 
--         cp.policy_id,
--         cp.client_id,
--         cp.policy_name,
--         cp.status,
--         cp.start_date,
--         cp.end_date,
--         cp.company_id,
--         ic.company_name,
--         cp.type_id,
--         pt.type_name,
--         EXTRACT(DAYS FROM (cp.end_date - CURRENT_DATE))::INTEGER as days_until_expiry,
--         CASE 
--             WHEN EXTRACT(DAYS FROM (cp.end_date - CURRENT_DATE)) <= 30 THEN 'Urgent'
--             WHEN EXTRACT(DAYS FROM (cp.end_date - CURRENT_DATE)) <= 45 THEN 'Soon'
--             ELSE 'Upcoming'
--         END::VARCHAR(10) as renewal_priority
--     FROM client_policies cp
--         LEFT JOIN policy_catalog pc ON cp.policy_catalog_id = pc.policy_catalog_id
--         LEFT JOIN policy_types pt ON cp.type_id = pt.type_id
--         LEFT JOIN insurance_companies ic ON cp.company_id = ic.company_id
--     WHERE cp.is_active = TRUE
--         AND cp.status = 'Active'
--         AND cp.end_date BETWEEN CURRENT_DATE AND (CURRENT_DATE + INTERVAL '%s days')
--         AND (p_agent_id IS NULL OR pc.agent_id = p_agent_id)
--     ORDER BY cp.end_date, renewal_priority;
-- END;
-- $ LANGUAGE plpgsql;

-- -- Get Agent Dashboard Summary
-- CREATE OR REPLACE FUNCTION sp_get_agent_dashboard_summary(p_agent_id UUID)
-- RETURNS TABLE (
--     total_policies BIGINT,
--     active_policies BIGINT,
--     expiring_in_30_days BIGINT,
--     expiring_in_60_days BIGINT,
--     total_companies BIGINT,
--     total_clients BIGINT,
--     inactive_policies BIGINT
-- ) AS $
-- DECLARE
--     v_total_policies BIGINT := 0;
--     v_active_policies BIGINT := 0;
--     v_expiring_in_30_days BIGINT := 0;
--     v_expiring_in_60_days BIGINT := 0;
--     v_total_companies BIGINT := 0;
--     v_total_clients BIGINT := 0;
-- BEGIN
--     -- Get policy counts
--     SELECT 
--         COUNT(*),
--         SUM(CASE WHEN cp.status = 'Active' AND cp.is_active = TRUE THEN 1 ELSE 0 END),
--         SUM(CASE 
--             WHEN cp.status = 'Active' 
--                  AND cp.is_active = TRUE
--                  AND cp.end_date BETWEEN CURRENT_DATE AND (CURRENT_DATE + INTERVAL '30 days')
--             THEN 1 ELSE 0 END),
--         SUM(CASE 
--             WHEN cp.status = 'Active' 
--                  AND cp.is_active = TRUE
--                  AND cp.end_date BETWEEN (CURRENT_DATE + INTERVAL '31 days') AND (CURRENT_DATE + INTERVAL '60 days')
--             THEN 1 ELSE 0 END)
--     INTO v_total_policies, v_active_policies, v_expiring_in_30_days, v_expiring_in_60_days
--     FROM client_policies cp
--         INNER JOIN policy_catalog pc ON cp.policy_catalog_id = pc.policy_catalog_id
--     WHERE pc.agent_id = p_agent_id;

--     -- Get company count (companies actually used in policies for this agent)
--     SELECT COUNT(DISTINCT cp.company_id)
--     INTO v_total_companies
--     FROM client_policies cp
--         INNER JOIN policy_catalog pc ON cp.policy_catalog_id = pc.policy_catalog_id
--     WHERE pc.agent_id = p_agent_id
--       AND cp.is_active = TRUE
--       AND cp.company_id IS NOT NULL;

--     -- Get client count (all clients of the agent, regardless of policy)
--     SELECT COUNT(*)
--     INTO v_total_clients
--     FROM clients c
--     WHERE c.agent_id = p_agent_id
--       AND COALESCE(c.is_active, TRUE) = TRUE;

--     RETURN QUERY
--     SELECT 
--         v_total_policies,
--         v_active_policies,
--         v_expiring_in_30_days,
--         v_expiring_in_60_days,
--         v_total_companies,
--         v_total_clients,
--         (v_total_policies - v_active_policies) as inactive_policies;
-- END;
-- $ LANGUAGE plpgsql;

-- -- Update Policy Category
-- CREATE OR REPLACE FUNCTION sp_update_policy_category_details(
--     p_category_id UUID,
--     p_category_name VARCHAR(100) DEFAULT NULL,
--     p_description TEXT DEFAULT NULL,
--     p_is_active BOOLEAN DEFAULT NULL
-- )
-- RETURNS TABLE(rows_affected INTEGER) AS $
-- DECLARE
--     v_rows_affected INTEGER;
-- BEGIN
--     UPDATE policy_categories
--     SET 
--         category_name = COALESCE(p_category_name, category_name),
--         description = COALESCE(p_description, description),
--         is_active = COALESCE(p_is_active, is_active)
--     WHERE category_id = p_category_id;
    
--     GET DIAGNOSTICS v_rows_affected = ROW_COUNT;
--     RETURN QUERY SELECT v_rows_affected;
-- END;
-- $ LANGUAGE plpgsql;

-- -- Update Insurance Company
-- CREATE OR REPLACE FUNCTION sp_update_insurance_company(
--     p_company_id UUID,
--     p_company_name VARCHAR(100) DEFAULT NULL,
--     p_is_active BOOLEAN DEFAULT NULL
-- )
-- RETURNS TABLE(rows_affected INTEGER) AS $
-- DECLARE
--     v_rows_affected INTEGER;
-- BEGIN
--     UPDATE insurance_companies
--     SET 
--         company_name = COALESCE(p_company_name, company_name),
--         is_active = COALESCE(p_is_active, is_active)
--     WHERE company_id = p_company_id;
    
--     GET DIAGNOSTICS v_rows_affected = ROW_COUNT;
--     RETURN QUERY SELECT v_rows_affected;
-- END;
-- $ LANGUAGE plpgsql;

-- -- Update Policy Type
-- CREATE OR REPLACE FUNCTION sp_update_policy_type_details(
--     p_type_id UUID,
--     p_type_name VARCHAR(100) DEFAULT NULL,
--     p_is_active BOOLEAN DEFAULT NULL
-- )
-- RETURNS TABLE(rows_affected INTEGER) AS $
-- DECLARE
--     v_rows_affected INTEGER;
-- BEGIN
--     UPDATE policy_types
--     SET 
--         type_name = COALESCE(p_type_name, type_name),
--         is_active = COALESCE(p_is_active, is_active)
--     WHERE type_id = p_type_id;
    
--     GET DIAGNOSTICS v_rows_affected = ROW_COUNT;
--     RETURN QUERY SELECT v_rows_affected;
-- END;
-- $ LANGUAGE plpgsql;

-- -- Get Policy History for Client
-- CREATE OR REPLACE FUNCTION sp_get_policy_history_for_client(
--     p_client_id UUID,
--     p_include_inactive BOOLEAN DEFAULT FALSE
-- )
-- RETURNS TABLE (
--     policy_id UUID,
--     client_id UUID,
--     policy_name VARCHAR(100),
--     status VARCHAR(20),
--     start_date DATE,
--     end_date DATE,
--     notes TEXT,
--     created_date TIMESTAMPTZ,
--     modified_date TIMESTAMPTZ,
--     company_id UUID,
--     company_name VARCHAR(100),
--     type_id UUID,
--     type_name VARCHAR(100),
--     policy_duration_days INTEGER,
--     policy_state VARCHAR(20)
-- ) AS $
-- BEGIN
--     RETURN QUERY
--     SELECT 
--         cp.policy_id,
--         cp.client_id,
--         cp.policy_name,
--         cp.status,
--         cp.start_date,
--         cp.end_date,
--         cp.notes,
--         cp.created_date,
--         cp.modified_date,
--         cp.company_id,
--         ic.company_name,
--         cp.type_id,
--         pt.type_name,
--         EXTRACT(DAYS FROM (cp.end_date - cp.start_date))::INTEGER as policy_duration_days,
--         CASE 
--             WHEN cp.status = 'Active' AND cp.end_date > CURRENT_DATE THEN 'Current'
--             WHEN cp.status = 'Active' AND cp.end_date <= CURRENT_DATE THEN 'Expired'
--             ELSE cp.status
--         END::VARCHAR(20) as policy_state
--     FROM client_policies cp
--         LEFT JOIN policy_types pt ON cp.type_id = pt.type_id
--         LEFT JOIN insurance_companies ic ON cp.company_id = ic.company_id
--     WHERE cp.client_id = p_client_id
--         AND (p_include_inactive = TRUE OR cp.is_active = TRUE)
--     ORDER BY cp.start_date DESC, cp.created_date DESC;
-- END;
-- $ LANGUAGE plpgsql;

-- -- Batch Expire Policies
-- CREATE OR REPLACE FUNCTION sp_batch_expire_policies(p_as_of_date DATE DEFAULT NULL)
-- RETURNS TABLE(policies_expired INTEGER) AS $
-- DECLARE
--     v_as_of_date DATE := COALESCE(p_as_of_date, CURRENT_DATE);
--     v_rows_affected INTEGER;
-- BEGIN
--     UPDATE client_policies
--     SET status = 'Expired', modified_date = NOW()
--     WHERE status = 'Active' 
--         AND end_date < v_as_of_date
--         AND is_active = TRUE;
    
--     GET DIAGNOSTICS v_rows_affected = ROW_COUNT;
--     RETURN QUERY SELECT v_rows_affected;
-- END;
-- $ LANGUAGE plpgsql;

-- -- ============================================
-- -- UTILITY FUNCTIONS
-- -- ============================================

-- -- Cleanup Soft Deleted Records
-- CREATE OR REPLACE FUNCTION sp_cleanup_soft_deleted_records(
--     p_days_old INTEGER DEFAULT 365,
--     p_dry_run BOOLEAN DEFAULT TRUE
-- )
-- RETURNS TABLE(table_name VARCHAR(50), records_to_delete BIGINT) AS $
-- DECLARE
--     v_cutoff_date TIMESTAMPTZ := NOW() - INTERVAL '%s days';
--     v_deleted_count INTEGER := 0;
-- BEGIN
--     IF p_dry_run = TRUE THEN
--         -- Show what would be deleted
--         RETURN QUERY
--         SELECT 'client_policies'::VARCHAR(50) as table_name, COUNT(*) as records_to_delete
--         FROM client_policies 
--         WHERE is_active = FALSE AND modified_date < v_cutoff_date
        
--         UNION ALL
        
--         SELECT 'policy_catalog'::VARCHAR(50) as table_name, COUNT(*) as records_to_delete
--         FROM policy_catalog 
--         WHERE is_active = FALSE AND modified_date < v_cutoff_date
        
--         UNION ALL
        
--         SELECT 'policy_templates'::VARCHAR(50) as table_name, COUNT(*) as records_to_delete
--         FROM policy_templates 
--         WHERE is_active = FALSE AND created_date < v_cutoff_date;
--     ELSE
--         -- Actually delete the records
--         DELETE FROM client_policies 
--         WHERE is_active = FALSE AND modified_date < v_cutoff_date;
        
--         GET DIAGNOSTICS v_deleted_count = ROW_COUNT;
        
--         DELETE FROM policy_catalog 
--         WHERE is_active = FALSE AND modified_date < v_cutoff_date;
        
--         GET DIAGNOSTICS v_deleted_count = v_deleted_count + ROW_COUNT;
        
--         DELETE FROM policy_templates 
--         WHERE is_active = FALSE AND created_date < v_cutoff_date;
        
--         GET DIAGNOSTICS v_deleted_count = v_deleted_count + ROW_COUNT;
        
--         RETURN QUERY SELECT 'total_deleted'::VARCHAR(50), v_deleted_count::BIGINT;
--     END IF;
-- END;
-- $ LANGUAGE plpgsql;

-- -- Get Clients With Policies
-- CREATE OR REPLACE FUNCTION sp_get_clients_with_policies(
--     p_agent_id UUID DEFAULT NULL,
--     p_client_id UUID DEFAULT NULL,
--     p_include_inactive BOOLEAN DEFAULT FALSE
-- )
-- RETURNS TABLE (
--     client_id UUID,
--     agent_id UUID,
--     first_name VARCHAR(50),
--     surname VARCHAR(50),
--     last_name VARCHAR(50),
--     full_name VARCHAR(152),
--     phone_number VARCHAR(20),
--     email VARCHAR(100),
--     address TEXT,
--     national_id VARCHAR(50),
--     date_of_birth DATE,
--     is_client BOOLEAN,
--     insurance_type VARCHAR(50),
--     client_notes TEXT,
--     client_created_date TIMESTAMPTZ,
--     client_modified_date TIMESTAMPTZ,
--     client_is_active BOOLEAN,
--     policy_id UUID,
--     policy_name VARCHAR(100),
--     status VARCHAR(20),
--     start_date DATE,
--     end_date DATE,
--     policy_notes TEXT,
--     policy_created_date TIMESTAMPTZ,
--     policy_modified_date TIMESTAMPTZ,
--     policy_is_active BOOLEAN,
--     policy_catalog_id UUID,
--     catalog_policy_name VARCHAR(100),
--     type_id UUID,
--     type_name VARCHAR(100),
--     company_id UUID,
--     company_name VARCHAR(100),
--     days_until_expiry INTEGER
-- ) AS $
-- BEGIN
--     RETURN QUERY
--     SELECT 
--         c.client_id,
--         c.agent_id,
--         c.first_name,
--         c.surname,
--         c.last_name,
--         (c.first_name || ' ' || c.surname || ' ' || c.last_name)::VARCHAR(152) AS full_name,
--         c.phone_number,
--         c.email,
--         c.address,
--         c.national_id,
--         c.date_of_birth,
--         c.is_client,
--         c.insurance_type,
--         c.notes AS client_notes,
--         c.created_date AS client_created_date,
--         c.modified_date AS client_modified_date,
--         c.is_active AS client_is_active,

--         cp.policy_id,
--         cp.policy_name,
--         cp.status,
--         cp.start_date,
--         cp.end_date,
--         cp.notes AS policy_notes,
--         cp.created_date AS policy_created_date,
--         cp.modified_date AS policy_modified_date,
--         cp.is_active AS policy_is_active,
--         cp.policy_catalog_id,
--         pc.policy_name AS catalog_policy_name,
--         cp.type_id,
--         pt.type_name,
--         cp.company_id,
--         ic.company_name,
--         EXTRACT(DAYS FROM (cp.end_date - CURRENT_DATE))::INTEGER AS days_until_expiry
--     FROM clients c
--         INNER JOIN client_policies cp 
--             ON c.client_id = cp.client_id
--            AND cp.policy_id IS NOT NULL
--            AND cp.company_id IS NOT NULL
--            AND cp.type_id IS NOT NULL
--         LEFT JOIN policy_catalog pc ON cp.policy_catalog_id = pc.policy_catalog_id
--         LEFT JOIN policy_types pt ON cp.type_id = pt.type_id
--         LEFT JOIN insurance_companies ic ON cp.company_id = ic.company_id
--     WHERE 
--         (p_agent_id IS NULL OR c.agent_id = p_agent_id)
--         AND (p_client_id IS NULL OR c.client_id = p_client_id)
--         AND (
--             p_include_inactive = TRUE 
--             OR (COALESCE(c.is_active, TRUE) = TRUE AND COALESCE(cp.is_active, TRUE) = TRUE)
--         )
--     ORDER BY c.created_date DESC, cp.end_date DESC;
-- END;
-- $ LANGUAGE plpgsql;

-- -- ============================================
-- -- SOFT DELETE FUNCTIONS
-- -- ============================================

-- -- Soft Delete Client Policy
-- CREATE OR REPLACE FUNCTION sp_soft_delete_client_policy(p_policy_id UUID)
-- RETURNS TABLE(success INTEGER, message TEXT) AS $
-- DECLARE
--     v_rows_affected INTEGER;
-- BEGIN
--     UPDATE client_policies
--     SET is_active = FALSE,
--         modified_date = NOW()
--     WHERE policy_id = p_policy_id AND COALESCE(is_active, TRUE) = TRUE;
    
--     GET DIAGNOSTICS v_rows_affected = ROW_COUNT;
    
--     IF v_rows_affected > 0 THEN
--         RETURN QUERY SELECT 1, 'Policy soft deleted successfully';
--     ELSE
--         RETURN QUERY SELECT 0, 'Policy not found or already inactive';
--     END IF;
-- END;
-- $ LANGUAGE plpgsql;

-- -- Soft Delete Insurance Company
-- CREATE OR REPLACE FUNCTION sp_soft_delete_insurance_company(p_company_id UUID)
-- RETURNS TABLE(success INTEGER, message TEXT) AS $
-- DECLARE
--     v_rows_affected INTEGER;
-- BEGIN
--     UPDATE insurance_companies
--     SET is_active = FALSE
--     WHERE company_id = p_company_id AND COALESCE(is_active, TRUE) = TRUE;
    
--     GET DIAGNOSTICS v_rows_affected = ROW_COUNT;
    
--     IF v_rows_affected > 0 THEN
--         RETURN QUERY SELECT 1, 'Insurance company soft deleted successfully';
--     ELSE
--         RETURN QUERY SELECT 0, 'Insurance company not found or already inactive';
--     END IF;
-- END;
-- $ LANGUAGE plpgsql;

-- -- Soft Delete Policy Catalog
-- CREATE OR REPLACE FUNCTION sp_soft_delete_policy_catalog(p_policy_catalog_id UUID)
-- RETURNS TABLE(success INTEGER, message TEXT) AS $
-- DECLARE
--     v_rows_affected INTEGER;
-- BEGIN
--     UPDATE policy_catalog
--     SET is_active = FALSE,
--         modified_date = NOW()
--     WHERE policy_catalog_id = p_policy_catalog_id AND COALESCE(is_active, TRUE) = TRUE;
    
--     GET DIAGNOSTICS v_rows_affected = ROW_COUNT;
    
--     IF v_rows_affected > 0 THEN
--         RETURN QUERY SELECT 1, 'Policy catalog soft deleted successfully';
--     ELSE
--         RETURN QUERY SELECT 0, 'Policy catalog not found or already inactive';
--     END IF;
-- END;
-- $ LANGUAGE plpgsql;

-- -- Soft Delete Policy Category
-- CREATE OR REPLACE FUNCTION sp_soft_delete_policy_category(p_category_id UUID)
-- RETURNS TABLE(success INTEGER, message TEXT) AS $
-- DECLARE
--     v_rows_affected INTEGER;
-- BEGIN
--     UPDATE policy_categories
--     SET is_active = FALSE
--     WHERE category_id = p_category_id AND COALESCE(is_active, TRUE) = TRUE;
    
--     GET DIAGNOSTICS v_rows_affected = ROW_COUNT;
    
--     IF v_rows_affected > 0 THEN
--         RETURN QUERY SELECT 1, 'Policy category soft deleted successfully';
--     ELSE
--         RETURN QUERY SELECT 0, 'Policy category not found or already inactive';
--     END IF;
-- END;
-- $ LANGUAGE plpgsql;

-- -- Soft Delete Policy Template
-- CREATE OR REPLACE FUNCTION sp_soft_delete_policy_template(p_template_id UUID)
-- RETURNS TABLE(success INTEGER, message TEXT) AS $
-- DECLARE
--     v_rows_affected INTEGER;
-- BEGIN
--     UPDATE policy_templates
--     SET is_active = FALSE
--     WHERE template_id = p_template_id AND COALESCE(is_active, TRUE) = TRUE;
    
--     GET DIAGNOSTICS v_rows_affected = ROW_COUNT;
    
--     IF v_rows_affected > 0 THEN
--         RETURN QUERY SELECT 1, 'Policy template soft deleted successfully';
--     ELSE
--         RETURN QUERY SELECT 0, 'Policy template not found or already inactive';
--     END IF;
-- END;
-- $ LANGUAGE plpgsql;

-- -- Soft Delete Policy Type
-- CREATE OR REPLACE FUNCTION sp_soft_delete_policy_type(p_type_id UUID)
-- RETURNS TABLE(success INTEGER, message TEXT) AS $
-- DECLARE
--     v_rows_affected INTEGER;
-- BEGIN
--     UPDATE policy_types
--     SET is_active = FALSE
--     WHERE type_id = p_type_id AND COALESCE(is_active, TRUE) = TRUE;
    
--     GET DIAGNOSTICS v_rows_affected = ROW_COUNT;
    
--     IF v_rows_affected > 0 THEN
--         RETURN QUERY SELECT 1, 'Policy type soft deleted successfully';
--     ELSE
--         RETURN QUERY SELECT 0, 'Policy type not found or already inactive';
--     END IF;
-- END;
-- $ LANGUAGE plpgsql;

-- -- ============================================
-- -- Reminders and Messaging PostgreSQL Functions
-- -- ============================================

-- -- ===========================================================
-- -- Create or Update Reminder
-- -- ===========================================================
-- CREATE OR REPLACE FUNCTION sp_upsert_reminder(
--     p_reminder_id UUID DEFAULT NULL,
--     p_client_id UUID DEFAULT NULL,
--     p_appointment_id UUID DEFAULT NULL,
--     p_agent_id UUID,
--     p_reminder_type VARCHAR(50),
--     p_title VARCHAR(200),
--     p_description TEXT DEFAULT NULL,
--     p_reminder_date DATE,
--     p_reminder_time TIME DEFAULT NULL,
--     p_client_name VARCHAR(150) DEFAULT NULL,
--     p_priority VARCHAR(10) DEFAULT 'Medium',
--     p_enable_sms BOOLEAN DEFAULT FALSE,
--     p_enable_whatsapp BOOLEAN DEFAULT FALSE,
--     p_enable_push_notification BOOLEAN DEFAULT TRUE,
--     p_advance_notice VARCHAR(20) DEFAULT '1 day',
--     p_custom_message TEXT DEFAULT NULL,
--     p_auto_send BOOLEAN DEFAULT FALSE,
--     p_notes TEXT DEFAULT NULL
-- )
-- RETURNS UUID AS $$
-- DECLARE
--     v_reminder_id UUID;
-- BEGIN
--     IF p_reminder_id IS NULL THEN
--         -- Create new reminder
--         v_reminder_id := gen_random_uuid();
        
--         INSERT INTO reminders (
--             reminder_id, client_id, appointment_id, agent_id, reminder_type, title, description,
--             reminder_date, reminder_time, client_name, priority, enable_sms, enable_whatsapp,
--             enable_push_notification, advance_notice, custom_message, auto_send, notes
--         )
--         VALUES (
--             v_reminder_id, p_client_id, p_appointment_id, p_agent_id, p_reminder_type, p_title, p_description,
--             p_reminder_date, p_reminder_time, p_client_name, p_priority, p_enable_sms, p_enable_whatsapp,
--             p_enable_push_notification, p_advance_notice, p_custom_message, p_auto_send, p_notes
--         );
        
--         -- Log activity
--         INSERT INTO activity_log (agent_id, activity_type, entity_type, entity_id, description)
--         VALUES (p_agent_id, 'reminder_created', 'reminder', v_reminder_id, 
--                 'Reminder "' || p_title || '" created');
--     ELSE
--         -- Update existing reminder
--         v_reminder_id := p_reminder_id;
        
--         UPDATE reminders 
--         SET 
--             reminder_type = p_reminder_type,
--             title = p_title,
--             description = p_description,
--             reminder_date = p_reminder_date,
--             reminder_time = p_reminder_time,
--             client_name = p_client_name,
--             priority = p_priority,
--             enable_sms = p_enable_sms,
--             enable_whatsapp = p_enable_whatsapp,
--             enable_push_notification = p_enable_push_notification,
--             advance_notice = p_advance_notice,
--             custom_message = p_custom_message,
--             auto_send = p_auto_send,
--             notes = p_notes,
--             modified_date = NOW()
--         WHERE reminder_id = p_reminder_id;
        
--         -- Log activity
--         INSERT INTO activity_log (agent_id, activity_type, entity_type, entity_id, description)
--         VALUES (p_agent_id, 'reminder_updated', 'reminder', v_reminder_id, 
--                 'Reminder "' || p_title || '" updated');
--     END IF;
    
--     RETURN v_reminder_id;
-- END;
-- $$ LANGUAGE plpgsql;

-- -- ===========================================================
-- -- Get All Reminders with Comprehensive Union
-- -- ===========================================================
-- CREATE OR REPLACE FUNCTION sp_get_all_reminders(
--     p_agent_id UUID,
--     p_start_date DATE DEFAULT NULL,
--     p_end_date DATE DEFAULT NULL,
--     p_page_number INTEGER DEFAULT 1,
--     p_page_size INTEGER DEFAULT 20
-- )
-- RETURNS TABLE (
--     reminder_id UUID,
--     client_id UUID,
--     appointment_id UUID,
--     agent_id UUID,
--     reminder_type VARCHAR(50),
--     title VARCHAR(200),
--     description TEXT,
--     reminder_date DATE,
--     reminder_time TIME,
--     client_name VARCHAR(150),
--     priority VARCHAR(10),
--     status VARCHAR(20),
--     enable_sms BOOLEAN,
--     enable_whatsapp BOOLEAN,
--     enable_push_notification BOOLEAN,
--     advance_notice VARCHAR(20),
--     custom_message TEXT,
--     auto_send BOOLEAN,
--     notes TEXT,
--     created_date TIMESTAMPTZ,
--     modified_date TIMESTAMPTZ,
--     completed_date TIMESTAMPTZ
-- ) AS $$
-- DECLARE
--     v_offset INTEGER := (p_page_number - 1) * p_page_size;
-- BEGIN
--     RETURN QUERY
--     WITH all_reminders AS (
--         -- 1. Manual Reminders from reminders table
--         SELECT 
--             r.reminder_id,
--             r.client_id,
--             r.appointment_id,
--             r.agent_id,
--             CASE WHEN r.reminder_type = 'Policy Expiry' THEN 'Maturing Policy' ELSE r.reminder_type END AS reminder_type,
--             r.title,
--             r.description,
--             r.reminder_date,
--             r.reminder_time,
--             r.client_name,
--             r.priority,
--             r.status,
--             r.enable_sms,
--             r.enable_whatsapp,
--             r.enable_push_notification,
--             r.advance_notice,
--             r.custom_message,
--             r.auto_send,
--             r.notes,
--             r.created_date,
--             r.modified_date,
--             r.completed_date
--         FROM reminders r
--         WHERE r.agent_id = p_agent_id

--         UNION ALL

--         -- 2. Maturing Policies
--         SELECT 
--             gen_random_uuid() AS reminder_id,
--             cp.client_id,
--             NULL AS appointment_id,
--             c.agent_id,
--             'Maturing Policy' AS reminder_type,
--             cp.policy_name AS title,
--             ('Policy for ' || cp.policy_name || ' is maturing soon') AS description,
--             cp.end_date AS reminder_date,
--             NULL AS reminder_time,
--             (c.first_name || ' ' || c.last_name) AS client_name,
--             'High' AS priority,
--             'Active' AS status,
--             FALSE, FALSE, TRUE, '7 days', NULL, FALSE, NULL,
--             NOW(), NOW(), NULL
--         FROM client_policies cp
--         INNER JOIN clients c ON c.client_id = cp.client_id
--         WHERE c.agent_id = p_agent_id
--           AND cp.is_active = TRUE
--           AND (p_start_date IS NULL OR cp.end_date >= p_start_date)
--           AND (p_end_date IS NULL OR cp.end_date <= p_end_date)

--         UNION ALL

--         -- 3. Birthdays (next 7 days)
--         SELECT 
--             gen_random_uuid() AS reminder_id,
--             c.client_id,
--             NULL AS appointment_id,
--             c.agent_id,
--             'Birthday' AS reminder_type,
--             'Birthday Reminder' AS title,
--             ('Wish ' || c.first_name || ' ' || c.last_name || ' a Happy Birthday!') AS description,
--             MAKE_DATE(EXTRACT(YEAR FROM CURRENT_DATE)::INTEGER, 
--                      EXTRACT(MONTH FROM c.date_of_birth)::INTEGER, 
--                      EXTRACT(DAY FROM c.date_of_birth)::INTEGER) AS reminder_date,
--             NULL AS reminder_time,
--             (c.first_name || ' ' || c.last_name) AS client_name,
--             'Low' AS priority,
--             'Active' AS status,
--             FALSE, FALSE, TRUE, '1 day', NULL, FALSE, NULL,
--             NOW(), NOW(), NULL
--         FROM clients c
--         WHERE c.agent_id = p_agent_id
--           AND c.is_active = TRUE
--           AND MAKE_DATE(EXTRACT(YEAR FROM CURRENT_DATE)::INTEGER, 
--                        EXTRACT(MONTH FROM c.date_of_birth)::INTEGER, 
--                        EXTRACT(DAY FROM c.date_of_birth)::INTEGER)
--               BETWEEN CURRENT_DATE AND CURRENT_DATE + INTERVAL '7 days'

--         UNION ALL

--         -- 4. Appointments
--         SELECT 
--             gen_random_uuid() AS reminder_id,
--             a.client_id,
--             a.appointment_id,
--             a.agent_id,
--             'Appointment' AS reminder_type,
--             a.title,
--             a.description,
--             a.appointment_date AS reminder_date,
--             a.start_time AS reminder_time,
--             a.client_name,
--             a.priority,
--             a.status,
--             FALSE, FALSE, TRUE, '1 day', NULL, FALSE, a.notes,
--             a.created_date,
--             a.modified_date,
--             NULL
--         FROM appointments a
--         WHERE a.agent_id = p_agent_id
--           AND a.is_active = TRUE
--           AND (p_start_date IS NULL OR a.appointment_date >= p_start_date)
--           AND (p_end_date IS NULL OR a.appointment_date <= p_end_date)
--     )
--     SELECT * FROM (
--         SELECT 
--             ROW_NUMBER() OVER (ORDER BY reminder_date ASC, reminder_time ASC) AS row_num,
--             ar.*
--         FROM all_reminders ar
--     ) AS paged
--     WHERE row_num BETWEEN (v_offset + 1) AND (v_offset + p_page_size)
--     ORDER BY reminder_date ASC, reminder_time ASC;
-- END;
-- $$ LANGUAGE plpgsql;

-- -- ===========================================================
-- -- Get Today's Reminders
-- -- ===========================================================
-- CREATE OR REPLACE FUNCTION sp_get_today_reminders(p_agent_id UUID)
-- RETURNS TABLE (
--     reminder_id UUID,
--     reminder_type VARCHAR(50),
--     title VARCHAR(200),
--     description TEXT,
--     reminder_time TIME,
--     client_name VARCHAR(150),
--     priority VARCHAR(10),
--     enable_sms BOOLEAN,
--     enable_whatsapp BOOLEAN,
--     enable_push_notification BOOLEAN,
--     custom_message TEXT,
--     notes TEXT
-- ) AS $$
-- BEGIN
--     RETURN QUERY
--     SELECT 
--         r.reminder_id,
--         r.reminder_type,
--         r.title,
--         r.description,
--         r.reminder_time,
--         r.client_name,
--         r.priority,
--         r.enable_sms,
--         r.enable_whatsapp,
--         r.enable_push_notification,
--         r.custom_message,
--         r.notes
--     FROM reminders r
--     WHERE 
--         r.agent_id = p_agent_id 
--         AND r.status = 'Active'
--         AND r.reminder_date = CURRENT_DATE
--     ORDER BY r.reminder_time ASC;
-- END;
-- $$ LANGUAGE plpgsql;

-- -- ===========================================================
-- -- Complete Reminder
-- -- ===========================================================
-- CREATE OR REPLACE FUNCTION sp_complete_reminder(
--     p_reminder_id UUID,
--     p_agent_id UUID,
--     p_notes TEXT DEFAULT NULL
-- )
-- RETURNS INTEGER AS $$
-- DECLARE
--     v_title VARCHAR(200);
--     v_rows_affected INTEGER;
-- BEGIN
--     -- Get reminder title for logging
--     SELECT title INTO v_title FROM reminders WHERE reminder_id = p_reminder_id;
    
--     UPDATE reminders 
--     SET 
--         status = 'Completed',
--         completed_date = NOW(),
--         modified_date = NOW(),
--         notes = CASE WHEN p_notes IS NOT NULL THEN p_notes ELSE notes END
--     WHERE reminder_id = p_reminder_id AND agent_id = p_agent_id;
    
--     GET DIAGNOSTICS v_rows_affected = ROW_COUNT;
    
--     -- Log activity
--     IF v_rows_affected > 0 THEN
--         INSERT INTO activity_log (agent_id, activity_type, entity_type, entity_id, description)
--         VALUES (p_agent_id, 'reminder_completed', 'reminder', p_reminder_id, 
--                 'Reminder "' || v_title || '" marked as completed');
--     END IF;
    
--     RETURN v_rows_affected;
-- END;
-- $$ LANGUAGE plpgsql;

-- -- ===========================================================
-- -- Delete Reminder
-- -- ===========================================================
-- CREATE OR REPLACE FUNCTION sp_delete_reminder(
--     p_reminder_id UUID,
--     p_agent_id UUID
-- )
-- RETURNS INTEGER AS $$
-- DECLARE
--     v_title VARCHAR(200);
--     v_rows_affected INTEGER;
-- BEGIN
--     -- Get reminder title for logging
--     SELECT title INTO v_title FROM reminders WHERE reminder_id = p_reminder_id;
    
--     DELETE FROM reminders 
--     WHERE reminder_id = p_reminder_id AND agent_id = p_agent_id;
    
--     GET DIAGNOSTICS v_rows_affected = ROW_COUNT;
    
--     -- Log activity
--     IF v_rows_affected > 0 THEN
--         INSERT INTO activity_log (agent_id, activity_type, entity_type, entity_id, description)
--         VALUES (p_agent_id, 'reminder_deleted', 'reminder', p_reminder_id, 
--                 'Reminder "' || v_title || '" deleted');
--     END IF;
    
--     RETURN v_rows_affected;
-- END;
-- $$ LANGUAGE plpgsql;

-- -- ===========================================================
-- -- Update Reminder Settings
-- -- ===========================================================
-- CREATE OR REPLACE FUNCTION sp_update_reminder_settings(
--     p_agent_id UUID,
--     p_reminder_type VARCHAR(50),
--     p_is_enabled BOOLEAN,
--     p_days_before INTEGER,
--     p_time_of_day TIME,
--     p_repeat_daily BOOLEAN DEFAULT FALSE
-- )
-- RETURNS VOID AS $$
-- BEGIN
--     -- Check if setting exists, create or update
--     IF EXISTS (SELECT 1 FROM reminder_settings WHERE agent_id = p_agent_id AND reminder_type = p_reminder_type) THEN
--         UPDATE reminder_settings 
--         SET 
--             is_enabled = p_is_enabled,
--             days_before = p_days_before,
--             time_of_day = p_time_of_day,
--             repeat_daily = p_repeat_daily,
--             modified_date = NOW()
--         WHERE agent_id = p_agent_id AND reminder_type = p_reminder_type;
--     ELSE
--         INSERT INTO reminder_settings (agent_id, reminder_type, is_enabled, days_before, time_of_day, repeat_daily)
--         VALUES (p_agent_id, p_reminder_type, p_is_enabled, p_days_before, p_time_of_day, p_repeat_daily);
--     END IF;
-- END;
-- $$ LANGUAGE plpgsql;

-- -- ===========================================================
-- -- Get Reminder Statistics
-- -- ===========================================================
-- CREATE OR REPLACE FUNCTION sp_get_reminder_statistics(p_agent_id UUID)
-- RETURNS TABLE(
--     total_active INTEGER,
--     total_completed INTEGER,
--     today_reminders INTEGER,
--     upcoming_reminders INTEGER,
--     high_priority INTEGER,
--     overdue INTEGER
-- ) AS $$
-- BEGIN
--     RETURN QUERY
--     SELECT 
--         (SELECT COUNT(*)::INTEGER FROM reminders WHERE agent_id = p_agent_id AND status = 'Active') AS total_active,
--         (SELECT COUNT(*)::INTEGER FROM reminders WHERE agent_id = p_agent_id AND status = 'Completed') AS total_completed,
--         (SELECT COUNT(*)::INTEGER FROM reminders WHERE agent_id = p_agent_id AND status = 'Active' AND reminder_date = CURRENT_DATE) AS today_reminders,
--         (SELECT COUNT(*)::INTEGER FROM reminders WHERE agent_id = p_agent_id AND status = 'Active' AND reminder_date BETWEEN CURRENT_DATE AND CURRENT_DATE + INTERVAL '7 days') AS upcoming_reminders,
--         (SELECT COUNT(*)::INTEGER FROM reminders WHERE agent_id = p_agent_id AND status = 'Active' AND priority = 'High') AS high_priority,
--         (SELECT COUNT(*)::INTEGER FROM reminders WHERE agent_id = p_agent_id AND status = 'Active' AND reminder_date < CURRENT_DATE) AS overdue;
-- END;
-- $$ LANGUAGE plpgsql;

-- -- ===========================================================
-- -- Get Reminder Settings
-- -- ===========================================================
-- CREATE OR REPLACE FUNCTION sp_get_reminder_settings(p_agent_id UUID)
-- RETURNS TABLE (
--     reminder_setting_id UUID,
--     reminder_type VARCHAR(50),
--     is_enabled BOOLEAN,
--     days_before INTEGER,
--     time_of_day TIME,
--     repeat_daily BOOLEAN,
--     created_date TIMESTAMPTZ,
--     modified_date TIMESTAMPTZ
-- ) AS $$
-- BEGIN
--     RETURN QUERY
--     SELECT 
--         rs.reminder_setting_id,
--         rs.reminder_type,
--         rs.is_enabled,
--         rs.days_before,
--         rs.time_of_day,
--         rs.repeat_daily,
--         rs.created_date,
--         rs.modified_date
--     FROM reminder_settings rs
--     WHERE rs.agent_id = p_agent_id
--     ORDER BY rs.reminder_type;
-- END;
-- $$ LANGUAGE plpgsql;

-- -- ===========================================================
-- -- Get All Reminders with Filters
-- -- ===========================================================
-- CREATE OR REPLACE FUNCTION sp_get_all_reminders_filtered(
--     p_agent_id UUID,
--     p_reminder_type VARCHAR(50) DEFAULT NULL,
--     p_status VARCHAR(20) DEFAULT NULL,
--     p_priority VARCHAR(10) DEFAULT NULL,
--     p_start_date DATE DEFAULT NULL,
--     p_end_date DATE DEFAULT NULL,
--     p_client_id UUID DEFAULT NULL,
--     p_page_size INTEGER DEFAULT 50,
--     p_page_number INTEGER DEFAULT 1
-- )
-- RETURNS TABLE (
--     reminder_id UUID,
--     client_id UUID,
--     appointment_id UUID,
--     agent_id UUID,
--     reminder_type VARCHAR(50),
--     title VARCHAR(200),
--     description TEXT,
--     reminder_date DATE,
--     reminder_time TIME,
--     client_name VARCHAR(150),
--     priority VARCHAR(10),
--     status VARCHAR(20),
--     enable_sms BOOLEAN,
--     enable_whatsapp BOOLEAN,
--     enable_push_notification BOOLEAN,
--     advance_notice VARCHAR(20),
--     custom_message TEXT,
--     auto_send BOOLEAN,
--     notes TEXT,
--     created_date TIMESTAMPTZ,
--     modified_date TIMESTAMPTZ,
--     completed_date TIMESTAMPTZ,
--     client_phone VARCHAR(20),
--     client_email VARCHAR(100),
--     total_records BIGINT
-- ) AS $$
-- DECLARE
--     v_offset INTEGER := (p_page_number - 1) * p_page_size;
-- BEGIN
--     RETURN QUERY
--     WITH filtered_reminders AS (
--         SELECT 
--             r.reminder_id,
--             r.client_id,
--             r.appointment_id,
--             r.agent_id,
--             r.reminder_type,
--             r.title,
--             r.description,
--             r.reminder_date,
--             r.reminder_time,
--             r.client_name,
--             r.priority,
--             r.status,
--             r.enable_sms,
--             r.enable_whatsapp,
--             r.enable_push_notification,
--             r.advance_notice,
--             r.custom_message,
--             r.auto_send,
--             r.notes,
--             r.created_date,
--             r.modified_date,
--             r.completed_date,
--             c.phone AS client_phone,
--             c.email AS client_email
--         FROM reminders r
--         LEFT JOIN clients c ON r.client_id = c.client_id
--         WHERE 
--             r.agent_id = p_agent_id
--             AND (p_reminder_type IS NULL OR r.reminder_type = p_reminder_type)
--             AND (p_status IS NULL OR r.status = p_status)
--             AND (p_priority IS NULL OR r.priority = p_priority)
--             AND (p_start_date IS NULL OR r.reminder_date >= p_start_date)
--             AND (p_end_date IS NULL OR r.reminder_date <= p_end_date)
--             AND (p_client_id IS NULL OR r.client_id = p_client_id)
--     ),
--     total_count AS (
--         SELECT COUNT(*) AS total_records FROM filtered_reminders
--     )
--     SELECT 
--         fr.*,
--         tc.total_records
--     FROM filtered_reminders fr
--     CROSS JOIN total_count tc
--     ORDER BY fr.reminder_date ASC, fr.reminder_time ASC
--     LIMIT p_page_size OFFSET v_offset;
-- END;
-- $$ LANGUAGE plpgsql;

-- -- ===========================================================
-- -- Get Reminder by ID
-- -- ===========================================================
-- CREATE OR REPLACE FUNCTION sp_get_reminder_by_id(
--     p_reminder_id UUID,
--     p_agent_id UUID
-- )
-- RETURNS TABLE (
--     reminder_id UUID,
--     client_id UUID,
--     appointment_id UUID,
--     agent_id UUID,
--     reminder_type VARCHAR(50),
--     title VARCHAR(200),
--     description TEXT,
--     reminder_date DATE,
--     reminder_time TIME,
--     client_name VARCHAR(150),
--     priority VARCHAR(10),
--     status VARCHAR(20),
--     enable_sms BOOLEAN,
--     enable_whatsapp BOOLEAN,
--     enable_push_notification BOOLEAN,
--     advance_notice VARCHAR(20),
--     custom_message TEXT,
--     auto_send BOOLEAN,
--     notes TEXT,
--     created_date TIMESTAMPTZ,
--     modified_date TIMESTAMPTZ,
--     completed_date TIMESTAMPTZ,
--     client_phone VARCHAR(20),
--     client_email VARCHAR(100),
--     full_client_name VARCHAR(300)
-- ) AS $$
-- BEGIN
--     RETURN QUERY
--     SELECT 
--         r.reminder_id,
--         r.client_id,
--         r.appointment_id,
--         r.agent_id,
--         r.reminder_type,
--         r.title,
--         r.description,
--         r.reminder_date,
--         r.reminder_time,
--         r.client_name,
--         r.priority,
--         r.status,
--         r.enable_sms,
--         r.enable_whatsapp,
--         r.enable_push_notification,
--         r.advance_notice,
--         r.custom_message,
--         r.auto_send,
--         r.notes,
--         r.created_date,
--         r.modified_date,
--         r.completed_date,
--         c.phone AS client_phone,
--         c.email AS client_email,
--         (c.first_name || ' ' || c.last_name) AS full_client_name
--     FROM reminders r
--     LEFT JOIN clients c ON r.client_id = c.client_id
--     WHERE r.reminder_id = p_reminder_id AND r.agent_id = p_agent_id;
-- END;
-- $$ LANGUAGE plpgsql;

-- -- ===========================================================
-- -- Create Reminder
-- -- ===========================================================
-- CREATE OR REPLACE FUNCTION sp_create_reminder(
--     p_agent_id UUID,
--     p_client_id UUID DEFAULT NULL,
--     p_appointment_id UUID DEFAULT NULL,
--     p_reminder_type VARCHAR(50),
--     p_title VARCHAR(200),
--     p_description TEXT DEFAULT NULL,
--     p_reminder_date DATE,
--     p_reminder_time TIME DEFAULT NULL,
--     p_client_name VARCHAR(150) DEFAULT NULL,
--     p_priority VARCHAR(10) DEFAULT 'Medium',
--     p_enable_sms BOOLEAN DEFAULT FALSE,
--     p_enable_whatsapp BOOLEAN DEFAULT FALSE,
--     p_enable_push_notification BOOLEAN DEFAULT TRUE,
--     p_advance_notice VARCHAR(20) DEFAULT '1 day',
--     p_custom_message TEXT DEFAULT NULL,
--     p_auto_send BOOLEAN DEFAULT FALSE,
--     p_notes TEXT DEFAULT NULL
-- )
-- RETURNS UUID AS $$
-- DECLARE
--     v_reminder_id UUID := gen_random_uuid();
--     v_client_name VARCHAR(150) := p_client_name;
-- BEGIN
--     -- Get client name if not provided but client_id is provided
--     IF v_client_name IS NULL AND p_client_id IS NOT NULL THEN
--         SELECT first_name || ' ' || last_name 
--         INTO v_client_name
--         FROM clients 
--         WHERE client_id = p_client_id AND agent_id = p_agent_id;
--     END IF;
    
--     INSERT INTO reminders (
--         reminder_id, client_id, appointment_id, agent_id, reminder_type, title, description,
--         reminder_date, reminder_time, client_name, priority, status, enable_sms, enable_whatsapp,
--         enable_push_notification, advance_notice, custom_message, auto_send, notes
--     )
--     VALUES (
--         v_reminder_id, p_client_id, p_appointment_id, p_agent_id, p_reminder_type, p_title, p_description,
--         p_reminder_date, p_reminder_time, v_client_name, p_priority, 'Active', p_enable_sms, p_enable_whatsapp,
--         p_enable_push_notification, p_advance_notice, p_custom_message, p_auto_send, p_notes
--     );
    
--     RETURN v_reminder_id;
-- END;
-- $$ LANGUAGE plpgsql;

-- -- ===========================================================
-- -- Update Reminder
-- -- ===========================================================
-- CREATE OR REPLACE FUNCTION sp_update_reminder(
--     p_reminder_id UUID,
--     p_agent_id UUID,
--     p_title VARCHAR(200) DEFAULT NULL,
--     p_description TEXT DEFAULT NULL,
--     p_reminder_date DATE DEFAULT NULL,
--     p_reminder_time TIME DEFAULT NULL,
--     p_priority VARCHAR(10) DEFAULT NULL,
--     p_status VARCHAR(20) DEFAULT NULL,
--     p_enable_sms BOOLEAN DEFAULT NULL,
--     p_enable_whatsapp BOOLEAN DEFAULT NULL,
--     p_enable_push_notification BOOLEAN DEFAULT NULL,
--     p_advance_notice VARCHAR(20) DEFAULT NULL,
--     p_custom_message TEXT DEFAULT NULL,
--     p_auto_send BOOLEAN DEFAULT NULL,
--     p_notes TEXT DEFAULT NULL
-- )
-- RETURNS INTEGER AS $$
-- DECLARE
--     v_rows_affected INTEGER;
-- BEGIN
--     UPDATE reminders 
--     SET 
--         title = COALESCE(p_title, title),
--         description = COALESCE(p_description, description),
--         reminder_date = COALESCE(p_reminder_date, reminder_date),
--         reminder_time = COALESCE(p_reminder_time, reminder_time),
--         priority = COALESCE(p_priority, priority),
--         status = COALESCE(p_status, status),
--         enable_sms = COALESCE(p_enable_sms, enable_sms),
--         enable_whatsapp = COALESCE(p_enable_whatsapp, enable_whatsapp),
--         enable_push_notification = COALESCE(p_enable_push_notification, enable_push_notification),
--         advance_notice = COALESCE(p_advance_notice, advance_notice),
--         custom_message = COALESCE(p_custom_message, custom_message),
--         auto_send = COALESCE(p_auto_send, auto_send),
--         notes = COALESCE(p_notes, notes),
--         modified_date = NOW(),
--         completed_date = CASE WHEN p_status = 'Completed' THEN NOW() ELSE completed_date END
--     WHERE reminder_id = p_reminder_id AND agent_id = p_agent_id;
    
--     GET DIAGNOSTICS v_rows_affected = ROW_COUNT;
--     RETURN v_rows_affected;
-- END;
-- $$ LANGUAGE plpgsql;

-- -- ===========================================================
-- -- Get Upcoming Reminders
-- -- ===========================================================
-- CREATE OR REPLACE FUNCTION sp_get_upcoming_reminders(
--     p_agent_id UUID,
--     p_days_ahead INTEGER DEFAULT 7
-- )
-- RETURNS TABLE (
--     reminder_id UUID,
--     client_id UUID,
--     reminder_type VARCHAR(50),
--     title VARCHAR(200),
--     description TEXT,
--     reminder_date DATE,
--     reminder_time TIME,
--     client_name VARCHAR(150),
--     priority VARCHAR(10),
--     status VARCHAR(20),
--     notes TEXT,
--     client_phone VARCHAR(20)
-- ) AS $$
-- DECLARE
--     v_end_date DATE := CURRENT_DATE + (p_days_ahead || ' days')::INTERVAL;
-- BEGIN
--     RETURN QUERY
--     SELECT 
--         r.reminder_id,
--         r.client_id,
--         r.reminder_type,
--         r.title,
--         r.description,
--         r.reminder_date,
--         r.reminder_time,
--         r.client_name,
--         r.priority,
--         r.status,
--         r.notes,
--         c.phone AS client_phone
--     FROM reminders r
--     LEFT JOIN clients c ON r.client_id = c.client_id
--     WHERE 
--         r.agent_id = p_agent_id 
--         AND r.status = 'Active'
--         AND r.reminder_date BETWEEN CURRENT_DATE AND v_end_date
--     ORDER BY r.reminder_date ASC, r.reminder_time ASC;
-- END;
-- $$ LANGUAGE plpgsql;

-- -- ===========================================================
-- -- Get Completed Reminders
-- -- ===========================================================
-- CREATE OR REPLACE FUNCTION sp_get_completed_reminders(
--     p_agent_id UUID,
--     p_start_date DATE DEFAULT NULL,
--     p_end_date DATE DEFAULT NULL,
--     p_page_size INTEGER DEFAULT 50,
--     p_page_number INTEGER DEFAULT 1
-- )
-- RETURNS TABLE (
--     reminder_id UUID,
--     client_id UUID,
--     reminder_type VARCHAR(50),
--     title VARCHAR(200),
--     description TEXT,
--     reminder_date DATE,
--     reminder_time TIME,
--     client_name VARCHAR(150),
--     priority VARCHAR(10),
--     status VARCHAR(20),
--     completed_date TIMESTAMPTZ,
--     notes TEXT,
--     client_phone VARCHAR(20)
-- ) AS $$
-- DECLARE
--     v_start_date DATE := COALESCE(p_start_date, CURRENT_DATE - INTERVAL '30 days');
--     v_end_date DATE := COALESCE(p_end_date, CURRENT_DATE);
--     v_offset INTEGER := (p_page_number - 1) * p_page_size;
-- BEGIN
--     RETURN QUERY
--     SELECT 
--         r.reminder_id,
--         r.client_id,
--         r.reminder_type,
--         r.title,
--         r.description,
--         r.reminder_date,
--         r.reminder_time,
--         r.client_name,
--         r.priority,
--         r.status,
--         r.completed_date,
--         r.notes,
--         c.phone AS client_phone
--     FROM reminders r
--     LEFT JOIN clients c ON r.client_id = c.client_id
--     WHERE 
--         r.agent_id = p_agent_id 
--         AND r.status = 'Completed'
--         AND r.completed_date BETWEEN v_start_date AND v_end_date + INTERVAL '1 day'
--     ORDER BY r.completed_date DESC
--     LIMIT p_page_size OFFSET v_offset;
-- END;
-- $$ LANGUAGE plpgsql;

-- -- ===========================================================
-- -- Get Today's Birthday Reminders
-- -- ===========================================================
-- CREATE OR REPLACE FUNCTION sp_get_today_birthday_reminders(p_agent_id UUID)
-- RETURNS TABLE (
--     client_id UUID,
--     first_name VARCHAR(50),
--     last_name VARCHAR(50),
--     phone VARCHAR(20),
--     email VARCHAR(100),
--     date_of_birth DATE,
--     age INTEGER
-- ) AS $
-- BEGIN
--     RETURN QUERY
--     SELECT 
--         c.client_id,
--         c.first_name,
--         c.last_name,
--         c.phone,
--         c.email,
--         c.date_of_birth,
--         (EXTRACT(YEAR FROM CURRENT_DATE) - EXTRACT(YEAR FROM c.date_of_birth))::INTEGER AS age
--     FROM clients c
--     WHERE 
--         c.agent_id = p_agent_id 
--         AND c.is_active = TRUE
--         AND EXTRACT(DAY FROM c.date_of_birth) = EXTRACT(DAY FROM CURRENT_DATE)
--         AND EXTRACT(MONTH FROM c.date_of_birth) = EXTRACT(MONTH FROM CURRENT_DATE);
-- END;
-- $ LANGUAGE plpgsql;

-- -- ===========================================================
-- -- Get Policy Expiry Reminders
-- -- ===========================================================
-- CREATE OR REPLACE FUNCTION sp_get_policy_expiry_reminders(
--     p_agent_id UUID,
--     p_days_ahead INTEGER DEFAULT 30
-- )
-- RETURNS TABLE (
--     policy_id UUID,
--     client_id UUID,
--     policy_name VARCHAR(100),
--     policy_type VARCHAR(50),
--     company_name VARCHAR(100),
--     end_date DATE,
--     first_name VARCHAR(50),
--     last_name VARCHAR(50),
--     phone VARCHAR(20),
--     email VARCHAR(100),
--     days_until_expiry INTEGER
-- ) AS $
-- DECLARE
--     v_start_date DATE := CURRENT_DATE;
--     v_end_date DATE := CURRENT_DATE + (p_days_ahead || ' days')::INTERVAL;
-- BEGIN
--     RETURN QUERY
--     SELECT 
--         cp.policy_id,
--         cp.client_id,
--         cp.policy_name,
--         cp.policy_type,
--         cp.company_name,
--         cp.end_date,
--         c.first_name,
--         c.last_name,
--         c.phone,
--         c.email,
--         (cp.end_date - v_start_date)::INTEGER AS days_until_expiry
--     FROM client_policies cp
--     INNER JOIN clients c ON cp.client_id = c.client_id
--     WHERE 
--         c.agent_id = p_agent_id 
--         AND cp.status = 'Active'
--         AND cp.is_active = TRUE
--         AND c.is_active = TRUE
--         AND cp.end_date BETWEEN v_start_date AND v_end_date
--     ORDER BY cp.end_date ASC;
-- END;
-- $ LANGUAGE plpgsql;

-- -- ===========================================================
-- -- Validate Phone Number Format
-- -- ===========================================================
-- CREATE OR REPLACE FUNCTION sp_validate_phone_number(
--     p_phone_number VARCHAR(20),
--     p_country_code VARCHAR(5) DEFAULT '+254'
-- )
-- RETURNS TABLE(
--     is_valid BOOLEAN,
--     formatted_number VARCHAR(20),
--     validation_message VARCHAR(200)
-- ) AS $
-- DECLARE
--     v_clean_number VARCHAR(20);
--     v_is_valid BOOLEAN := FALSE;
--     v_formatted_number VARCHAR(20) := '';
--     v_validation_message VARCHAR(200) := '';
-- BEGIN
--     -- Remove spaces, dashes, and other formatting
--     v_clean_number := REGEXP_REPLACE(p_phone_number, '[^0-9+]', '', 'g');
--     v_clean_number := REPLACE(v_clean_number, '+', '');
    
--     -- Basic validation for Kenyan numbers
--     IF LENGTH(v_clean_number) = 10 AND LEFT(v_clean_number, 1) = '0' THEN
--         v_formatted_number := p_country_code || RIGHT(v_clean_number, 9);
--         v_is_valid := TRUE;
--         v_validation_message := 'Valid phone number';
--     ELSIF LENGTH(v_clean_number) = 9 THEN
--         v_formatted_number := p_country_code || v_clean_number;
--         v_is_valid := TRUE;
--         v_validation_message := 'Valid phone number';
--     ELSIF LENGTH(v_clean_number) = 13 AND LEFT(v_clean_number, 3) = '254' THEN
--         v_formatted_number := '+' || v_clean_number;
--         v_is_valid := TRUE;
--         v_validation_message := 'Valid phone number';
--     ELSE
--         v_validation_message := 'Invalid phone number format';
--     END IF;
    
--     RETURN QUERY
--     SELECT v_is_valid, v_formatted_number, v_validation_message;
-- END;
-- $ LANGUAGE plpgsql;

-- -- ===========================================================
-- -- Get Reminders by Type
-- -- ===========================================================
-- CREATE OR REPLACE FUNCTION sp_get_reminders_by_type(
--     p_agent_id UUID,
--     p_reminder_type VARCHAR(50)
-- )
-- RETURNS TABLE (
--     reminder_id UUID,
--     client_id UUID,
--     appointment_id UUID,
--     agent_id UUID,
--     reminder_type VARCHAR(50),
--     title VARCHAR(200),
--     description TEXT,
--     reminder_date DATE,
--     reminder_time TIME,
--     client_name VARCHAR(150),
--     priority VARCHAR(10),
--     status VARCHAR(20),
--     enable_sms BOOLEAN,
--     enable_whatsapp BOOLEAN,
--     enable_push_notification BOOLEAN,
--     advance_notice VARCHAR(20),
--     custom_message TEXT,
--     auto_send BOOLEAN,
--     notes TEXT,
--     created_date TIMESTAMPTZ,
--     modified_date TIMESTAMPTZ,
--     completed_date TIMESTAMPTZ
-- ) AS $
-- BEGIN
--     RETURN QUERY
--     SELECT 
--         r.reminder_id,
--         r.client_id,
--         r.appointment_id,
--         r.agent_id,
--         r.reminder_type,
--         r.title,
--         r.description,
--         r.reminder_date,
--         r.reminder_time,
--         r.client_name,
--         r.priority,
--         r.status,
--         r.enable_sms,
--         r.enable_whatsapp,
--         r.enable_push_notification,
--         r.advance_notice,
--         r.custom_message,
--         r.auto_send,
--         r.notes,
--         r.created_date,
--         r.modified_date,
--         r.completed_date
--     FROM reminders r
--     WHERE r.agent_id = p_agent_id
--       AND r.reminder_type = p_reminder_type
--     ORDER BY r.reminder_date, r.reminder_time;
-- END;
-- $ LANGUAGE plpgsql;

-- -- ===========================================================
-- -- Get Reminders by Status
-- -- ===========================================================
-- CREATE OR REPLACE FUNCTION sp_get_reminders_by_status(
--     p_agent_id UUID,
--     p_status VARCHAR(20)
-- )
-- RETURNS TABLE (
--     reminder_id UUID,
--     client_id UUID,
--     appointment_id UUID,
--     agent_id UUID,
--     reminder_type VARCHAR(50),
--     title VARCHAR(200),
--     description TEXT,
--     reminder_date DATE,
--     reminder_time TIME,
--     client_name VARCHAR(150),
--     priority VARCHAR(10),
--     status VARCHAR(20),
--     enable_sms BOOLEAN,
--     enable_whatsapp BOOLEAN,
--     enable_push_notification BOOLEAN,
--     advance_notice VARCHAR(20),
--     custom_message TEXT,
--     auto_send BOOLEAN,
--     notes TEXT,
--     created_date TIMESTAMPTZ,
--     modified_date TIMESTAMPTZ,
--     completed_date TIMESTAMPTZ
-- ) AS $
-- BEGIN
--     RETURN QUERY
--     SELECT 
--         r.reminder_id,
--         r.client_id,
--         r.appointment_id,
--         r.agent_id,
--         r.reminder_type,
--         r.title,
--         r.description,
--         r.reminder_date,
--         r.reminder_time,
--         r.client_name,
--         r.priority,
--         r.status,
--         r.enable_sms,
--         r.enable_whatsapp,
--         r.enable_push_notification,
--         r.advance_notice,
--         r.custom_message,
--         r.auto_send,
--         r.notes,
--         r.created_date,
--         r.modified_date,
--         r.completed_date
--     FROM reminders r
--     WHERE r.agent_id = p_agent_id
--       AND r.status = p_status
--     ORDER BY r.reminder_date, r.reminder_time;
-- END;
-- $ LANGUAGE plpgsql;

-- -- ============================================
-- -- Automated Messages Functions
-- -- ============================================

-- -- ===========================================================
-- -- Create Automated Message
-- -- ===========================================================
-- CREATE OR REPLACE FUNCTION sp_create_automated_message(
--     p_agent_id UUID,
--     p_message_type VARCHAR(50),
--     p_title VARCHAR(200),
--     p_template TEXT,
--     p_scheduled_date TIMESTAMPTZ,
--     p_delivery_method VARCHAR(20),
--     p_recipients TEXT DEFAULT NULL
-- )
-- RETURNS UUID AS $
-- DECLARE
--     v_message_id UUID := gen_random_uuid();
--     v_phone VARCHAR(20);
--     v_recipients_array TEXT[];
--     v_recipient TEXT;
-- BEGIN
--     INSERT INTO automated_messages (
--         message_id, agent_id, message_type, title, template,
--         scheduled_date, delivery_method, recipients
--     )
--     VALUES (
--         v_message_id, p_agent_id, p_message_type, p_title, p_template,
--         p_scheduled_date, p_delivery_method, p_recipients
--     );
    
--     -- If recipients are provided, create individual recipient records
--     IF p_recipients IS NOT NULL AND p_recipients != '' THEN
--         -- Simple comma-separated parsing
--         v_recipients_array := string_to_array(REPLACE(p_recipients, ' ', ''), ',');
        
--         FOREACH v_recipient IN ARRAY v_recipients_array
--         LOOP
--             IF LENGTH(v_recipient) > 0 THEN
--                 INSERT INTO message_recipients (message_id, phone_number)
--                 VALUES (v_message_id, v_recipient);
--             END IF;
--         END LOOP;
--     END IF;
    
--     -- Log activity
--     INSERT INTO activity_log (agent_id, activity_type, entity_type, entity_id, description)
--     VALUES (p_agent_id, 'automated_message_created', 'automated_message', v_message_id, 
--             'Automated message "' || p_title || '" scheduled');
    
--     RETURN v_message_id;
-- END;
-- $ LANGUAGE plpgsql;

-- -- ===========================================================
-- -- Get Automated Messages
-- -- ===========================================================
-- CREATE OR REPLACE FUNCTION sp_get_automated_messages(
--     p_agent_id UUID,
--     p_status VARCHAR(20) DEFAULT 'All'
-- )
-- RETURNS TABLE (
--     message_id UUID,
--     agent_id UUID,
--     message_type VARCHAR(50),
--     title VARCHAR(200),
--     template TEXT,
--     scheduled_date TIMESTAMPTZ,
--     delivery_method VARCHAR(20),
--     status VARCHAR(20),
--     recipients TEXT,
--     created_date TIMESTAMPTZ,
--     modified_date TIMESTAMPTZ,
--     sent_date TIMESTAMPTZ,
--     recipient_count BIGINT,
--     delivered_count BIGINT,
--     failed_count BIGINT
-- ) AS $
-- BEGIN
--     RETURN QUERY
--     SELECT 
--         am.message_id,
--         am.agent_id,
--         am.message_type,
--         am.title,
--         am.template,
--         am.scheduled_date,
--         am.delivery_method,
--         am.status,
--         am.recipients,
--         am.created_date,
--         am.modified_date,
--         am.sent_date,
--         COUNT(mr.recipient_id) AS recipient_count,
--         COUNT(CASE WHEN mr.delivery_status = 'Delivered' THEN 1 END) AS delivered_count,
--         COUNT(CASE WHEN mr.delivery_status = 'Failed' THEN 1 END) AS failed_count
--     FROM automated_messages am
--     LEFT JOIN message_recipients mr ON am.message_id = mr.message_id
--     WHERE 
--         am.agent_id = p_agent_id
--         AND (p_status = 'All' OR am.status = p_status)
--     GROUP BY 
--         am.message_id, am.agent_id, am.message_type, am.title, am.template,
--         am.scheduled_date, am.delivery_method, am.status, am.recipients,
--         am.created_date, am.modified_date, am.sent_date
--     ORDER BY am.scheduled_date DESC;
-- END;
-- $ LANGUAGE plpgsql;

-- -- ===========================================================
-- -- Delete Automated Message
-- -- ===========================================================
-- CREATE OR REPLACE FUNCTION sp_delete_automated_message(
--     p_message_id UUID,
--     p_agent_id UUID
-- )
-- RETURNS INTEGER AS $
-- DECLARE
--     v_title VARCHAR(200);
--     v_rows_affected INTEGER;
-- BEGIN
--     -- Get message title for logging
--     SELECT title INTO v_title FROM automated_messages WHERE message_id = p_message_id;
    
--     -- Delete recipients first (cascade should handle this, but being explicit)
--     DELETE FROM message_recipients WHERE message_id = p_message_id;
    
--     -- Delete message
--     DELETE FROM automated_messages 
--     WHERE message_id = p_message_id AND agent_id = p_agent_id;
    
--     GET DIAGNOSTICS v_rows_affected = ROW_COUNT;
    
--     -- Log activity
--     IF v_rows_affected > 0 THEN
--         INSERT INTO activity_log (agent_id, activity_type, entity_type, entity_id, description)
--         VALUES (p_agent_id, 'automated_message_deleted', 'automated_message', p_message_id, 
--                 'Automated message "' || v_title || '" deleted');
--     END IF;
    
--     RETURN v_rows_affected;
-- END;
-- $ LANGUAGE plpgsql;

-- -- ============================================
-- -- Daily Notes Functions
-- -- ============================================

-- -- ===========================================================
-- -- Save Daily Notes
-- -- ===========================================================
-- CREATE OR REPLACE FUNCTION sp_save_daily_notes(
--     p_agent_id UUID,
--     p_note_date DATE,
--     p_notes TEXT
-- )
-- RETURNS VOID AS $
-- BEGIN
--     -- Check if notes exist for this date
--     IF EXISTS (SELECT 1 FROM daily_notes WHERE agent_id = p_agent_id AND note_date = p_note_date) THEN
--         UPDATE daily_notes 
--         SET notes = p_notes, modified_date = NOW()
--         WHERE agent_id = p_agent_id AND note_date = p_note_date;
--     ELSE
--         INSERT INTO daily_notes (agent_id, note_date, notes)
--         VALUES (p_agent_id, p_note_date, p_notes);
--     END IF;
    
--     -- Log activity
--     INSERT INTO activity_log (agent_id, activity_type, entity_type, entity_id, description)
--     VALUES (p_agent_id, 'daily_notes_updated', 'daily_notes', NULL, 
--             'Daily notes updated for ' || TO_CHAR(p_note_date, 'Month DD, YYYY'));
-- END;
-- $ LANGUAGE plpgsql;

-- -- ===========================================================
-- -- Get Daily Notes
-- -- ===========================================================
-- CREATE OR REPLACE FUNCTION sp_get_daily_notes(
--     p_agent_id UUID,
--     p_note_date DATE
-- )
-- RETURNS TABLE (
--     note_id UUID,
--     note_date DATE,
--     notes TEXT,
--     created_date TIMESTAMPTZ,
--     modified_date TIMESTAMPTZ
-- ) AS $
-- BEGIN
--     RETURN QUERY
--     SELECT 
--         dn.note_id,
--         dn.note_date,
--         dn.notes,
--         dn.created_date,
--         dn.modified_date
--     FROM daily_notes dn
--     WHERE dn.agent_id = p_agent_id AND dn.note_date = p_note_date;
-- END;
-- $ LANGUAGE plpgsql;

-- -- ===========================================================
-- -- Daily Notes Management Functions
-- -- ===========================================================

-- -- Get Daily Notes
-- CREATE OR REPLACE FUNCTION sp_get_daily_notes(
--     p_agent_id UUID,
--     p_note_date DATE
-- )
-- RETURNS TABLE (
--     note_id UUID,
--     agent_id UUID,
--     note_date DATE,
--     notes TEXT,
--     created_date TIMESTAMPTZ,
--     modified_date TIMESTAMPTZ
-- ) AS $$
-- BEGIN
--     RETURN QUERY
--     SELECT 
--         dn.note_id,
--         dn.agent_id,
--         dn.note_date,
--         dn.notes,
--         dn.created_date,
--         dn.modified_date
--     FROM daily_notes dn
--     WHERE dn.agent_id = p_agent_id AND dn.note_date = p_note_date;
-- END;
-- $$ LANGUAGE plpgsql;

-- -- Save Daily Notes
-- CREATE OR REPLACE FUNCTION sp_save_daily_notes(
--     p_agent_id UUID,
--     p_note_date DATE,
--     p_notes TEXT
-- )
-- RETURNS TABLE(rows_affected INTEGER) AS $$
-- DECLARE
--     v_rows_affected INTEGER;
-- BEGIN
--     IF EXISTS (SELECT 1 FROM daily_notes WHERE agent_id = p_agent_id AND note_date = p_note_date) THEN
--         UPDATE daily_notes 
--         SET 
--             notes = p_notes,
--             modified_date = NOW()
--         WHERE agent_id = p_agent_id AND note_date = p_note_date;
        
--         GET DIAGNOSTICS v_rows_affected = ROW_COUNT;
--     ELSE
--         INSERT INTO daily_notes (agent_id, note_date, notes)
--         VALUES (p_agent_id, p_note_date, p_notes);
        
--         GET DIAGNOSTICS v_rows_affected = ROW_COUNT;
--     END IF;
    
--     RETURN QUERY SELECT v_rows_affected;
-- END;
-- $$ LANGUAGE plpgsql;

-- -- Get All Notes
-- CREATE OR REPLACE FUNCTION sp_get_all_notes(
--     p_agent_id UUID,
--     p_start_date DATE DEFAULT NULL,
--     p_end_date DATE DEFAULT NULL
-- )
-- RETURNS TABLE (
--     note_id UUID,
--     agent_id UUID,
--     note_date DATE,
--     notes TEXT,
--     created_date TIMESTAMPTZ,
--     modified_date TIMESTAMPTZ
-- ) AS $$
-- DECLARE
--     v_start_date DATE;
--     v_end_date DATE;
-- BEGIN
--     v_start_date := COALESCE(p_start_date, CURRENT_DATE - INTERVAL '3 months');
--     v_end_date := COALESCE(p_end_date, CURRENT_DATE);
    
--     RETURN QUERY
--     SELECT 
--         dn.note_id,
--         dn.agent_id,
--         dn.note_date,
--         dn.notes,
--         dn.created_date,
--         dn.modified_date
--     FROM daily_notes dn
--     WHERE 
--         dn.agent_id = p_agent_id 
--         AND dn.note_date BETWEEN v_start_date AND v_end_date
--     ORDER BY dn.note_date DESC;
-- END;
-- $$ LANGUAGE plpgsql;

-- -- Search Notes
-- CREATE OR REPLACE FUNCTION sp_search_notes(
--     p_agent_id UUID,
--     p_search_term VARCHAR(500)
-- )
-- RETURNS TABLE (
--     note_id UUID,
--     agent_id UUID,
--     note_date DATE,
--     notes TEXT,
--     created_date TIMESTAMPTZ,
--     modified_date TIMESTAMPTZ
-- ) AS $$
-- BEGIN
--     RETURN QUERY
--     SELECT 
--         dn.note_id,
--         dn.agent_id,
--         dn.note_date,
--         dn.notes,
--         dn.created_date,
--         dn.modified_date
--     FROM daily_notes dn
--     WHERE 
--         dn.agent_id = p_agent_id 
--         AND dn.notes ILIKE '%' || p_search_term || '%'
--     ORDER BY dn.note_date DESC;
-- END;
-- $$ LANGUAGE plpgsql;

-- -- Delete Notes
-- CREATE OR REPLACE FUNCTION sp_delete_notes(
--     p_agent_id UUID,
--     p_note_date DATE
-- )
-- RETURNS TABLE(rows_affected INTEGER) AS $$
-- DECLARE
--     v_rows_affected INTEGER;
-- BEGIN
--     DELETE FROM daily_notes 
--     WHERE agent_id = p_agent_id AND note_date = p_note_date;
    
--     GET DIAGNOSTICS v_rows_affected = ROW_COUNT;
    
--     RETURN QUERY SELECT v_rows_affected;
-- END;
-- $$ LANGUAGE plpgsql;

-- -- ===========================================================
-- -- Navbar Badge Counts
-- -- ===========================================================
-- CREATE OR REPLACE FUNCTION sp_get_navbar_badge_counts(p_agent_id UUID)
-- RETURNS TABLE(
--     clients_count BIGINT,
--     policies_count BIGINT,
--     reminders_count BIGINT,
--     appointments_count BIGINT
-- ) AS $$
-- BEGIN
--     RETURN QUERY
--     SELECT 
--         -- Clients (only active ones)
--         COUNT(DISTINCT CASE WHEN c.is_active = TRUE THEN c.client_id END) AS clients_count,
        
--         -- Policies (only active)
--         COUNT(DISTINCT CASE WHEN p.is_active = TRUE THEN p.policy_id END) AS policies_count,
        
--         -- Reminders (pending/active)
--         COUNT(DISTINCT CASE WHEN r.status = 'Active' THEN r.reminder_id END) AS reminders_count,
        
--         -- Appointments (upcoming or active)
--         COUNT(DISTINCT CASE 
--                       WHEN a.is_active = TRUE 
--                            AND a.status NOT IN ('Completed', 'Cancelled') 
--                       THEN a.appointment_id END) AS appointments_count
--     FROM (SELECT 1 AS dummy) d
--     LEFT JOIN clients c ON c.agent_id = p_agent_id
--     LEFT JOIN client_policies p ON p.client_id = c.client_id
--     LEFT JOIN reminders r ON r.agent_id = p_agent_id
--     LEFT JOIN appointments a ON a.agent_id = p_agent_id;
-- END;
-- $$ LANGUAGE plpgsql;

-- -- ===========================================================
-- -- Global Search Functions
-- -- ===========================================================

-- -- Global Search
-- CREATE OR REPLACE FUNCTION sp_global_search(
--     p_agent_id UUID,
--     p_search_term VARCHAR(500)
-- )
-- RETURNS TABLE(
--     entity_type VARCHAR(50),
--     entity_id UUID,
--     title VARCHAR(500),
--     subtitle VARCHAR(500),
--     detail1 VARCHAR(500),
--     detail2 VARCHAR(500),
--     status VARCHAR(100)
-- ) AS $$
-- BEGIN
--     RETURN QUERY
--     -- Search Clients
--     SELECT 
--         'Client'::VARCHAR(50) AS entity_type,
--         c.client_id AS entity_id,
--         (c.first_name || ' ' || c.surname)::VARCHAR(500) AS title,
--         c.email::VARCHAR(500) AS subtitle,
--         c.phone_number::VARCHAR(500) AS detail1,
--         c.address::VARCHAR(500) AS detail2,
--         CASE WHEN c.is_client = TRUE THEN 'Client' ELSE 'Prospect' END::VARCHAR(100) AS status
--     FROM clients c
--     WHERE c.agent_id = p_agent_id 
--         AND c.is_active = TRUE
--         AND (
--             c.first_name ILIKE '%' || p_search_term || '%' OR
--             c.surname ILIKE '%' || p_search_term || '%' OR
--             c.last_name ILIKE '%' || p_search_term || '%' OR
--             c.email ILIKE '%' || p_search_term || '%' OR
--             c.phone_number ILIKE '%' || p_search_term || '%' OR
--             c.national_id ILIKE '%' || p_search_term || '%'
--         )
    
--     UNION ALL
    
--     -- Search Appointments
--     SELECT 
--         'Appointment'::VARCHAR(50) AS entity_type,
--         a.appointment_id AS entity_id,
--         a.title::VARCHAR(500),
--         a.client_name::VARCHAR(500) AS subtitle,
--         a.appointment_date::VARCHAR(500) AS detail1,
--         a.location::VARCHAR(500) AS detail2,
--         a.status::VARCHAR(100)
--     FROM appointments a
--     INNER JOIN clients c ON a.client_id = c.client_id
--     WHERE c.agent_id = p_agent_id 
--         AND a.is_active = TRUE
--         AND (
--             a.title ILIKE '%' || p_search_term || '%' OR
--             a.client_name ILIKE '%' || p_search_term || '%' OR
--             a.description ILIKE '%' || p_search_term || '%' OR
--             a.location ILIKE '%' || p_search_term || '%'
--         )
    
--     UNION ALL
    
--     -- Search Policies
--     SELECT 
--         'Policy'::VARCHAR(50) AS entity_type,
--         pc.policy_catalog_id AS entity_id,
--         pc.policy_name::VARCHAR(500) AS title,
--         pc.policy_type::VARCHAR(500) AS subtitle,
--         pc.company_name::VARCHAR(500) AS detail1,
--         ''::VARCHAR(500) AS detail2,
--         CASE WHEN pc.is_active = TRUE THEN 'Active' ELSE 'Inactive' END::VARCHAR(100) AS status
--     FROM policy_catalog pc
--     WHERE pc.agent_id = p_agent_id
--         AND (
--             pc.policy_name ILIKE '%' || p_search_term || '%' OR
--             pc.policy_type ILIKE '%' || p_search_term || '%' OR
--             pc.company_name ILIKE '%' || p_search_term || '%' OR
--             pc.notes ILIKE '%' || p_search_term || '%'
--         )
    
--     UNION ALL
    
--     -- Search Reminders
--     SELECT 
--         'Reminder'::VARCHAR(50) AS entity_type,
--         r.reminder_id AS entity_id,
--         r.title::VARCHAR(500),
--         r.client_name::VARCHAR(500) AS subtitle,
--         r.reminder_date::VARCHAR(500) AS detail1,
--         r.reminder_type::VARCHAR(500) AS detail2,
--         r.status::VARCHAR(100)
--     FROM reminders r
--     WHERE r.agent_id = p_agent_id
--         AND (
--             r.title ILIKE '%' || p_search_term || '%' OR
--             r.client_name ILIKE '%' || p_search_term || '%' OR
--             r.description ILIKE '%' || p_search_term || '%' OR
--             r.reminder_type ILIKE '%' || p_search_term || '%'
--         )
--     ORDER BY entity_type, title;
-- END;
-- $$ LANGUAGE plpgsql;

-- -- Search Clients
-- CREATE OR REPLACE FUNCTION sp_search_clients(
--     p_agent_id UUID,
--     p_search_term VARCHAR(500)
-- )
-- RETURNS TABLE(
--     client_id UUID,
--     first_name VARCHAR(50),
--     surname VARCHAR(50),
--     last_name VARCHAR(50),
--     phone_number VARCHAR(20),
--     email VARCHAR(100),
--     address TEXT,
--     national_id VARCHAR(50),
--     date_of_birth DATE,
--     is_client BOOLEAN,
--     insurance_type VARCHAR(100),
--     notes TEXT,
--     created_date TIMESTAMPTZ,
--     modified_date TIMESTAMPTZ,
--     client_type VARCHAR(20)
-- ) AS $$
-- BEGIN
--     RETURN QUERY
--     SELECT 
--         c.client_id,
--         c.first_name,
--         c.surname,
--         c.last_name,
--         c.phone_number,
--         c.email,
--         c.address,
--         c.national_id,
--         c.date_of_birth,
--         c.is_client,
--         c.insurance_type,
--         c.notes,
--         c.created_date,
--         c.modified_date,
--         CASE WHEN c.is_client = TRUE THEN 'Client' ELSE 'Prospect' END::VARCHAR(20) AS client_type
--     FROM clients c
--     WHERE c.agent_id = p_agent_id 
--         AND c.is_active = TRUE
--         AND (
--             c.first_name ILIKE '%' || p_search_term || '%' OR
--             c.surname ILIKE '%' || p_search_term || '%' OR
--             c.last_name ILIKE '%' || p_search_term || '%' OR
--             c.email ILIKE '%' || p_search_term || '%' OR
--             c.phone_number ILIKE '%' || p_search_term || '%' OR
--             c.national_id ILIKE '%' || p_search_term || '%' OR
--             c.address ILIKE '%' || p_search_term || '%' OR
--             c.insurance_type ILIKE '%' || p_search_term || '%'
--         )
--     ORDER BY c.is_client DESC, c.first_name, c.surname;
-- END;
-- $$ LANGUAGE plpgsql;

-- -- Search Appointments
-- CREATE OR REPLACE FUNCTION sp_search_appointments(
--     p_agent_id UUID,
--     p_search_term VARCHAR(500)
-- )
-- RETURNS TABLE(
--     appointment_id UUID,
--     client_id UUID,
--     client_name VARCHAR(100),
--     client_phone VARCHAR(20),
--     title VARCHAR(200),
--     description TEXT,
--     appointment_date DATE,
--     start_time TIME,
--     end_time TIME,
--     location VARCHAR(200),
--     type VARCHAR(50),
--     status VARCHAR(50),
--     priority VARCHAR(20),
--     notes TEXT,
--     created_date TIMESTAMPTZ
-- ) AS $$
-- BEGIN
--     RETURN QUERY
--     SELECT 
--         a.appointment_id,
--         a.client_id,
--         a.client_name,
--         a.client_phone,
--         a.title,
--         a.description,
--         a.appointment_date,
--         a.start_time,
--         a.end_time,
--         a.location,
--         a.type,
--         a.status,
--         a.priority,
--         a.notes,
--         a.created_date
--     FROM appointments a
--     INNER JOIN clients c ON a.client_id = c.client_id
--     WHERE c.agent_id = p_agent_id 
--         AND a.is_active = TRUE
--         AND (
--             a.title ILIKE '%' || p_search_term || '%' OR
--             a.client_name ILIKE '%' || p_search_term || '%' OR
--             a.description ILIKE '%' || p_search_term || '%' OR
--             a.location ILIKE '%' || p_search_term || '%' OR
--             a.type ILIKE '%' || p_search_term || '%'
--         )
--     ORDER BY a.appointment_date DESC, a.start_time;
-- END;
-- $$ LANGUAGE plpgsql;

-- -- Search Policies
-- CREATE OR REPLACE FUNCTION sp_search_policies(
--     p_agent_id UUID,
--     p_search_term VARCHAR(500)
-- )
-- RETURNS TABLE(
--     policy_catalog_id UUID,
--     policy_name VARCHAR(200),
--     policy_type VARCHAR(100),
--     company_id UUID,
--     company_name VARCHAR(100),
--     notes TEXT,
--     is_active BOOLEAN,
--     created_date TIMESTAMPTZ,
--     modified_date TIMESTAMPTZ
-- ) AS $$
-- BEGIN
--     RETURN QUERY
--     SELECT 
--         pc.policy_catalog_id,
--         pc.policy_name,
--         pc.policy_type,
--         pc.company_id,
--         pc.company_name,
--         pc.notes,
--         pc.is_active,
--         pc.created_date,
--         pc.modified_date
--     FROM policy_catalog pc
--     WHERE pc.agent_id = p_agent_id
--         AND (
--             pc.policy_name ILIKE '%' || p_search_term || '%' OR
--             pc.policy_type ILIKE '%' || p_search_term || '%' OR
--             pc.company_name ILIKE '%' || p_search_term || '%' OR
--             pc.notes ILIKE '%' || p_search_term || '%'
--         )
--     ORDER BY pc.policy_name;
-- END;
-- $$ LANGUAGE plpgsql;

-- -- Search Reminders
-- CREATE OR REPLACE FUNCTION sp_search_reminders(
--     p_agent_id UUID,
--     p_search_term VARCHAR(500)
-- )
-- RETURNS TABLE(
--     reminder_id UUID,
--     client_id UUID,
--     appointment_id UUID,
--     reminder_type VARCHAR(50),
--     title VARCHAR(200),
--     description TEXT,
--     reminder_date DATE,
--     reminder_time TIME,
--     client_name VARCHAR(100),
--     priority VARCHAR(20),
--     status VARCHAR(50),
--     notes TEXT,
--     created_date TIMESTAMPTZ
-- ) AS $$
-- BEGIN
--     RETURN QUERY
--     SELECT 
--         r.reminder_id,
--         r.client_id,
--         r.appointment_id,
--         r.reminder_type,
--         r.title,
--         r.description,
--         r.reminder_date,
--         r.reminder_time,
--         r.client_name,
--         r.priority,
--         r.status,
--         r.notes,
--         r.created_date
--     FROM reminders r
--     WHERE r.agent_id = p_agent_id
--         AND (
--             r.title ILIKE '%' || p_search_term || '%' OR
--             r.client_name ILIKE '%' || p_search_term || '%' OR
--             r.description ILIKE '%' || p_search_term || '%' OR
--             r.reminder_type ILIKE '%' || p_search_term || '%' OR
--             r.notes ILIKE '%' || p_search_term || '%'
--         )
--     ORDER BY r.reminder_date DESC;
-- END;
-- $$ LANGUAGE plpgsql;

-- -- Get Search Suggestions
-- CREATE OR REPLACE FUNCTION sp_get_search_suggestions(
--     p_agent_id UUID,
--     p_search_term VARCHAR(500),
--     p_max_results INTEGER DEFAULT 10
-- )
-- RETURNS TABLE(suggestion VARCHAR(500)) AS $$
-- BEGIN
--     RETURN QUERY
--     SELECT DISTINCT suggestions.suggestion
--     FROM (
--         SELECT c.first_name::VARCHAR(500) AS suggestion FROM clients c WHERE c.agent_id = p_agent_id AND c.first_name ILIKE p_search_term || '%'
--         UNION
--         SELECT c.surname::VARCHAR(500) FROM clients c WHERE c.agent_id = p_agent_id AND c.surname ILIKE p_search_term || '%'
--         UNION
--         SELECT c.email::VARCHAR(500) FROM clients c WHERE c.agent_id = p_agent_id AND c.email ILIKE p_search_term || '%'
--         UNION
--         SELECT c.insurance_type::VARCHAR(500) FROM clients c WHERE c.agent_id = p_agent_id AND c.insurance_type ILIKE p_search_term || '%'
--         UNION
--         SELECT pc.policy_name::VARCHAR(500) FROM policy_catalog pc WHERE pc.agent_id = p_agent_id AND pc.policy_name ILIKE p_search_term || '%'
--         UNION
--         SELECT pc.policy_type::VARCHAR(500) FROM policy_catalog pc WHERE pc.agent_id = p_agent_id AND pc.policy_type ILIKE p_search_term || '%'
--         UNION
--         SELECT pc.company_name::VARCHAR(500) FROM policy_catalog pc WHERE pc.agent_id = p_agent_id AND pc.company_name ILIKE p_search_term || '%'
--     ) AS suggestions
--     ORDER BY suggestion
--     LIMIT p_max_results;
-- END;
-- $$ LANGUAGE plpgsql;

-- -- Save Search History
-- CREATE OR REPLACE FUNCTION sp_save_search_history(
--     p_agent_id UUID,
--     p_search_term VARCHAR(500)
-- )
-- RETURNS VOID AS $$
-- BEGIN
--     IF EXISTS (SELECT 1 FROM search_history WHERE agent_id = p_agent_id AND search_term = p_search_term) THEN
--         UPDATE search_history 
--         SET 
--             search_count = search_count + 1,
--             last_searched = NOW()
--         WHERE agent_id = p_agent_id AND search_term = p_search_term;
--     ELSE
--         INSERT INTO search_history (agent_id, search_term)
--         VALUES (p_agent_id, p_search_term);
--     END IF;
-- END;
-- $$ LANGUAGE plpgsql;

-- -- Get Search History
-- CREATE OR REPLACE FUNCTION sp_get_search_history(
--     p_agent_id UUID,
--     p_max_results INTEGER DEFAULT 20
-- )
-- RETURNS TABLE(
--     search_term VARCHAR(500),
--     search_count INTEGER,
--     last_searched TIMESTAMPTZ
-- ) AS $$
-- BEGIN
--     RETURN QUERY
--     SELECT 
--         sh.search_term,
--         sh.search_count,
--         sh.last_searched
--     FROM search_history sh
--     WHERE sh.agent_id = p_agent_id
--     ORDER BY sh.last_searched DESC
--     LIMIT p_max_results;
-- END;
-- $$ LANGUAGE plpgsql;

-- -- ============================================
-- -- Validation Service Functions
-- -- ============================================

-- -- Validate Email
-- CREATE OR REPLACE FUNCTION sp_validate_email(p_email VARCHAR(100))
-- RETURNS TABLE(is_valid BOOLEAN, validation_message VARCHAR(200)) AS $$
-- DECLARE
--     v_is_valid BOOLEAN := FALSE;
--     v_validation_message VARCHAR(200) := '';
-- BEGIN
--     IF p_email IS NULL OR p_email = '' THEN
--         v_validation_message := 'Email cannot be empty';
--     ELSIF POSITION('@' IN p_email) = 0 OR POSITION('.' IN p_email) = 0 THEN
--         v_validation_message := 'Invalid email format';
--     ELSIF LENGTH(p_email) > 100 THEN
--         v_validation_message := 'Email too long (max 100 characters)';
--     ELSE
--         v_is_valid := TRUE;
--         v_validation_message := 'Valid email';
--     END IF;
    
--     RETURN QUERY SELECT v_is_valid, v_validation_message;
-- END;
-- $$ LANGUAGE plpgsql;

-- -- Validate National ID (Kenya format)
-- CREATE OR REPLACE FUNCTION sp_validate_national_id(p_national_id VARCHAR(20))
-- RETURNS TABLE(is_valid BOOLEAN, validation_message VARCHAR(200), formatted_national_id VARCHAR(20)) AS $$
-- DECLARE
--     v_is_valid BOOLEAN := FALSE;
--     v_validation_message VARCHAR(200) := '';
--     v_formatted_id VARCHAR(20);
-- BEGIN
--     -- Remove spaces and convert to upper case
--     v_formatted_id := UPPER(REPLACE(p_national_id, ' ', ''));
    
--     IF p_national_id IS NULL OR p_national_id = '' THEN
--         v_validation_message := 'National ID cannot be empty';
--     ELSIF LENGTH(v_formatted_id) < 7 OR LENGTH(v_formatted_id) > 8 THEN
--         v_validation_message := 'National ID must be 7-8 characters long';
--     ELSIF v_formatted_id !~ '^[0-9]{7,8}$' THEN
--         v_validation_message := 'National ID must contain only numbers';
--     ELSE
--         v_is_valid := TRUE;
--         v_validation_message := 'Valid National ID';
--     END IF;
    
--     RETURN QUERY SELECT v_is_valid, v_validation_message, v_formatted_id;
-- END;
-- $$ LANGUAGE plpgsql;

-- -- Validate Date
-- CREATE OR REPLACE FUNCTION sp_validate_date(
--     p_date_value DATE,
--     p_min_date DATE DEFAULT '1900-01-01',
--     p_max_date DATE DEFAULT '2100-12-31'
-- )
-- RETURNS TABLE(is_valid BOOLEAN, validation_message VARCHAR(200)) AS $$
-- DECLARE
--     v_is_valid BOOLEAN := FALSE;
--     v_validation_message VARCHAR(200) := '';
-- BEGIN
--     IF p_date_value IS NULL THEN
--         v_validation_message := 'Date cannot be null';
--     ELSIF p_date_value < p_min_date THEN
--         v_validation_message := 'Date is too early (minimum: ' || p_min_date::TEXT || ')';
--     ELSIF p_date_value > p_max_date THEN
--         v_validation_message := 'Date is too late (maximum: ' || p_max_date::TEXT || ')';
--     ELSE
--         v_is_valid := TRUE;
--         v_validation_message := 'Valid date';
--     END IF;
    
--     RETURN QUERY SELECT v_is_valid, v_validation_message;
-- END;
-- $$ LANGUAGE plpgsql;

-- -- Validate Time Range
-- CREATE OR REPLACE FUNCTION sp_validate_time_range(
--     p_start_time TIME,
--     p_end_time TIME
-- )
-- RETURNS TABLE(is_valid BOOLEAN, validation_message VARCHAR(200)) AS $$
-- DECLARE
--     v_is_valid BOOLEAN := FALSE;
--     v_validation_message VARCHAR(200) := '';
--     v_duration INTERVAL;
-- BEGIN
--     IF p_start_time IS NULL OR p_end_time IS NULL THEN
--         v_validation_message := 'Start time and end time cannot be null';
--     ELSIF p_start_time >= p_end_time THEN
--         v_validation_message := 'Start time must be before end time';
--     ELSE
--         v_duration := p_end_time - p_start_time;
        
--         IF EXTRACT(EPOCH FROM v_duration) < 900 THEN -- 15 minutes in seconds
--             v_validation_message := 'Time range must be at least 15 minutes';
--         ELSIF EXTRACT(EPOCH FROM v_duration) > 43200 THEN -- 12 hours in seconds
--             v_validation_message := 'Time range cannot exceed 12 hours';
--         ELSE
--             v_is_valid := TRUE;
--             v_validation_message := 'Valid time range';
--         END IF;
--     END IF;
    
--     RETURN QUERY SELECT v_is_valid, v_validation_message;
-- END;
-- $$ LANGUAGE plpgsql;

-- -- Check Data Integrity
-- CREATE OR REPLACE FUNCTION sp_check_data_integrity(p_agent_id UUID)
-- RETURNS TABLE(
--     issue_type VARCHAR(50),
--     issue_count BIGINT,
--     description VARCHAR(100)
-- ) AS $$
-- BEGIN
--     RETURN QUERY
--     SELECT 
--         'OrphanedAppointments'::VARCHAR(50) AS issue_type,
--         COUNT(*)::BIGINT AS issue_count,
--         'Appointments without valid clients'::VARCHAR(100) AS description
--     FROM appointments a
--     LEFT JOIN clients c ON a.client_id = c.client_id
--     WHERE c.client_id IS NULL
    
--     UNION ALL
    
--     SELECT 
--         'OrphanedPolicies'::VARCHAR(50),
--         COUNT(*)::BIGINT,
--         'Client policies without valid clients'::VARCHAR(100)
--     FROM client_policies cp
--     LEFT JOIN clients c ON cp.client_id = c.client_id
--     WHERE c.client_id IS NULL
    
--     UNION ALL
    
--     SELECT 
--         'OrphanedReminders'::VARCHAR(50),
--         COUNT(*)::BIGINT,
--         'Reminders without valid clients'::VARCHAR(100)
--     FROM reminders r
--     LEFT JOIN clients c ON r.client_id = c.client_id
--     WHERE r.client_id IS NOT NULL AND c.client_id IS NULL
    
--     UNION ALL
    
--     SELECT 
--         'DuplicateEmails'::VARCHAR(50),
--         (COUNT(*) - COUNT(DISTINCT email))::BIGINT,
--         'Clients with duplicate email addresses'::VARCHAR(100)
--     FROM clients
--     WHERE agent_id = p_agent_id AND is_active = TRUE
    
--     UNION ALL
    
--     SELECT 
--         'DuplicatePhones'::VARCHAR(50),
--         (COUNT(*) - COUNT(DISTINCT phone_number))::BIGINT,
--         'Clients with duplicate phone numbers'::VARCHAR(100)
--     FROM clients
--     WHERE agent_id = p_agent_id AND is_active = TRUE
    
--     UNION ALL
    
--     SELECT 
--         'DuplicateNationalIds'::VARCHAR(50),
--         (COUNT(*) - COUNT(DISTINCT national_id))::BIGINT,
--         'Clients with duplicate national IDs'::VARCHAR(100)
--     FROM clients
--     WHERE agent_id = p_agent_id AND is_active = TRUE
    
--     UNION ALL
    
--     SELECT 
--         'FutureAppointments'::VARCHAR(50),
--         COUNT(*)::BIGINT,
--         'Appointments scheduled more than 1 year in future'::VARCHAR(100)
--     FROM appointments a
--     INNER JOIN clients c ON a.client_id = c.client_id
--     WHERE c.agent_id = p_agent_id 
--         AND a.appointment_date > (NOW() + INTERVAL '1 year')
    
--     UNION ALL
    
--     SELECT 
--         'ExpiredActiveReminders'::VARCHAR(50),
--         COUNT(*)::BIGINT,
--         'Active reminders with past dates'::VARCHAR(100)
--     FROM reminders r
--     WHERE r.agent_id = p_agent_id 
--         AND r.status = 'Active'
--         AND r.reminder_date < CURRENT_DATE;
-- END;
-- $$ LANGUAGE plpgsql;

-- -- ============================================
-- -- Utility Service Functions
-- -- ============================================

-- -- Calculate Age Function
-- CREATE OR REPLACE FUNCTION fn_calculate_age(p_date_of_birth DATE)
-- RETURNS INTEGER AS $$
-- BEGIN
--     RETURN DATE_PART('year', AGE(p_date_of_birth));
-- END;
-- $$ LANGUAGE plpgsql;

-- -- Calculate Days Until Expiry Function
-- CREATE OR REPLACE FUNCTION fn_days_until_expiry(p_expiry_date DATE)
-- RETURNS INTEGER AS $$
-- BEGIN
--     RETURN (p_expiry_date - CURRENT_DATE);
-- END;
-- $$ LANGUAGE plpgsql;

-- -- Format Client Name Function
-- CREATE OR REPLACE FUNCTION fn_format_client_name(
--     p_first_name VARCHAR(50),
--     p_surname VARCHAR(50),
--     p_last_name VARCHAR(50) DEFAULT NULL
-- )
-- RETURNS VARCHAR(152) AS $$
-- BEGIN
--     RETURN TRIM(p_first_name) || ' ' || 
--            TRIM(p_surname) || 
--            CASE 
--                WHEN p_last_name IS NOT NULL AND p_last_name != '' 
--                THEN ' ' || TRIM(p_last_name)
--                ELSE ''
--            END;
-- END;
-- $$ LANGUAGE plpgsql;

-- -- Format Phone Number
-- CREATE OR REPLACE FUNCTION sp_format_phone_number(
--     p_phone_number VARCHAR(20),
--     p_country_code VARCHAR(5) DEFAULT '+254'
-- )
-- RETURNS TABLE(formatted_phone_number VARCHAR(20)) AS $$
-- DECLARE
--     v_formatted_number VARCHAR(20) := '';
--     v_clean_number VARCHAR(20);
-- BEGIN
--     -- Remove spaces, dashes, and other formatting
--     v_clean_number := REPLACE(REPLACE(REPLACE(p_phone_number, ' ', ''), '-', ''), '(', '');
--     v_clean_number := REPLACE(REPLACE(REPLACE(v_clean_number, ')', ''), '+', ''), '.', '');
    
--     -- Format for Kenya
--     IF LENGTH(v_clean_number) = 10 AND LEFT(v_clean_number, 1) = '0' THEN
--         v_formatted_number := p_country_code || RIGHT(v_clean_number, 9);
--     ELSIF LENGTH(v_clean_number) = 9 THEN
--         v_formatted_number := p_country_code || v_clean_number;
--     ELSIF LENGTH(v_clean_number) = 13 AND LEFT(v_clean_number, 3) = '254' THEN
--         v_formatted_number := '+' || v_clean_number;
--     ELSE
--         v_formatted_number := p_phone_number;
--     END IF;
    
--     RETURN QUERY SELECT v_formatted_number;
-- END;
-- $$ LANGUAGE plpgsql;

-- -- Format Currency
-- CREATE OR REPLACE FUNCTION fn_format_currency(p_amount DECIMAL(10,2))
-- RETURNS VARCHAR(20) AS $$
-- BEGIN
--     RETURN 'KSH ' || TO_CHAR(p_amount, 'FM999,999,990.00');
-- END;
-- $$ LANGUAGE plpgsql;

-- -- Generate ID
-- CREATE OR REPLACE FUNCTION fn_generate_id()
-- RETURNS UUID AS $$
-- BEGIN
--     RETURN gen_random_uuid();
-- END;
-- $$ LANGUAGE plpgsql;

-- -- Get Greeting
-- CREATE OR REPLACE FUNCTION sp_get_greeting()
-- RETURNS TABLE(greeting VARCHAR(20)) AS $$
-- DECLARE
--     v_current_hour INTEGER;
--     v_greeting VARCHAR(20);
-- BEGIN
--     v_current_hour := EXTRACT(HOUR FROM NOW());
    
--     v_greeting := CASE 
--         WHEN v_current_hour < 12 THEN 'Good Morning'
--         WHEN v_current_hour < 17 THEN 'Good Afternoon'
--         ELSE 'Good Evening'
--     END;
    
--     RETURN QUERY SELECT v_greeting;
-- END;
-- $$ LANGUAGE plpgsql;

-- -- Get Status Color
-- CREATE OR REPLACE FUNCTION fn_get_status_color(p_status VARCHAR(20))
-- RETURNS VARCHAR(20) AS $$
-- BEGIN
--     RETURN CASE p_status
--         WHEN 'Active' THEN 'success'
--         WHEN 'Completed' THEN 'success'
--         WHEN 'Confirmed' THEN 'info'
--         WHEN 'Scheduled' THEN 'primary'
--         WHEN 'In Progress' THEN 'warning'
--         WHEN 'Cancelled' THEN 'danger'
--         WHEN 'Expired' THEN 'danger'
--         WHEN 'Inactive' THEN 'secondary'
--         WHEN 'Lapsed' THEN 'danger'
--         ELSE 'secondary'
--     END;
-- END;
-- $$ LANGUAGE plpgsql;

-- -- Get Priority Color
-- CREATE OR REPLACE FUNCTION fn_get_priority_color(p_priority VARCHAR(10))
-- RETURNS VARCHAR(20) AS $$
-- BEGIN
--     RETURN CASE p_priority
--         WHEN 'High' THEN 'danger'
--         WHEN 'Medium' THEN 'warning'
--         WHEN 'Low' THEN 'info'
--         ELSE 'secondary'
--     END;
-- END;
-- $$ LANGUAGE plpgsql;

-- -- Get Appointment Type Icon
-- CREATE OR REPLACE FUNCTION fn_get_appointment_type_icon(p_type VARCHAR(50))
-- RETURNS VARCHAR(20) AS $$
-- BEGIN
--     RETURN CASE p_type
--         WHEN 'Call' THEN 'phone'
--         WHEN 'Meeting' THEN 'users'
--         WHEN 'Site Visit' THEN 'map-pin'
--         WHEN 'Policy Review' THEN 'file-text'
--         WHEN 'Claim Processing' THEN 'clipboard'
--         ELSE 'calendar'
--     END;
-- END;
-- $$ LANGUAGE plpgsql;

-- -- Parse Template
-- CREATE OR REPLACE FUNCTION sp_parse_template(
--     p_template TEXT,
--     p_client_name VARCHAR(150) DEFAULT NULL,
--     p_agent_name VARCHAR(100) DEFAULT NULL,
--     p_policy_type VARCHAR(50) DEFAULT NULL,
--     p_expiry_date DATE DEFAULT NULL,
--     p_company_name VARCHAR(100) DEFAULT NULL
-- )
-- RETURNS TABLE(parsed_template TEXT) AS $$
-- DECLARE
--     v_parsed_template TEXT;
-- BEGIN
--     v_parsed_template := p_template;
    
--     -- Replace common placeholders
--     v_parsed_template := REPLACE(v_parsed_template, '{name}', COALESCE(p_client_name, '{name}'));
--     v_parsed_template := REPLACE(v_parsed_template, '{client_name}', COALESCE(p_client_name, '{client_name}'));
--     v_parsed_template := REPLACE(v_parsed_template, '{agent_name}', COALESCE(p_agent_name, '{agent_name}'));
--     v_parsed_template := REPLACE(v_parsed_template, '{policy_type}', COALESCE(p_policy_type, '{policy_type}'));
--     v_parsed_template := REPLACE(v_parsed_template, '{expiry_date}', COALESCE(p_expiry_date::TEXT, '{expiry_date}'));
--     v_parsed_template := REPLACE(v_parsed_template, '{company_name}', COALESCE(p_company_name, '{company_name}'));
--     v_parsed_template := REPLACE(v_parsed_template, '{current_date}', NOW()::DATE::TEXT);
--     v_parsed_template := REPLACE(v_parsed_template, '{current_year}', EXTRACT(YEAR FROM NOW())::TEXT);
    
--     RETURN QUERY SELECT v_parsed_template;
-- END;
-- $$ LANGUAGE plpgsql;

-- -- Generate Random Password
-- CREATE OR REPLACE FUNCTION sp_generate_random_password(p_length INTEGER DEFAULT 12)
-- RETURNS TABLE(random_password VARCHAR(50)) AS $$
-- DECLARE
--     v_password VARCHAR(50) := '';
--     v_characters VARCHAR(100) := 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*';
--     v_char_length INTEGER;
--     v_counter INTEGER := 0;
-- BEGIN
--     v_char_length := LENGTH(v_characters);
    
--     WHILE v_counter < p_length LOOP
--         v_password := v_password || SUBSTRING(v_characters FROM (FLOOR(RANDOM() * v_char_length) + 1) FOR 1);
--         v_counter := v_counter + 1;
--     END LOOP;
    
--     RETURN QUERY SELECT v_password;
-- END;
-- $$ LANGUAGE plpgsql;

-- -- ============================================
-- -- Notification Service Functions
-- -- ============================================

-- -- Create Notifications Table (if not exists)
-- CREATE TABLE IF NOT EXISTS notifications (
--     notification_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
--     agent_id UUID NOT NULL,
--     notification_type VARCHAR(20) NOT NULL CHECK (notification_type IN ('Email', 'SMS', 'WhatsApp', 'Push')),
--     recipient VARCHAR(200) NOT NULL,
--     subject VARCHAR(200),
--     body TEXT NOT NULL,
--     status VARCHAR(20) DEFAULT 'Pending' CHECK (status IN ('Pending', 'Sent', 'Failed', 'Cancelled')),
--     scheduled_time TIMESTAMPTZ,
--     sent_time TIMESTAMPTZ,
--     error_message VARCHAR(500),
--     retry_count INTEGER DEFAULT 0,
--     created_date TIMESTAMPTZ DEFAULT NOW(),
--     FOREIGN KEY (agent_id) REFERENCES agent(agent_id) ON DELETE CASCADE
-- );

-- -- Send Email Notification
-- CREATE OR REPLACE FUNCTION sp_send_email_notification(
--     p_agent_id UUID,
--     p_to_email VARCHAR(200),
--     p_subject VARCHAR(200),
--     p_body TEXT
-- )
-- RETURNS TABLE(notification_id UUID, success BOOLEAN) AS $$
-- DECLARE
--     v_notification_id UUID := gen_random_uuid();
-- BEGIN
--     INSERT INTO notifications (
--         notification_id, agent_id, notification_type, recipient, subject, body, status
--     )
--     VALUES (
--         v_notification_id, p_agent_id, 'Email', p_to_email, p_subject, p_body, 'Pending'
--     );
    
--     -- In a real implementation, this would integrate with an email service
--     -- For now, we'll just mark it as sent
--     UPDATE notifications 
--     SET status = 'Sent', sent_time = NOW()
--     WHERE notification_id = v_notification_id;
    
--     RETURN QUERY SELECT v_notification_id, TRUE;
-- END;
-- $$ LANGUAGE plpgsql;

-- -- Send SMS Notification
-- CREATE OR REPLACE FUNCTION sp_send_sms_notification(
--     p_agent_id UUID,
--     p_phone_number VARCHAR(20),
--     p_message TEXT
-- )
-- RETURNS TABLE(notification_id UUID, success BOOLEAN) AS $$
-- DECLARE
--     v_notification_id UUID := gen_random_uuid();
--     v_success BOOLEAN;
-- BEGIN
--     INSERT INTO notifications (
--         notification_id, agent_id, notification_type, recipient, body, status
--     )
--     VALUES (
--         v_notification_id, p_agent_id, 'SMS', p_phone_number, p_message, 'Pending'
--     );
    
--     -- In a real implementation, this would integrate with an SMS service
--     -- For now, we'll simulate success/failure
--     v_success := (RANDOM() > 0.1); -- 90% success rate
    
--     IF v_success THEN
--         UPDATE notifications 
--         SET status = 'Sent', sent_time = NOW()
--         WHERE notification_id = v_notification_id;
--     ELSE
--         UPDATE notifications 
--         SET status = 'Failed', error_message = 'Simulated SMS delivery failure'
--         WHERE notification_id = v_notification_id;
--     END IF;
    
--     RETURN QUERY SELECT v_notification_id, v_success;
-- END;
-- $$ LANGUAGE plpgsql;

-- -- Send WhatsApp Notification
-- CREATE OR REPLACE FUNCTION sp_send_whatsapp_notification(
--     p_agent_id UUID,
--     p_phone_number VARCHAR(20),
--     p_message TEXT
-- )
-- RETURNS TABLE(notification_id UUID, success BOOLEAN) AS $$
-- DECLARE
--     v_notification_id UUID := gen_random_uuid();
-- BEGIN
--     INSERT INTO notifications (
--         notification_id, agent_id, notification_type, recipient, body, status
--     )
--     VALUES (
--         v_notification_id, p_agent_id, 'WhatsApp', p_phone_number, p_message, 'Pending'
--     );
    
--     -- In a real implementation, this would integrate with WhatsApp Business API
--     -- For now, we'll simulate success
--     UPDATE notifications 
--     SET status = 'Sent', sent_time = NOW()
--     WHERE notification_id = v_notification_id;
    
--     RETURN QUERY SELECT v_notification_id, TRUE;
-- END;
-- $$ LANGUAGE plpgsql;

-- -- Send Push Notification
-- CREATE OR REPLACE FUNCTION sp_send_push_notification(
--     p_agent_id UUID,
--     p_title VARCHAR(200),
--     p_body TEXT
-- )
-- RETURNS TABLE(notification_id UUID, success BOOLEAN) AS $$
-- DECLARE
--     v_notification_id UUID := gen_random_uuid();
-- BEGIN
--     INSERT INTO notifications (
--         notification_id, agent_id, notification_type, recipient, subject, body, status
--     )
--     VALUES (
--         v_notification_id, p_agent_id, 'Push', p_agent_id::TEXT, p_title, p_body, 'Pending'
--     );
    
--     -- In a real implementation, this would integrate with push notification service
--     UPDATE notifications 
--     SET status = 'Sent', sent_time = NOW()
--     WHERE notification_id = v_notification_id;
    
--     RETURN QUERY SELECT v_notification_id, TRUE;
-- END;
-- $$ LANGUAGE plpgsql;

-- -- Schedule Notification
-- CREATE OR REPLACE FUNCTION sp_schedule_notification(
--     p_agent_id UUID,
--     p_scheduled_time TIMESTAMPTZ,
--     p_notification_type VARCHAR(20),
--     p_recipient VARCHAR(200),
--     p_subject VARCHAR(200) DEFAULT NULL,
--     p_body TEXT
-- )
-- RETURNS TABLE(notification_id UUID) AS $$
-- DECLARE
--     v_notification_id UUID := gen_random_uuid();
-- BEGIN
--     INSERT INTO notifications (
--         notification_id, agent_id, notification_type, recipient, subject, body, scheduled_time, status
--     )
--     VALUES (
--         v_notification_id, p_agent_id, p_notification_type, p_recipient, p_subject, p_body, p_scheduled_time, 'Pending'
--     );
    
--     RETURN QUERY SELECT v_notification_id;
-- END;
-- $$ LANGUAGE plpgsql;

-- -- Cancel Scheduled Notification
-- CREATE OR REPLACE FUNCTION sp_cancel_scheduled_notification(
--     p_notification_id UUID,
--     p_agent_id UUID
-- )
-- RETURNS TABLE(rows_affected INTEGER) AS $$
-- DECLARE
--     v_rows_affected INTEGER;
-- BEGIN
--     UPDATE notifications 
--     SET status = 'Cancelled'
--     WHERE notification_id = p_notification_id 
--         AND agent_id = p_agent_id 
--         AND status = 'Pending';
    
--     GET DIAGNOSTICS v_rows_affected = ROW_COUNT;
    
--     RETURN QUERY SELECT v_rows_affected;
-- END;
-- $$ LANGUAGE plpgsql;

-- -- Process Scheduled Notifications
-- CREATE OR REPLACE FUNCTION sp_process_scheduled_notifications()
-- RETURNS TABLE(
--     notification_id UUID,
--     agent_id UUID,
--     notification_type VARCHAR(20),
--     recipient VARCHAR(200),
--     subject VARCHAR(200),
--     body TEXT,
--     scheduled_time TIMESTAMPTZ
-- ) AS $$
-- BEGIN
--     RETURN QUERY
--     SELECT 
--         n.notification_id,
--         n.agent_id,
--         n.notification_type,
--         n.recipient,
--         n.subject,
--         n.body,
--         n.scheduled_time
--     FROM notifications n
--     WHERE n.status = 'Pending'
--         AND n.scheduled_time IS NOT NULL
--         AND n.scheduled_time <= NOW()
--     ORDER BY n.scheduled_time ASC;
-- END;
-- $$ LANGUAGE plpgsql;

-- -- Get Notification History
-- CREATE OR REPLACE FUNCTION sp_get_notification_history(
--     p_agent_id UUID,
--     p_start_date DATE DEFAULT NULL,
--     p_end_date DATE DEFAULT NULL,
--     p_notification_type VARCHAR(20) DEFAULT NULL,
--     p_status VARCHAR(20) DEFAULT NULL,
--     p_page_size INTEGER DEFAULT 50,
--     p_page_number INTEGER DEFAULT 1
-- )
-- RETURNS TABLE(
--     notification_id UUID,
--     notification_type VARCHAR(20),
--     recipient VARCHAR(200),
--     subject VARCHAR(200),
--     body TEXT,
--     status VARCHAR(20),
--     scheduled_time TIMESTAMPTZ,
--     sent_time TIMESTAMPTZ,
--     error_message VARCHAR(500),
--     retry_count INTEGER,
--     created_date TIMESTAMPTZ,
--     total_records BIGINT
-- ) AS $$
-- DECLARE
--     v_start_date DATE;
--     v_end_date DATE;
--     v_offset INTEGER;
--     v_total_records BIGINT;
-- BEGIN
--     v_start_date := COALESCE(p_start_date, CURRENT_DATE - INTERVAL '30 days');
--     v_end_date := COALESCE(p_end_date, CURRENT_DATE);
--     v_offset := (p_page_number - 1) * p_page_size;
    
--     -- Get total count
--     SELECT COUNT(*)
--     INTO v_total_records
--     FROM notifications n
--     WHERE 
--         n.agent_id = p_agent_id
--         AND n.created_date::DATE BETWEEN v_start_date AND v_end_date
--         AND (p_notification_type IS NULL OR n.notification_type = p_notification_type)
--         AND (p_status IS NULL OR n.status = p_status);
    
--     RETURN QUERY
--     SELECT 
--         n.notification_id,
--         n.notification_type,
--         n.recipient,
--         n.subject,
--         n.body,
--         n.status,
--         n.scheduled_time,
--         n.sent_time,
--         n.error_message,
--         n.retry_count,
--         n.created_date,
--         v_total_records
--     FROM notifications n
--     WHERE 
--         n.agent_id = p_agent_id
--         AND n.created_date::DATE BETWEEN v_start_date AND v_end_date
--         AND (p_notification_type IS NULL OR n.notification_type = p_notification_type)
--         AND (p_status IS NULL OR n.status = p_status)
--     ORDER BY n.created_date DESC
--     LIMIT p_page_size OFFSET v_offset;
-- END;
-- $$ LANGUAGE plpgsql;

-- -- Update Notification Status
-- CREATE OR REPLACE FUNCTION sp_update_notification_status(
--     p_notification_id UUID,
--     p_status VARCHAR(20),
--     p_error_message VARCHAR(500) DEFAULT NULL
-- )
-- RETURNS TABLE(rows_affected INTEGER) AS $$
-- DECLARE
--     v_rows_affected INTEGER;
-- BEGIN
--     UPDATE notifications 
--     SET 
--         status = p_status,
--         sent_time = CASE WHEN p_status = 'Sent' THEN NOW() ELSE sent_time END,
--         error_message = p_error_message,
--         retry_count = CASE WHEN p_status = 'Failed' THEN retry_count + 1 ELSE retry_count END
--     WHERE notification_id = p_notification_id;
    
--     GET DIAGNOSTICS v_rows_affected = ROW_COUNT;
    
--     RETURN QUERY SELECT v_rows_affected;
-- END;
-- $$ LANGUAGE plpgsql;